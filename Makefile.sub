# User-settable parameters.
# Pass these at 'make' invocation time to the top-level Makefile.

# (MODE is set from top-level Makefile and persisted to .stamp-mode.)

# Set NO_GIT=1 if you are using MODE=dev and do not want to build or run
# a Git daemon.
NO_GIT ?=

# Set NET_EXTERNAL=interface to use a non-default interface for the
# "External" (192.168.1.0/24) network.
NET_EXTERNAL ?= tap200

# Set NET_INTERNAL=interface to use a non-default interface for the
# "Internal" (169.254.169.0/24) network.
NET_INTERNAL ?= tap201

# Set KEYFENDER_CARGS=arguments to override arguments passed to mirage configure
# for the Keyfender unikernel. Default for MODE=muen is '--retry=true'.
# (actual setting is performed later)

# Set MUEN_TARGET to qemu-kvm or supermicro-x11ssh-tf.
# TODO: This should be persisted similarly to MODE=, or otherwise detect that
# it changed?
MUEN_TARGET ?= qemu-kvm

# ------------------------------------------------------------------------------

TOP_DIR := $(abspath .)

.SUFFIXES:

# Ensure that variables specified on the (top-level) 'make' command line are
# NOT passed down to sub-makes invoked by this Makefile. Doing so would pass
# down e.g. $(MODE), which is an overloaded name and breaks third-party
# "downstream" Makefiles.
MAKEOVERRIDES =

# Do not run any jobs in *this* Makefile in parallel. This would not gain us
# anything and complicates the output. -j is still passed to and honored by
# recursively called Makefiles.
.NOTPARALLEL:

.PHONY: all
all:
	@echo Error: Makefile.sub should not be invoked directly
	@false

# We cannot use $(MODE) in this Makefile, as that can be overriden by the user
# in the top-level Makefile, and we need either the "last used mode" from
# .stamp-mode OR 'dev' if this is a fresh/distclean'd tree.
XMODE := $(shell cat .stamp-mode 2>/dev/null)

# List of top-level submodules required to be initialised and cloned in
# 'make prepare'. This is initially empty, and set below depending on MODE and
# NO_GIT.
REQUIRED_SUBMODULES :=

ifeq ($(XMODE),)
XMODE := dev
endif
ifeq ($(XMODE),dev)
TARGET := hvt
KEYFENDER_CARGS ?=
ifeq ($(NO_GIT),)
REQUIRED_SUBMODULES += src/git
endif
else ifeq ($(XMODE),muen)
TARGET := muen
KEYFENDER_CARGS ?= --retry=true
REQUIRED_SUBMODULES += src/git src/zlib src/muen/muen \
    src/u-root/src/github.com/u-root/u-root
else
$(error Invalid MODE '$(XMODE)')
endif

# ------------------------------------------------------------------------------
#
# Rules for 'prepare' step. Common to all MODEs.
#
# ------------------------------------------------------------------------------

.stamp-prepare:
ifneq ($(REQUIRED_SUBMODULES),)
	git submodule update --init --depth 1 -- $(REQUIRED_SUBMODULES)
ifeq ($(XMODE),muen)
	git -C src/muen/muen submodule update --init --depth 1
endif
endif
	opam install -y depext
	opam pin add -y -n keyfender $(TOP_DIR)/src/keyfender#HEAD
	opam depext --yes --update keyfender mirage solo5-bindings-$(TARGET) mirage-solo5
	opam install -y mirage solo5-bindings-$(TARGET) mirage-solo5
	opam install -y --deps-only keyfender
	touch $@

.PHONY: prepare
prepare: .stamp-prepare

distclean: clean
	-opam pin remove -y $(TOP_DIR)/src/keyfender#HEAD
	$(RM) .stamp-prepare

# ------------------------------------------------------------------------------
#
# Rules for building the keyfender library, and the S-Keyfender unikernel.
# Common to all MODEs.
#
# ------------------------------------------------------------------------------

KEYFENDER := src/keyfender/_build/default/keyfender.cmxa
KEYFENDER_INSTALL := src/keyfender/_build/default/stamp-install
S_KEYFENDER := src/s_keyfender/keyfender.$(TARGET)
GIT_DAEMON ?= src/git/git-daemon

$(KEYFENDER): .stamp-prepare
	cd src/keyfender && dune build

# XXX We want to use --assume-built here, but that causes OPAM to go off into an
# XXX infinite loop. So just use --inplace-build, and deal with 'dune build'
# XXX being run twice.
$(KEYFENDER_INSTALL): $(KEYFENDER)
	opam reinstall -y --inplace-build keyfender
	touch $@

.PHONY: clean-keyfender
clean-keyfender:
	-opam remove -y keyfender
	$(RM) $(KEYFENDER_INSTALL)
	-cd src/keyfender && dune clean
	-cd src/s_keyfender && mirage clean

$(S_KEYFENDER): $(KEYFENDER_INSTALL)
	cd src/s_keyfender && mirage configure -t $(TARGET) $(KEYFENDER_CARGS)
	cd src/s_keyfender && $(MAKE) depend
	cd src/s_keyfender && mirage build

.PHONY: build-keyfender
build-keyfender: $(S_KEYFENDER)

.PHONY: test-keyfender-lib test-keyfender-api test-keyfender-e2e
test-keyfender-lib: .stamp-prepare
	cd src/keyfender && opam install --deps-only -t .
	cd src/keyfender && dune runtest

test-keyfender-api: $(KEYFENDER)
	cd src/tests/generated && ./test.sh

test-keyfender-e2e: $(KEYFENDER)
	pkill test_server.exe || true
	src/keyfender/_build/default/test/test_server.exe &
	sleep 2
	NITROHSM_URL="http://localhost:8080/api" ITERS=1 JOBS=1 src/tests/provision_test.sh
	NITROHSM_URL="http://localhost:8080/api" ITERS=1 JOBS=1 src/tests/load_test.sh
	pkill test_server.exe || true

ifeq ($(XMODE),dev)
# ------------------------------------------------------------------------------
#
# Rules for building and running a local development system using Solo5/hvt.
#
# ------------------------------------------------------------------------------

RUN_DIR := $(TOP_DIR)/run

ifeq ($(NO_GIT),)

GIT_MAKEFLAGS := NO_PERL=1 NO_OPENSSL=1 NO_CURL=1 NO_EXPAT=1 NO_TCLTK=1 \
    NO_GETTEXT=1 NO_PYTHON=1

$(GIT_DAEMON):
	$(MAKE) -C src/git $(GIT_MAKEFLAGS) all

else

$(GIT_DAEMON): ;

endif

.PHONY: build
build: $(S_KEYFENDER) $(GIT_DAEMON)

ifeq ($(NO_GIT),)

$(RUN_DIR)/git/keyfender-data.git:
	mkdir -p $@
	git init --bare $@

$(RUN_DIR)/git-daemon.pid: | $(RUN_DIR)/git/keyfender-data.git
	src/git/bin-wrappers/git daemon \
	    --listen=169.254.169.2 \
	    --base-path=$(RUN_DIR)/git \
	    --export-all \
	    --enable=receive-pack \
	    --pid-file=$@ &

else

$(RUN_DIR)/git-daemon.pid: ;

endif

.PHONY: run
run: build $(RUN_DIR)/git-daemon.pid
	solo5-hvt \
	    --net:external=$(NET_EXTERNAL) \
	    --net:internal=$(NET_INTERNAL) \
	    $(S_KEYFENDER)

.PHONY: clean
clean: clean-keyfender
ifeq ($(NO_GIT),)
	-test -f $(RUN_DIR)/git-daemon.pid && \
	    kill $$(cat $(RUN_DIR)/git-daemon.pid) && \
	    rm $(RUN_DIR)/git-daemon.pid
	$(MAKE) -C src/git --silent --no-print-directory distclean
endif
	$(RM) -r $(RUN_DIR)

else ifeq ($(XMODE),muen)
# ------------------------------------------------------------------------------
#
# Rules for building and running an emulated Muen system.
#
# ------------------------------------------------------------------------------

POLICY_DIR=$(TOP_DIR)/src/muen/policy
ifeq ($(MUEN_TARGET),qemu-kvm)
MUEN_HARDWARE=$(POLICY_DIR)/hardware/nitrohsm-$(MUEN_TARGET).xml
MUEN_PLATFORM=$(POLICY_DIR)/platform/nitrohsm-$(MUEN_TARGET).xml
MUEN_LINUX_CONFIG=$(TOP_DIR)/src/muen/muen/components/linux/config/linux64-4.18
else ifeq ($(MUEN_TARGET),supermicro-x11ssh-tf)
MUEN_HARDWARE=$(POLICY_DIR)/hardware/nitrohsm-$(MUEN_TARGET).xml
MUEN_PLATFORM=$(POLICY_DIR)/platform/nitrohsm-$(MUEN_TARGET).xml
MUEN_LINUX_CONFIG=$(TOP_DIR)/src/muen/linux/config-4.18-$(MUEN_TARGET)
else
$(error Invalid MUEN_TARGET)
endif

OBJ_DIR := $(TOP_DIR)/obj
OBJ_DATA_DIR := $(OBJ_DIR)/data
OBJ_INITRAMFS_DIR := $(OBJ_DIR)/initramfs
OBJ_GIT_BIN_DIR := $(OBJ_INITRAMFS_DIR)/bin
OBJ_GIT_LIBEXEC_DIR := $(OBJ_INITRAMFS_DIR)/libexec/git-core
OBJ_DATA_GIT_DIR := $(OBJ_DATA_DIR)/git
OBJ_QEMU_DISK_IMG := $(OBJ_DIR)/disk.img

$(OBJ_DIR):
	mkdir -p $@

ZLIB_DIR := $(TOP_DIR)/src/zlib
ZLIB_LIBZ := $(ZLIB_DIR)/libz.a

# The symlinks below are so that we can pass $(ZLIB_DIR) directly to Git's
# build system without a separate "install" step.
$(ZLIB_DIR)/stamp-configure: $(ZLIB_DIR)/configure $(ZLIB_DIR)/Makefile.in
	cd $(ZLIB_DIR) && CC=x86_64-linux-musl-gcc ./configure --static
	cd $(ZLIB_DIR) && ln -s . include
	cd $(ZLIB_DIR) && ln -s . lib
	touch $@

$(ZLIB_LIBZ): $(ZLIB_DIR)/stamp-configure
	$(MAKE) -C $(ZLIB_DIR)

GIT_MAKEFLAGS := NO_PERL=1 NO_OPENSSL=1 NO_CURL=1 NO_EXPAT=1 NO_TCLTK=1 \
    NO_GETTEXT=1 NO_PYTHON=1 NO_REGEX=NeedsStartEnd \
    HOST_CPU=x86_64 CC=x86_64-linux-musl-gcc \
    LDFLAGS=-static ZLIB_PATH=$(ZLIB_DIR) \
    INSTALL_SYMLINKS=1 \
    prefix=/ DESTDIR=$(OBJ_INITRAMFS_DIR)

$(GIT_DAEMON): $(ZLIB_LIBZ)
	$(MAKE) -C src/git $(GIT_MAKEFLAGS) all strip

INSTALL_GIT_DAEMON := $(OBJ_GIT_LIBEXEC_DIR)/git-daemon

$(INSTALL_GIT_DAEMON): $(GIT_DAEMON) | $(OBJ_DIR)
	$(MAKE) -C src/git $(GIT_MAKEFLAGS) install
	$(RM) $(OBJ_GIT_LIBEXEC_DIR)/git-credential-*
	$(RM) $(OBJ_GIT_LIBEXEC_DIR)/git-cvs*
	$(RM) $(OBJ_GIT_LIBEXEC_DIR)/git-http-backend
	$(RM) $(OBJ_GIT_LIBEXEC_DIR)/git-imap-send
	$(RM) $(OBJ_GIT_LIBEXEC_DIR)/git-remote-testsvn
	$(RM) $(OBJ_GIT_LIBEXEC_DIR)/git-shell
	$(RM) $(OBJ_GIT_BIN_DIR)/git-cvsserver
	$(RM) $(OBJ_GIT_BIN_DIR)/git-shell

OBJ_INITRAMFS_CPIO := $(OBJ_DIR)/initramfs.cpio
OBJ_INITRAMFS := $(OBJ_DIR)/initramfs.cpio.gz
U_ROOT_GOPATH := $(TOP_DIR)/src/u-root
U_ROOT_BIN := $(U_ROOT_GOPATH)/bin/u-root
U_ROOT_UINIT := nitrohsm/uinit
U_ROOT_PKGS := core $(U_ROOT_UINIT)

# Rather than using "export GOPATH" and thus potentially polluting the
# environment of *all* Makefiles called from this Makefile, ensure it is set
# explicitly and only for those recipes/commands that require it.
$(U_ROOT_BIN):
	GOPATH=$(U_ROOT_GOPATH) go install github.com/u-root/u-root

$(OBJ_INITRAMFS): $(U_ROOT_BIN) $(INSTALL_GIT_DAEMON)
	GOPATH=$(U_ROOT_GOPATH) $(U_ROOT_BIN) -format=cpio -build=bb \
	    -o $(OBJ_INITRAMFS_CPIO) \
	    -files "$(OBJ_INITRAMFS_DIR):/" \
	    $(U_ROOT_PKGS)
	gzip -9 -f $(OBJ_INITRAMFS_CPIO)

# Ensure u-root initramfs is rebuilt if nitrohsm uinit sources change.
# There might be a better way of doing this, but this will have to do for now.
$(OBJ_INITRAMFS): \
    $(U_ROOT_GOPATH)/src/nitrohsm/uinit/uinit.go \
    $(U_ROOT_GOPATH)/src/nitrohsm/uinit/script/script.go

MUEN_POLICY_OBJ_DIR := src/muen/muen/policy/obj
MUEN_PACK_OBJ_DIR := src/muen/muen/pack/obj
MUEN_S_KEYFENDER := $(MUEN_POLICY_OBJ_DIR)/keyfender.muen
MUEN_S_KEYFENDER_CSPEC := src/muen/policy/xml/component_unikernel.xml
MUEN_PACK_IMG := $(MUEN_PACK_OBJ_DIR)/muen.img
MUEN_GEN_CSPEC := src/muen/muen/tools/scripts/solo5-muen-gencspec.py
# XXX: Using --bootparams= here is not currently possible without using
# XXX: mirageos/compose.py, so we persist parameters at unikernel configure
# XXX: time instead.
MUEN_GEN_CSPEC_EXTRA :=

$(MUEN_S_KEYFENDER) $(MUEN_S_KEYFENDER_CSPEC): $(S_KEYFENDER)
	$(MUEN_GEN_CSPEC) \
	    --out_spec=$(MUEN_S_KEYFENDER_CSPEC) \
	    $(MUEN_GEN_CSPEC_EXTRA) \
	    $< \
	    src/muen/muen/policy/xml/mirageos/cspec_src.xml \
	    $(MUEN_POLICY_OBJ_DIR)

$(MUEN_PACK_IMG): $(MUEN_S_KEYFENDER) $(MUEN_S_KEYFENDER_CSPEC) $(OBJ_INITRAMFS)
	$(MAKE) -C src/muen/muen --silent --no-print-directory \
	    NO_PROOF=1 \
	    SYSTEM=$(TOP_DIR)/src/muen/policy/xml/nitrohsm_basic_system.xml \
	    HARDWARE=$(MUEN_HARDWARE) \
	    PLATFORM=$(MUEN_PLATFORM) \
	    LINUX_CONFIG=$(MUEN_LINUX_CONFIG) \
	    INITRAMFS=$(OBJ_INITRAMFS) \
	    pack

# XXX Files will be owned by the build user. Maybe run this from uinit once we
# XXX have a real S-Storage, and also run git daemon as non-root.
$(OBJ_DATA_GIT_DIR)/keyfender-data.git:
	mkdir -p $@
	git init --bare $@

$(OBJ_DATA_DIR): $(OBJ_DATA_GIT_DIR)/keyfender-data.git

$(OBJ_QEMU_DISK_IMG): $(MUEN_PACK_IMG) $(OBJ_DATA_DIR) tools/muen-mkdiskimage.sh
	tools/muen-mkdiskimage.sh $@ $< $(OBJ_DATA_DIR)

.PHONY: build
build: $(OBJ_QEMU_DISK_IMG)

RUN_DIR := $(TOP_DIR)/run
RUN_QEMU_DISK_IMG := $(RUN_DIR)/disk.img

$(RUN_QEMU_DISK_IMG): $(OBJ_QEMU_DISK_IMG)
	mkdir -p $(RUN_DIR)
	cp $< $@

$(RUN_DIR)/screenrc:
	echo "logfile $(RUN_DIR)/emulate.out" >$@

QEMU ?= qemu-system-x86_64

# Built manually, see coreboot/README.md
QEMU_BIOS_IMG := $(TOP_DIR)/coreboot/qemu/coreboot.rom

QEMU_OPTS := \
    -bios $(QEMU_BIOS_IMG) \
    -drive file=$(RUN_QEMU_DISK_IMG),format=raw \
    -serial file:run/serial.out \
    -machine q35,accel=kvm,kernel-irqchip=split \
    -cpu host,+invtsc \
    -m 5120 \
    -smp cores=2,threads=2,sockets=1 \
    -device intel-iommu,intremap=on,device-iotlb=on \
    -device ioh3420,id=pcie.1,chassis=1 \
    -device virtio-net-pci,bus=pcie.1,addr=0.0,netdev=net0,disable-legacy=on,disable-modern=off,iommu_platform=on,ats=on \
    -device qemu-xhci,id=xhci,bus=pcie.0,addr=3.0 \
    -device usb-tablet,bus=xhci.0 \
    -netdev tap,id=net0,ifname=$(NET_EXTERNAL),script=no,downscript=no \
    -curses
QEMU_PIDFILE := $(RUN_DIR)/qemu.pid

.PHONY: check-running
check-running:
	@if test -f $(QEMU_PIDFILE) && test -d /proc/`cat $(QEMU_PIDFILE)`; then \
	    echo "Error: QEMU still running, check $(QEMU_PIDFILE)"; \
	    false; \
	else \
	    true; \
	fi

.PHONY: run
run: $(RUN_QEMU_DISK_IMG) $(QEMU_BIOS_IMG) $(RUN_DIR)/screenrc check-running
	screen -c $(RUN_DIR)/screenrc -L -dmS kvm-muen \
	    $(QEMU) $(QEMU_OPTS) -pidfile $(RUN_DIR)/qemu.pid
	@echo -n "* QEMU/KVM started for '$(RUN_QEMU_DISK_IMG)', waiting for boot: "
	@for i in $$(seq 1 5); do \
	    sleep 1; \
	    echo -n .; \
	    boot=$$(cat $(RUN_DIR)/serial.out 2>/dev/null | grep 'Booting Muen'); \
	    if [ -n "$$boot" ]; then \
	        echo " OK"; echo; \
	        echo "Console: screen -r kvm-muen"; \
	        echo "         (C-A k to quit, C-A d to detach)"; \
	        break; \
	    fi; \
	done; \
	if [ -z "$$boot" ]; then echo "\nERROR:" && cat $(RUN_DIR)/emulate.out && exit 1; fi

.PHONY: clean
clean: clean-keyfender
	$(RM) $(MUEN_S_KEYFENDER) $(MUEN_S_KEYFENDER_CSPEC)
	$(MAKE) -C src/muen/muen --silent --no-print-directory distclean
	$(MAKE) -C src/git --silent --no-print-directory distclean
	$(MAKE) -C src/zlib --silent --no-print-directory distclean
	$(RM) $(ZLIB_DIR)/stamp-configure $(ZLIB_DIR)/include $(ZLIB_DIR)/lib
	$(RM) $(U_ROOT_BIN)
	$(RM) -r $(OBJ_DIR) $(RUN_DIR)

endif

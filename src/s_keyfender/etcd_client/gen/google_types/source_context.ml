(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: google/protobuf/source_context.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec Google : sig
  module rec Protobuf : sig

    (**
      `SourceContext` represents information about the source of a
      protobuf element, like the file in which it is defined.
    *)
    module rec SourceContext : sig
      type t = (string)
      (**
      The path-qualified name of the .proto file that contained the associated
      protobuf element.  For example: `"google/protobuf/source_context.proto"`.
      *)

      val make: ?file_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?file_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end
end = struct
  module rec Protobuf : sig

    (**
      `SourceContext` represents information about the source of a
      protobuf element, like the file in which it is defined.
    *)
    module rec SourceContext : sig
      type t = (string)
      (**
      The path-qualified name of the .proto file that contained the associated
      protobuf element.  For example: `"google/protobuf/source_context.proto"`.
      *)

      val make: ?file_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?file_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end = struct
    module rec SourceContext : sig
      type t = (string)
      (**
      The path-qualified name of the .proto file that contained the associated
      protobuf element.  For example: `"google/protobuf/source_context.proto"`.
      *)

      val make: ?file_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?file_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = SourceContext
      let name () = ".google.protobuf.SourceContext"
      type t = (string)
      (**
      The path-qualified name of the .proto file that contained the associated
      protobuf element.  For example: `"google/protobuf/source_context.proto"`.
      *)

      type make_t = ?file_name:string -> unit -> t
      let make ?(file_name = {||}) () = (file_name)
      let merge =
      let merge_file_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "file_name", "fileName"), string, ({||})) ) in
      fun (t1_file_name) (t2_file_name) -> merge_file_name t1_file_name t2_file_name
      let spec () = Runtime'.Spec.( basic ((1, "file_name", "fileName"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (file_name) -> serialize writer file_name

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor file_name = (file_name) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (file_name) -> serialize file_name
      let from_json_exn =
        let constructor file_name = (file_name) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
  end
end

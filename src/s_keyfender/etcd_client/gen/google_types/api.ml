(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: google/protobuf/api.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
  module Source_context = Source_context
  module Type = Type
end
(**/**)
module rec Google : sig
  module rec Protobuf : sig

    (**
      Api is a light-weight descriptor for an API Interface.

      Interfaces are also described as "protocol buffer services" in some contexts,
      such as by the "service" keyword in a .proto file, but they are different
      from API Services, which represent a concrete implementation of an interface
      as opposed to simply a description of methods and bindings. They are also
      sometimes simply referred to as "APIs" in other contexts, such as the name of
      this message itself. See https://cloud.google.com/apis/design/glossary for
      detailed terminology.
    *)
    module rec Api : sig
      type t = {
      name: string;(** The fully qualified name of this interface, including package name
      followed by the interface's simple name. *)
      methods: Method.t list;(** The methods of this interface, in unspecified order. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the interface. *)
      version: string;(** A version string for this interface. If specified, must have the form
      `major-version.minor-version`, as in `1.10`. If the minor version is
      omitted, it defaults to zero. If the entire version field is empty, the
      major version is derived from the package name, as outlined below. If the
      field is not empty, the version in the package name will be verified to be
      consistent with what is provided here.

      The versioning schema uses \[semantic
      versioning\](http://semver.org) where the major version number
      indicates a breaking change and the minor version an additive,
      non-breaking change. Both version numbers are signals to users
      what to expect from different versions, and should be carefully
      chosen based on the product plan.

      The major version is also reflected in the package name of the
      interface, which must end in `v<major-version>`, as in
      `google.feature.v1`. For major versions 0 and 1, the suffix can
      be omitted. Zero major versions must only be used for
      experimental, non-GA interfaces. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** Source context for the protocol buffer service represented by this
      message. *)
      mixins: Mixin.t list;(** Included interfaces. See \[Mixin\]\[\]. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of the service. *)
      }
      val make: ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** Method represents a method of an API interface. *)
    and Method : sig
      type t = {
      name: string;(** The simple name of this method. *)
      request_type_url: string;(** A URL of the input message type. *)
      request_streaming: bool;(** If true, the request is streamed. *)
      response_type_url: string;(** The URL of the output message type. *)
      response_streaming: bool;(** If true, the response is streamed. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the method. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of this method. *)
      }
      val make: ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      Declares an API Interface to be included in this interface. The including
      interface must redeclare all the methods from the included interface, but
      documentation and options are inherited as follows:

      - If after comment and whitespace stripping, the documentation
      string of the redeclared method is empty, it will be inherited
      from the original method.
      - Each annotation belonging to the service config (http,
      visibility) which is not set in the redeclared method will be
      inherited.
      - If an http annotation is inherited, the path pattern will be
      modified as follows. Any version prefix will be replaced by the
      version of the including interface plus the \[root\]\[\] path if
      specified.
      Example of a simple mixin:
      {v
           package google.acl.v1;
           service AccessControl {
             // Get the underlying ACL object.
             rpc GetAcl(GetAclRequest) returns (Acl) {
               option (google.api.http).get = "/v1/{resource=**}:getAcl";
             }
           }

           package google.storage.v2;
           service Storage {
             rpc GetAcl(GetAclRequest) returns (Acl);

             // Get a data record.
             rpc GetData(GetDataRequest) returns (Data) {
               option (google.api.http).get = "/v2/{resource=**}";
             }
           }
      v}
      Example of a mixin configuration:
      {v
           apis:
      v}
      - name: google.storage.v2.Storage
      mixins:
      - name: google.acl.v1.AccessControl

      The mixin construct implies that all methods in `AccessControl` are
      also declared with same name and request/response types in
      `Storage`. A documentation generator or annotation processor will
      see the effective `Storage.GetAcl` method after inherting
      documentation and annotations as follows:
      {v
           service Storage {
             // Get the underlying ACL object.
             rpc GetAcl(GetAclRequest) returns (Acl) {
               option (google.api.http).get = "/v2/{resource=**}:getAcl";
             }
             ...
           }
      v}
      Note how the version in the path pattern changed from `v1` to `v2`.

      If the `root` field in the mixin is specified, it should be a
      relative path under which inherited HTTP paths are placed. Example:
      {v
           apis:
      v}
      - name: google.storage.v2.Storage
      mixins:
      - name: google.acl.v1.AccessControl
      root: acls
      This implies the following inherited HTTP annotation:
      {v
           service Storage {
             // Get the underlying ACL object.
             rpc GetAcl(GetAclRequest) returns (Acl) {
               option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
             }
             ...
           }
      v}
    *)
    and Mixin : sig
      type t = {
      name: string;(** The fully qualified name of the interface which is included. *)
      root: string;(** If non-empty specifies a path under which inherited HTTP paths
      are rooted. *)
      }
      val make: ?name:string -> ?root:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?root:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end
end = struct
  module rec Protobuf : sig

    (**
      Api is a light-weight descriptor for an API Interface.

      Interfaces are also described as "protocol buffer services" in some contexts,
      such as by the "service" keyword in a .proto file, but they are different
      from API Services, which represent a concrete implementation of an interface
      as opposed to simply a description of methods and bindings. They are also
      sometimes simply referred to as "APIs" in other contexts, such as the name of
      this message itself. See https://cloud.google.com/apis/design/glossary for
      detailed terminology.
    *)
    module rec Api : sig
      type t = {
      name: string;(** The fully qualified name of this interface, including package name
      followed by the interface's simple name. *)
      methods: Method.t list;(** The methods of this interface, in unspecified order. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the interface. *)
      version: string;(** A version string for this interface. If specified, must have the form
      `major-version.minor-version`, as in `1.10`. If the minor version is
      omitted, it defaults to zero. If the entire version field is empty, the
      major version is derived from the package name, as outlined below. If the
      field is not empty, the version in the package name will be verified to be
      consistent with what is provided here.

      The versioning schema uses \[semantic
      versioning\](http://semver.org) where the major version number
      indicates a breaking change and the minor version an additive,
      non-breaking change. Both version numbers are signals to users
      what to expect from different versions, and should be carefully
      chosen based on the product plan.

      The major version is also reflected in the package name of the
      interface, which must end in `v<major-version>`, as in
      `google.feature.v1`. For major versions 0 and 1, the suffix can
      be omitted. Zero major versions must only be used for
      experimental, non-GA interfaces. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** Source context for the protocol buffer service represented by this
      message. *)
      mixins: Mixin.t list;(** Included interfaces. See \[Mixin\]\[\]. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of the service. *)
      }
      val make: ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** Method represents a method of an API interface. *)
    and Method : sig
      type t = {
      name: string;(** The simple name of this method. *)
      request_type_url: string;(** A URL of the input message type. *)
      request_streaming: bool;(** If true, the request is streamed. *)
      response_type_url: string;(** The URL of the output message type. *)
      response_streaming: bool;(** If true, the response is streamed. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the method. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of this method. *)
      }
      val make: ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      Declares an API Interface to be included in this interface. The including
      interface must redeclare all the methods from the included interface, but
      documentation and options are inherited as follows:

      - If after comment and whitespace stripping, the documentation
      string of the redeclared method is empty, it will be inherited
      from the original method.
      - Each annotation belonging to the service config (http,
      visibility) which is not set in the redeclared method will be
      inherited.
      - If an http annotation is inherited, the path pattern will be
      modified as follows. Any version prefix will be replaced by the
      version of the including interface plus the \[root\]\[\] path if
      specified.
      Example of a simple mixin:
      {v
           package google.acl.v1;
           service AccessControl {
             // Get the underlying ACL object.
             rpc GetAcl(GetAclRequest) returns (Acl) {
               option (google.api.http).get = "/v1/{resource=**}:getAcl";
             }
           }

           package google.storage.v2;
           service Storage {
             rpc GetAcl(GetAclRequest) returns (Acl);

             // Get a data record.
             rpc GetData(GetDataRequest) returns (Data) {
               option (google.api.http).get = "/v2/{resource=**}";
             }
           }
      v}
      Example of a mixin configuration:
      {v
           apis:
      v}
      - name: google.storage.v2.Storage
      mixins:
      - name: google.acl.v1.AccessControl

      The mixin construct implies that all methods in `AccessControl` are
      also declared with same name and request/response types in
      `Storage`. A documentation generator or annotation processor will
      see the effective `Storage.GetAcl` method after inherting
      documentation and annotations as follows:
      {v
           service Storage {
             // Get the underlying ACL object.
             rpc GetAcl(GetAclRequest) returns (Acl) {
               option (google.api.http).get = "/v2/{resource=**}:getAcl";
             }
             ...
           }
      v}
      Note how the version in the path pattern changed from `v1` to `v2`.

      If the `root` field in the mixin is specified, it should be a
      relative path under which inherited HTTP paths are placed. Example:
      {v
           apis:
      v}
      - name: google.storage.v2.Storage
      mixins:
      - name: google.acl.v1.AccessControl
      root: acls
      This implies the following inherited HTTP annotation:
      {v
           service Storage {
             // Get the underlying ACL object.
             rpc GetAcl(GetAclRequest) returns (Acl) {
               option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
             }
             ...
           }
      v}
    *)
    and Mixin : sig
      type t = {
      name: string;(** The fully qualified name of the interface which is included. *)
      root: string;(** If non-empty specifies a path under which inherited HTTP paths
      are rooted. *)
      }
      val make: ?name:string -> ?root:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?root:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end = struct
    module rec Api : sig
      type t = {
      name: string;(** The fully qualified name of this interface, including package name
      followed by the interface's simple name. *)
      methods: Method.t list;(** The methods of this interface, in unspecified order. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the interface. *)
      version: string;(** A version string for this interface. If specified, must have the form
      `major-version.minor-version`, as in `1.10`. If the minor version is
      omitted, it defaults to zero. If the entire version field is empty, the
      major version is derived from the package name, as outlined below. If the
      field is not empty, the version in the package name will be verified to be
      consistent with what is provided here.

      The versioning schema uses \[semantic
      versioning\](http://semver.org) where the major version number
      indicates a breaking change and the minor version an additive,
      non-breaking change. Both version numbers are signals to users
      what to expect from different versions, and should be carefully
      chosen based on the product plan.

      The major version is also reflected in the package name of the
      interface, which must end in `v<major-version>`, as in
      `google.feature.v1`. For major versions 0 and 1, the suffix can
      be omitted. Zero major versions must only be used for
      experimental, non-GA interfaces. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** Source context for the protocol buffer service represented by this
      message. *)
      mixins: Mixin.t list;(** Included interfaces. See \[Mixin\]\[\]. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of the service. *)
      }
      val make: ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Api
      let name () = ".google.protobuf.Api"
      type t = {
      name: string;(** The fully qualified name of this interface, including package name
      followed by the interface's simple name. *)
      methods: Method.t list;(** The methods of this interface, in unspecified order. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the interface. *)
      version: string;(** A version string for this interface. If specified, must have the form
      `major-version.minor-version`, as in `1.10`. If the minor version is
      omitted, it defaults to zero. If the entire version field is empty, the
      major version is derived from the package name, as outlined below. If the
      field is not empty, the version in the package name will be verified to be
      consistent with what is provided here.

      The versioning schema uses \[semantic
      versioning\](http://semver.org) where the major version number
      indicates a breaking change and the minor version an additive,
      non-breaking change. Both version numbers are signals to users
      what to expect from different versions, and should be carefully
      chosen based on the product plan.

      The major version is also reflected in the package name of the
      interface, which must end in `v<major-version>`, as in
      `google.feature.v1`. For major versions 0 and 1, the suffix can
      be omitted. Zero major versions must only be used for
      experimental, non-GA interfaces. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** Source context for the protocol buffer service represented by this
      message. *)
      mixins: Mixin.t list;(** Included interfaces. See \[Mixin\]\[\]. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of the service. *)
      }
      type make_t = ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      let make ?(name = {||}) ?(methods = []) ?(options = []) ?(version = {||}) ?source_context ?(mixins = []) ?(syntax = Imported'modules.Type.Google.Protobuf.Syntax.from_int_exn 0) () = { name; methods; options; version; source_context; mixins; syntax }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_methods = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "methods", "methods"), (message (module Method)), not_packed) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "options", "options"), (message (module Imported'modules.Type.Google.Protobuf.Option)), not_packed) ) in
      let merge_version = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "version", "version"), string, ({||})) ) in
      let merge_source_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((5, "source_context", "sourceContext"), (message (module Imported'modules.Source_context.Google.Protobuf.SourceContext))) ) in
      let merge_mixins = Runtime'.Merge.merge Runtime'.Spec.( repeated ((6, "mixins", "mixins"), (message (module Mixin)), not_packed) ) in
      let merge_syntax = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "syntax", "syntax"), (enum (module Imported'modules.Type.Google.Protobuf.Syntax)), (Imported'modules.Type.Google.Protobuf.Syntax.from_int_exn 0)) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      methods = (merge_methods t1.methods t2.methods);
      options = (merge_options t1.options t2.options);
      version = (merge_version t1.version t2.version);
      source_context = (merge_source_context t1.source_context t2.source_context);
      mixins = (merge_mixins t1.mixins t2.mixins);
      syntax = (merge_syntax t1.syntax t2.syntax);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: repeated ((2, "methods", "methods"), (message (module Method)), not_packed) ^:: repeated ((3, "options", "options"), (message (module Imported'modules.Type.Google.Protobuf.Option)), not_packed) ^:: basic ((4, "version", "version"), string, ({||})) ^:: basic_opt ((5, "source_context", "sourceContext"), (message (module Imported'modules.Source_context.Google.Protobuf.SourceContext))) ^:: repeated ((6, "mixins", "mixins"), (message (module Mixin)), not_packed) ^:: basic ((7, "syntax", "syntax"), (enum (module Imported'modules.Type.Google.Protobuf.Syntax)), (Imported'modules.Type.Google.Protobuf.Syntax.from_int_exn 0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; methods; options; version; source_context; mixins; syntax } -> serialize writer name methods options version source_context mixins syntax

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name methods options version source_context mixins syntax = { name; methods; options; version; source_context; mixins; syntax } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; methods; options; version; source_context; mixins; syntax } -> serialize name methods options version source_context mixins syntax
      let from_json_exn =
        let constructor name methods options version source_context mixins syntax = { name; methods; options; version; source_context; mixins; syntax } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and Method : sig
      type t = {
      name: string;(** The simple name of this method. *)
      request_type_url: string;(** A URL of the input message type. *)
      request_streaming: bool;(** If true, the request is streamed. *)
      response_type_url: string;(** The URL of the output message type. *)
      response_streaming: bool;(** If true, the response is streamed. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the method. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of this method. *)
      }
      val make: ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Method
      let name () = ".google.protobuf.Method"
      type t = {
      name: string;(** The simple name of this method. *)
      request_type_url: string;(** A URL of the input message type. *)
      request_streaming: bool;(** If true, the request is streamed. *)
      response_type_url: string;(** The URL of the output message type. *)
      response_streaming: bool;(** If true, the response is streamed. *)
      options: Imported'modules.Type.Google.Protobuf.Option.t list;(** Any metadata attached to the method. *)
      syntax: Imported'modules.Type.Google.Protobuf.Syntax.t;(** The source syntax of this method. *)
      }
      type make_t = ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      let make ?(name = {||}) ?(request_type_url = {||}) ?(request_streaming = false) ?(response_type_url = {||}) ?(response_streaming = false) ?(options = []) ?(syntax = Imported'modules.Type.Google.Protobuf.Syntax.from_int_exn 0) () = { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_request_type_url = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "request_type_url", "requestTypeUrl"), string, ({||})) ) in
      let merge_request_streaming = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "request_streaming", "requestStreaming"), bool, (false)) ) in
      let merge_response_type_url = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "response_type_url", "responseTypeUrl"), string, ({||})) ) in
      let merge_response_streaming = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "response_streaming", "responseStreaming"), bool, (false)) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((6, "options", "options"), (message (module Imported'modules.Type.Google.Protobuf.Option)), not_packed) ) in
      let merge_syntax = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "syntax", "syntax"), (enum (module Imported'modules.Type.Google.Protobuf.Syntax)), (Imported'modules.Type.Google.Protobuf.Syntax.from_int_exn 0)) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      request_type_url = (merge_request_type_url t1.request_type_url t2.request_type_url);
      request_streaming = (merge_request_streaming t1.request_streaming t2.request_streaming);
      response_type_url = (merge_response_type_url t1.response_type_url t2.response_type_url);
      response_streaming = (merge_response_streaming t1.response_streaming t2.response_streaming);
      options = (merge_options t1.options t2.options);
      syntax = (merge_syntax t1.syntax t2.syntax);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "request_type_url", "requestTypeUrl"), string, ({||})) ^:: basic ((3, "request_streaming", "requestStreaming"), bool, (false)) ^:: basic ((4, "response_type_url", "responseTypeUrl"), string, ({||})) ^:: basic ((5, "response_streaming", "responseStreaming"), bool, (false)) ^:: repeated ((6, "options", "options"), (message (module Imported'modules.Type.Google.Protobuf.Option)), not_packed) ^:: basic ((7, "syntax", "syntax"), (enum (module Imported'modules.Type.Google.Protobuf.Syntax)), (Imported'modules.Type.Google.Protobuf.Syntax.from_int_exn 0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax } -> serialize writer name request_type_url request_streaming response_type_url response_streaming options syntax

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name request_type_url request_streaming response_type_url response_streaming options syntax = { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax } -> serialize name request_type_url request_streaming response_type_url response_streaming options syntax
      let from_json_exn =
        let constructor name request_type_url request_streaming response_type_url response_streaming options syntax = { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and Mixin : sig
      type t = {
      name: string;(** The fully qualified name of the interface which is included. *)
      root: string;(** If non-empty specifies a path under which inherited HTTP paths
      are rooted. *)
      }
      val make: ?name:string -> ?root:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?root:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Mixin
      let name () = ".google.protobuf.Mixin"
      type t = {
      name: string;(** The fully qualified name of the interface which is included. *)
      root: string;(** If non-empty specifies a path under which inherited HTTP paths
      are rooted. *)
      }
      type make_t = ?name:string -> ?root:string -> unit -> t
      let make ?(name = {||}) ?(root = {||}) () = { name; root }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_root = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "root", "root"), string, ({||})) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      root = (merge_root t1.root t2.root);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "root", "root"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; root } -> serialize writer name root

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name root = { name; root } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; root } -> serialize name root
      let from_json_exn =
        let constructor name root = { name; root } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
  end
end

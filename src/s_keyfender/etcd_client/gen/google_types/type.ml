(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: google/protobuf/type.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
  module Any = Any
  module Source_context = Source_context
end
(**/**)
module rec Google : sig
  module rec Protobuf : sig

    (** The syntax in which a protocol buffer element is defined. *)
    module rec Syntax : sig
      type t =
        | SYNTAX_PROTO2
        (** Syntax `proto2`. *)
        | SYNTAX_PROTO3
        (** Syntax `proto3`. *)
        | SYNTAX_EDITIONS
        (** Syntax `editions`. *)

      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end

    (** A protocol buffer message type. *)
    and Type : sig
      type t = {
      name: string;(** The fully qualified message name. *)
      fields: Field.t list;(** The list of fields. *)
      oneofs: string list;(** The list of types appearing in `oneof` definitions in this type. *)
      options: Option.t list;(** The protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      val make: ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** A single field of a message type. *)
    and Field : sig

      (** Basic field types. *)
      module rec Kind : sig
        type t =
          | TYPE_UNKNOWN
          (** Field type unknown. *)
          | TYPE_DOUBLE
          (** Field type double. *)
          | TYPE_FLOAT
          (** Field type float. *)
          | TYPE_INT64
          (** Field type int64. *)
          | TYPE_UINT64
          (** Field type uint64. *)
          | TYPE_INT32
          (** Field type int32. *)
          | TYPE_FIXED64
          (** Field type fixed64. *)
          | TYPE_FIXED32
          (** Field type fixed32. *)
          | TYPE_BOOL
          (** Field type bool. *)
          | TYPE_STRING
          (** Field type string. *)
          | TYPE_GROUP
          (** Field type group. Proto2 syntax only, and deprecated. *)
          | TYPE_MESSAGE
          (** Field type message. *)
          | TYPE_BYTES
          (** Field type bytes. *)
          | TYPE_UINT32
          (** Field type uint32. *)
          | TYPE_ENUM
          (** Field type enum. *)
          | TYPE_SFIXED32
          (** Field type sfixed32. *)
          | TYPE_SFIXED64
          (** Field type sfixed64. *)
          | TYPE_SINT32
          (** Field type sint32. *)
          | TYPE_SINT64
          (** Field type sint64. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end

      (** Whether a field is optional, required, or repeated. *)
      and Cardinality : sig
        type t =
          | CARDINALITY_UNKNOWN
          (** For fields with unknown cardinality. *)
          | CARDINALITY_OPTIONAL
          (** For optional fields. *)
          | CARDINALITY_REQUIRED
          (** For required fields. Proto2 syntax only. *)
          | CARDINALITY_REPEATED
          (** For repeated fields. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end
      type t = {
      kind: Kind.t;(** The field type. *)
      cardinality: Cardinality.t;(** The field cardinality. *)
      number: int;(** The field number. *)
      name: string;(** The field name. *)
      type_url: string;(** The field type URL, without the scheme, for message or enumeration
      types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`. *)
      oneof_index: int;(** The index of the field type in `Type.oneofs`, for message or enumeration
      types. The first type has index 1; zero means the type is not in the list. *)
      packed: bool;(** Whether to use alternative packed wire representation. *)
      options: Option.t list;(** The protocol buffer options. *)
      json_name: string;(** The field JSON name. *)
      default_value: string;(** The string value of the default value of this field. Proto2 syntax only. *)
      }
      val make: ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** Enum type definition. *)
    and Enum : sig
      type t = {
      name: string;(** Enum type name. *)
      enumvalue: EnumValue.t list;(** Enum value definitions. *)
      options: Option.t list;(** Protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      val make: ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** Enum value definition. *)
    and EnumValue : sig
      type t = {
      name: string;(** Enum value name. *)
      number: int;(** Enum value number. *)
      options: Option.t list;(** Protocol buffer options. *)
      }
      val make: ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      A protocol buffer option, which can be attached to a message, field,
      enumeration, etc.
    *)
    and Option : sig
      type t = {
      name: string;(** The option's name. For protobuf built-in options (options defined in
      descriptor.proto), this is the short name. For example, `"map_entry"`.
      For custom options, it should be the fully-qualified name. For example,
      `"google.api.http"`. *)
      value: Imported'modules.Any.Google.Protobuf.Any.t option;(** The option's value packed in an Any message. If the value is a primitive,
      the corresponding wrapper type defined in google/protobuf/wrappers.proto
      should be used. If the value is an enum, it should be stored as an int32
      value using the google.protobuf.Int32Value type. *)
      }
      val make: ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end
end = struct
  module rec Protobuf : sig

    (** The syntax in which a protocol buffer element is defined. *)
    module rec Syntax : sig
      type t =
        | SYNTAX_PROTO2
        (** Syntax `proto2`. *)
        | SYNTAX_PROTO3
        (** Syntax `proto3`. *)
        | SYNTAX_EDITIONS
        (** Syntax `editions`. *)

      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end

    (** A protocol buffer message type. *)
    and Type : sig
      type t = {
      name: string;(** The fully qualified message name. *)
      fields: Field.t list;(** The list of fields. *)
      oneofs: string list;(** The list of types appearing in `oneof` definitions in this type. *)
      options: Option.t list;(** The protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      val make: ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** A single field of a message type. *)
    and Field : sig

      (** Basic field types. *)
      module rec Kind : sig
        type t =
          | TYPE_UNKNOWN
          (** Field type unknown. *)
          | TYPE_DOUBLE
          (** Field type double. *)
          | TYPE_FLOAT
          (** Field type float. *)
          | TYPE_INT64
          (** Field type int64. *)
          | TYPE_UINT64
          (** Field type uint64. *)
          | TYPE_INT32
          (** Field type int32. *)
          | TYPE_FIXED64
          (** Field type fixed64. *)
          | TYPE_FIXED32
          (** Field type fixed32. *)
          | TYPE_BOOL
          (** Field type bool. *)
          | TYPE_STRING
          (** Field type string. *)
          | TYPE_GROUP
          (** Field type group. Proto2 syntax only, and deprecated. *)
          | TYPE_MESSAGE
          (** Field type message. *)
          | TYPE_BYTES
          (** Field type bytes. *)
          | TYPE_UINT32
          (** Field type uint32. *)
          | TYPE_ENUM
          (** Field type enum. *)
          | TYPE_SFIXED32
          (** Field type sfixed32. *)
          | TYPE_SFIXED64
          (** Field type sfixed64. *)
          | TYPE_SINT32
          (** Field type sint32. *)
          | TYPE_SINT64
          (** Field type sint64. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end

      (** Whether a field is optional, required, or repeated. *)
      and Cardinality : sig
        type t =
          | CARDINALITY_UNKNOWN
          (** For fields with unknown cardinality. *)
          | CARDINALITY_OPTIONAL
          (** For optional fields. *)
          | CARDINALITY_REQUIRED
          (** For required fields. Proto2 syntax only. *)
          | CARDINALITY_REPEATED
          (** For repeated fields. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end
      type t = {
      kind: Kind.t;(** The field type. *)
      cardinality: Cardinality.t;(** The field cardinality. *)
      number: int;(** The field number. *)
      name: string;(** The field name. *)
      type_url: string;(** The field type URL, without the scheme, for message or enumeration
      types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`. *)
      oneof_index: int;(** The index of the field type in `Type.oneofs`, for message or enumeration
      types. The first type has index 1; zero means the type is not in the list. *)
      packed: bool;(** Whether to use alternative packed wire representation. *)
      options: Option.t list;(** The protocol buffer options. *)
      json_name: string;(** The field JSON name. *)
      default_value: string;(** The string value of the default value of this field. Proto2 syntax only. *)
      }
      val make: ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** Enum type definition. *)
    and Enum : sig
      type t = {
      name: string;(** Enum type name. *)
      enumvalue: EnumValue.t list;(** Enum value definitions. *)
      options: Option.t list;(** Protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      val make: ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (** Enum value definition. *)
    and EnumValue : sig
      type t = {
      name: string;(** Enum value name. *)
      number: int;(** Enum value number. *)
      options: Option.t list;(** Protocol buffer options. *)
      }
      val make: ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      A protocol buffer option, which can be attached to a message, field,
      enumeration, etc.
    *)
    and Option : sig
      type t = {
      name: string;(** The option's name. For protobuf built-in options (options defined in
      descriptor.proto), this is the short name. For example, `"map_entry"`.
      For custom options, it should be the fully-qualified name. For example,
      `"google.api.http"`. *)
      value: Imported'modules.Any.Google.Protobuf.Any.t option;(** The option's value packed in an Any message. If the value is a primitive,
      the corresponding wrapper type defined in google/protobuf/wrappers.proto
      should be used. If the value is an enum, it should be stored as an int32
      value using the google.protobuf.Int32Value type. *)
      }
      val make: ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end = struct
    module rec Syntax : sig
      type t =
        | SYNTAX_PROTO2
        (** Syntax `proto2`. *)
        | SYNTAX_PROTO3
        (** Syntax `proto3`. *)
        | SYNTAX_EDITIONS
        (** Syntax `editions`. *)

      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = Syntax
      type t =
        | SYNTAX_PROTO2
        (** Syntax `proto2`. *)
        | SYNTAX_PROTO3
        (** Syntax `proto3`. *)
        | SYNTAX_EDITIONS
        (** Syntax `editions`. *)

      let name () = ".google.protobuf.Syntax"
      let to_int = function
        | SYNTAX_PROTO2 -> 0
        | SYNTAX_PROTO3 -> 1
        | SYNTAX_EDITIONS -> 2
      let from_int_exn = function
        | 0 -> SYNTAX_PROTO2
        | 1 -> SYNTAX_PROTO3
        | 2 -> SYNTAX_EDITIONS
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | SYNTAX_PROTO2 -> "SYNTAX_PROTO2"
        | SYNTAX_PROTO3 -> "SYNTAX_PROTO3"
        | SYNTAX_EDITIONS -> "SYNTAX_EDITIONS"
      let from_string_exn = function
        | "SYNTAX_PROTO2" -> SYNTAX_PROTO2
        | "SYNTAX_PROTO3" -> SYNTAX_PROTO3
        | "SYNTAX_EDITIONS" -> SYNTAX_EDITIONS
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    and Type : sig
      type t = {
      name: string;(** The fully qualified message name. *)
      fields: Field.t list;(** The list of fields. *)
      oneofs: string list;(** The list of types appearing in `oneof` definitions in this type. *)
      options: Option.t list;(** The protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      val make: ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Type
      let name () = ".google.protobuf.Type"
      type t = {
      name: string;(** The fully qualified message name. *)
      fields: Field.t list;(** The list of fields. *)
      oneofs: string list;(** The list of types appearing in `oneof` definitions in this type. *)
      options: Option.t list;(** The protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      type make_t = ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      let make ?(name = {||}) ?(fields = []) ?(oneofs = []) ?(options = []) ?source_context ?(syntax = Syntax.from_int_exn 0) ?(edition = {||}) () = { name; fields; oneofs; options; source_context; syntax; edition }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_fields = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "fields", "fields"), (message (module Field)), not_packed) ) in
      let merge_oneofs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "oneofs", "oneofs"), string, not_packed) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "options", "options"), (message (module Option)), not_packed) ) in
      let merge_source_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((5, "source_context", "sourceContext"), (message (module Imported'modules.Source_context.Google.Protobuf.SourceContext))) ) in
      let merge_syntax = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "syntax", "syntax"), (enum (module Syntax)), (Syntax.from_int_exn 0)) ) in
      let merge_edition = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "edition", "edition"), string, ({||})) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      fields = (merge_fields t1.fields t2.fields);
      oneofs = (merge_oneofs t1.oneofs t2.oneofs);
      options = (merge_options t1.options t2.options);
      source_context = (merge_source_context t1.source_context t2.source_context);
      syntax = (merge_syntax t1.syntax t2.syntax);
      edition = (merge_edition t1.edition t2.edition);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: repeated ((2, "fields", "fields"), (message (module Field)), not_packed) ^:: repeated ((3, "oneofs", "oneofs"), string, not_packed) ^:: repeated ((4, "options", "options"), (message (module Option)), not_packed) ^:: basic_opt ((5, "source_context", "sourceContext"), (message (module Imported'modules.Source_context.Google.Protobuf.SourceContext))) ^:: basic ((6, "syntax", "syntax"), (enum (module Syntax)), (Syntax.from_int_exn 0)) ^:: basic ((7, "edition", "edition"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; fields; oneofs; options; source_context; syntax; edition } -> serialize writer name fields oneofs options source_context syntax edition

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name fields oneofs options source_context syntax edition = { name; fields; oneofs; options; source_context; syntax; edition } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; fields; oneofs; options; source_context; syntax; edition } -> serialize name fields oneofs options source_context syntax edition
      let from_json_exn =
        let constructor name fields oneofs options source_context syntax edition = { name; fields; oneofs; options; source_context; syntax; edition } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and Field : sig

      (** Basic field types. *)
      module rec Kind : sig
        type t =
          | TYPE_UNKNOWN
          (** Field type unknown. *)
          | TYPE_DOUBLE
          (** Field type double. *)
          | TYPE_FLOAT
          (** Field type float. *)
          | TYPE_INT64
          (** Field type int64. *)
          | TYPE_UINT64
          (** Field type uint64. *)
          | TYPE_INT32
          (** Field type int32. *)
          | TYPE_FIXED64
          (** Field type fixed64. *)
          | TYPE_FIXED32
          (** Field type fixed32. *)
          | TYPE_BOOL
          (** Field type bool. *)
          | TYPE_STRING
          (** Field type string. *)
          | TYPE_GROUP
          (** Field type group. Proto2 syntax only, and deprecated. *)
          | TYPE_MESSAGE
          (** Field type message. *)
          | TYPE_BYTES
          (** Field type bytes. *)
          | TYPE_UINT32
          (** Field type uint32. *)
          | TYPE_ENUM
          (** Field type enum. *)
          | TYPE_SFIXED32
          (** Field type sfixed32. *)
          | TYPE_SFIXED64
          (** Field type sfixed64. *)
          | TYPE_SINT32
          (** Field type sint32. *)
          | TYPE_SINT64
          (** Field type sint64. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end

      (** Whether a field is optional, required, or repeated. *)
      and Cardinality : sig
        type t =
          | CARDINALITY_UNKNOWN
          (** For fields with unknown cardinality. *)
          | CARDINALITY_OPTIONAL
          (** For optional fields. *)
          | CARDINALITY_REQUIRED
          (** For required fields. Proto2 syntax only. *)
          | CARDINALITY_REPEATED
          (** For repeated fields. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end
      type t = {
      kind: Kind.t;(** The field type. *)
      cardinality: Cardinality.t;(** The field cardinality. *)
      number: int;(** The field number. *)
      name: string;(** The field name. *)
      type_url: string;(** The field type URL, without the scheme, for message or enumeration
      types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`. *)
      oneof_index: int;(** The index of the field type in `Type.oneofs`, for message or enumeration
      types. The first type has index 1; zero means the type is not in the list. *)
      packed: bool;(** Whether to use alternative packed wire representation. *)
      options: Option.t list;(** The protocol buffer options. *)
      json_name: string;(** The field JSON name. *)
      default_value: string;(** The string value of the default value of this field. Proto2 syntax only. *)
      }
      val make: ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Field
      module rec Kind : sig
        type t =
          | TYPE_UNKNOWN
          (** Field type unknown. *)
          | TYPE_DOUBLE
          (** Field type double. *)
          | TYPE_FLOAT
          (** Field type float. *)
          | TYPE_INT64
          (** Field type int64. *)
          | TYPE_UINT64
          (** Field type uint64. *)
          | TYPE_INT32
          (** Field type int32. *)
          | TYPE_FIXED64
          (** Field type fixed64. *)
          | TYPE_FIXED32
          (** Field type fixed32. *)
          | TYPE_BOOL
          (** Field type bool. *)
          | TYPE_STRING
          (** Field type string. *)
          | TYPE_GROUP
          (** Field type group. Proto2 syntax only, and deprecated. *)
          | TYPE_MESSAGE
          (** Field type message. *)
          | TYPE_BYTES
          (** Field type bytes. *)
          | TYPE_UINT32
          (** Field type uint32. *)
          | TYPE_ENUM
          (** Field type enum. *)
          | TYPE_SFIXED32
          (** Field type sfixed32. *)
          | TYPE_SFIXED64
          (** Field type sfixed64. *)
          | TYPE_SINT32
          (** Field type sint32. *)
          | TYPE_SINT64
          (** Field type sint64. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end = struct
        module This'_ = Kind
        type t =
          | TYPE_UNKNOWN
          (** Field type unknown. *)
          | TYPE_DOUBLE
          (** Field type double. *)
          | TYPE_FLOAT
          (** Field type float. *)
          | TYPE_INT64
          (** Field type int64. *)
          | TYPE_UINT64
          (** Field type uint64. *)
          | TYPE_INT32
          (** Field type int32. *)
          | TYPE_FIXED64
          (** Field type fixed64. *)
          | TYPE_FIXED32
          (** Field type fixed32. *)
          | TYPE_BOOL
          (** Field type bool. *)
          | TYPE_STRING
          (** Field type string. *)
          | TYPE_GROUP
          (** Field type group. Proto2 syntax only, and deprecated. *)
          | TYPE_MESSAGE
          (** Field type message. *)
          | TYPE_BYTES
          (** Field type bytes. *)
          | TYPE_UINT32
          (** Field type uint32. *)
          | TYPE_ENUM
          (** Field type enum. *)
          | TYPE_SFIXED32
          (** Field type sfixed32. *)
          | TYPE_SFIXED64
          (** Field type sfixed64. *)
          | TYPE_SINT32
          (** Field type sint32. *)
          | TYPE_SINT64
          (** Field type sint64. *)

        let name () = ".google.protobuf.Field.Kind"
        let to_int = function
          | TYPE_UNKNOWN -> 0
          | TYPE_DOUBLE -> 1
          | TYPE_FLOAT -> 2
          | TYPE_INT64 -> 3
          | TYPE_UINT64 -> 4
          | TYPE_INT32 -> 5
          | TYPE_FIXED64 -> 6
          | TYPE_FIXED32 -> 7
          | TYPE_BOOL -> 8
          | TYPE_STRING -> 9
          | TYPE_GROUP -> 10
          | TYPE_MESSAGE -> 11
          | TYPE_BYTES -> 12
          | TYPE_UINT32 -> 13
          | TYPE_ENUM -> 14
          | TYPE_SFIXED32 -> 15
          | TYPE_SFIXED64 -> 16
          | TYPE_SINT32 -> 17
          | TYPE_SINT64 -> 18
        let from_int_exn = function
          | 0 -> TYPE_UNKNOWN
          | 1 -> TYPE_DOUBLE
          | 2 -> TYPE_FLOAT
          | 3 -> TYPE_INT64
          | 4 -> TYPE_UINT64
          | 5 -> TYPE_INT32
          | 6 -> TYPE_FIXED64
          | 7 -> TYPE_FIXED32
          | 8 -> TYPE_BOOL
          | 9 -> TYPE_STRING
          | 10 -> TYPE_GROUP
          | 11 -> TYPE_MESSAGE
          | 12 -> TYPE_BYTES
          | 13 -> TYPE_UINT32
          | 14 -> TYPE_ENUM
          | 15 -> TYPE_SFIXED32
          | 16 -> TYPE_SFIXED64
          | 17 -> TYPE_SINT32
          | 18 -> TYPE_SINT64
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | TYPE_UNKNOWN -> "TYPE_UNKNOWN"
          | TYPE_DOUBLE -> "TYPE_DOUBLE"
          | TYPE_FLOAT -> "TYPE_FLOAT"
          | TYPE_INT64 -> "TYPE_INT64"
          | TYPE_UINT64 -> "TYPE_UINT64"
          | TYPE_INT32 -> "TYPE_INT32"
          | TYPE_FIXED64 -> "TYPE_FIXED64"
          | TYPE_FIXED32 -> "TYPE_FIXED32"
          | TYPE_BOOL -> "TYPE_BOOL"
          | TYPE_STRING -> "TYPE_STRING"
          | TYPE_GROUP -> "TYPE_GROUP"
          | TYPE_MESSAGE -> "TYPE_MESSAGE"
          | TYPE_BYTES -> "TYPE_BYTES"
          | TYPE_UINT32 -> "TYPE_UINT32"
          | TYPE_ENUM -> "TYPE_ENUM"
          | TYPE_SFIXED32 -> "TYPE_SFIXED32"
          | TYPE_SFIXED64 -> "TYPE_SFIXED64"
          | TYPE_SINT32 -> "TYPE_SINT32"
          | TYPE_SINT64 -> "TYPE_SINT64"
        let from_string_exn = function
          | "TYPE_UNKNOWN" -> TYPE_UNKNOWN
          | "TYPE_DOUBLE" -> TYPE_DOUBLE
          | "TYPE_FLOAT" -> TYPE_FLOAT
          | "TYPE_INT64" -> TYPE_INT64
          | "TYPE_UINT64" -> TYPE_UINT64
          | "TYPE_INT32" -> TYPE_INT32
          | "TYPE_FIXED64" -> TYPE_FIXED64
          | "TYPE_FIXED32" -> TYPE_FIXED32
          | "TYPE_BOOL" -> TYPE_BOOL
          | "TYPE_STRING" -> TYPE_STRING
          | "TYPE_GROUP" -> TYPE_GROUP
          | "TYPE_MESSAGE" -> TYPE_MESSAGE
          | "TYPE_BYTES" -> TYPE_BYTES
          | "TYPE_UINT32" -> TYPE_UINT32
          | "TYPE_ENUM" -> TYPE_ENUM
          | "TYPE_SFIXED32" -> TYPE_SFIXED32
          | "TYPE_SFIXED64" -> TYPE_SFIXED64
          | "TYPE_SINT32" -> TYPE_SINT32
          | "TYPE_SINT64" -> TYPE_SINT64
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      and Cardinality : sig
        type t =
          | CARDINALITY_UNKNOWN
          (** For fields with unknown cardinality. *)
          | CARDINALITY_OPTIONAL
          (** For optional fields. *)
          | CARDINALITY_REQUIRED
          (** For required fields. Proto2 syntax only. *)
          | CARDINALITY_REPEATED
          (** For repeated fields. *)

        val name: unit -> string
        (** Fully qualified protobuf name of this enum *)

        (**/**)
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
        (**/**)
      end = struct
        module This'_ = Cardinality
        type t =
          | CARDINALITY_UNKNOWN
          (** For fields with unknown cardinality. *)
          | CARDINALITY_OPTIONAL
          (** For optional fields. *)
          | CARDINALITY_REQUIRED
          (** For required fields. Proto2 syntax only. *)
          | CARDINALITY_REPEATED
          (** For repeated fields. *)

        let name () = ".google.protobuf.Field.Cardinality"
        let to_int = function
          | CARDINALITY_UNKNOWN -> 0
          | CARDINALITY_OPTIONAL -> 1
          | CARDINALITY_REQUIRED -> 2
          | CARDINALITY_REPEATED -> 3
        let from_int_exn = function
          | 0 -> CARDINALITY_UNKNOWN
          | 1 -> CARDINALITY_OPTIONAL
          | 2 -> CARDINALITY_REQUIRED
          | 3 -> CARDINALITY_REPEATED
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | CARDINALITY_UNKNOWN -> "CARDINALITY_UNKNOWN"
          | CARDINALITY_OPTIONAL -> "CARDINALITY_OPTIONAL"
          | CARDINALITY_REQUIRED -> "CARDINALITY_REQUIRED"
          | CARDINALITY_REPEATED -> "CARDINALITY_REPEATED"
        let from_string_exn = function
          | "CARDINALITY_UNKNOWN" -> CARDINALITY_UNKNOWN
          | "CARDINALITY_OPTIONAL" -> CARDINALITY_OPTIONAL
          | "CARDINALITY_REQUIRED" -> CARDINALITY_REQUIRED
          | "CARDINALITY_REPEATED" -> CARDINALITY_REPEATED
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      let name () = ".google.protobuf.Field"
      type t = {
      kind: Kind.t;(** The field type. *)
      cardinality: Cardinality.t;(** The field cardinality. *)
      number: int;(** The field number. *)
      name: string;(** The field name. *)
      type_url: string;(** The field type URL, without the scheme, for message or enumeration
      types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`. *)
      oneof_index: int;(** The index of the field type in `Type.oneofs`, for message or enumeration
      types. The first type has index 1; zero means the type is not in the list. *)
      packed: bool;(** Whether to use alternative packed wire representation. *)
      options: Option.t list;(** The protocol buffer options. *)
      json_name: string;(** The field JSON name. *)
      default_value: string;(** The string value of the default value of this field. Proto2 syntax only. *)
      }
      type make_t = ?kind:Kind.t -> ?cardinality:Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      let make ?(kind = Kind.from_int_exn 0) ?(cardinality = Cardinality.from_int_exn 0) ?(number = 0) ?(name = {||}) ?(type_url = {||}) ?(oneof_index = 0) ?(packed = false) ?(options = []) ?(json_name = {||}) ?(default_value = {||}) () = { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value }
      let merge =
      let merge_kind = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "kind", "kind"), (enum (module Kind)), (Kind.from_int_exn 0)) ) in
      let merge_cardinality = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "cardinality", "cardinality"), (enum (module Cardinality)), (Cardinality.from_int_exn 0)) ) in
      let merge_number = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "number", "number"), int32_int, (0)) ) in
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "name", "name"), string, ({||})) ) in
      let merge_type_url = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "type_url", "typeUrl"), string, ({||})) ) in
      let merge_oneof_index = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "oneof_index", "oneofIndex"), int32_int, (0)) ) in
      let merge_packed = Runtime'.Merge.merge Runtime'.Spec.( basic ((8, "packed", "packed"), bool, (false)) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((9, "options", "options"), (message (module Option)), not_packed) ) in
      let merge_json_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((10, "json_name", "jsonName"), string, ({||})) ) in
      let merge_default_value = Runtime'.Merge.merge Runtime'.Spec.( basic ((11, "default_value", "defaultValue"), string, ({||})) ) in
      fun t1 t2 -> {
      kind = (merge_kind t1.kind t2.kind);
      cardinality = (merge_cardinality t1.cardinality t2.cardinality);
      number = (merge_number t1.number t2.number);
      name = (merge_name t1.name t2.name);
      type_url = (merge_type_url t1.type_url t2.type_url);
      oneof_index = (merge_oneof_index t1.oneof_index t2.oneof_index);
      packed = (merge_packed t1.packed t2.packed);
      options = (merge_options t1.options t2.options);
      json_name = (merge_json_name t1.json_name t2.json_name);
      default_value = (merge_default_value t1.default_value t2.default_value);
       }
      let spec () = Runtime'.Spec.( basic ((1, "kind", "kind"), (enum (module Kind)), (Kind.from_int_exn 0)) ^:: basic ((2, "cardinality", "cardinality"), (enum (module Cardinality)), (Cardinality.from_int_exn 0)) ^:: basic ((3, "number", "number"), int32_int, (0)) ^:: basic ((4, "name", "name"), string, ({||})) ^:: basic ((6, "type_url", "typeUrl"), string, ({||})) ^:: basic ((7, "oneof_index", "oneofIndex"), int32_int, (0)) ^:: basic ((8, "packed", "packed"), bool, (false)) ^:: repeated ((9, "options", "options"), (message (module Option)), not_packed) ^:: basic ((10, "json_name", "jsonName"), string, ({||})) ^:: basic ((11, "default_value", "defaultValue"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value } -> serialize writer kind cardinality number name type_url oneof_index packed options json_name default_value

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor kind cardinality number name type_url oneof_index packed options json_name default_value = { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value } -> serialize kind cardinality number name type_url oneof_index packed options json_name default_value
      let from_json_exn =
        let constructor kind cardinality number name type_url oneof_index packed options json_name default_value = { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and Enum : sig
      type t = {
      name: string;(** Enum type name. *)
      enumvalue: EnumValue.t list;(** Enum value definitions. *)
      options: Option.t list;(** Protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      val make: ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Enum
      let name () = ".google.protobuf.Enum"
      type t = {
      name: string;(** Enum type name. *)
      enumvalue: EnumValue.t list;(** Enum value definitions. *)
      options: Option.t list;(** Protocol buffer options. *)
      source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option;(** The source context. *)
      syntax: Syntax.t;(** The source syntax. *)
      edition: string;(** The source edition string, only valid when syntax is SYNTAX_EDITIONS. *)
      }
      type make_t = ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> ?edition:string -> unit -> t
      let make ?(name = {||}) ?(enumvalue = []) ?(options = []) ?source_context ?(syntax = Syntax.from_int_exn 0) ?(edition = {||}) () = { name; enumvalue; options; source_context; syntax; edition }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_enumvalue = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "enumvalue", "enumvalue"), (message (module EnumValue)), not_packed) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "options", "options"), (message (module Option)), not_packed) ) in
      let merge_source_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "source_context", "sourceContext"), (message (module Imported'modules.Source_context.Google.Protobuf.SourceContext))) ) in
      let merge_syntax = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "syntax", "syntax"), (enum (module Syntax)), (Syntax.from_int_exn 0)) ) in
      let merge_edition = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "edition", "edition"), string, ({||})) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      enumvalue = (merge_enumvalue t1.enumvalue t2.enumvalue);
      options = (merge_options t1.options t2.options);
      source_context = (merge_source_context t1.source_context t2.source_context);
      syntax = (merge_syntax t1.syntax t2.syntax);
      edition = (merge_edition t1.edition t2.edition);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: repeated ((2, "enumvalue", "enumvalue"), (message (module EnumValue)), not_packed) ^:: repeated ((3, "options", "options"), (message (module Option)), not_packed) ^:: basic_opt ((4, "source_context", "sourceContext"), (message (module Imported'modules.Source_context.Google.Protobuf.SourceContext))) ^:: basic ((5, "syntax", "syntax"), (enum (module Syntax)), (Syntax.from_int_exn 0)) ^:: basic ((6, "edition", "edition"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; enumvalue; options; source_context; syntax; edition } -> serialize writer name enumvalue options source_context syntax edition

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name enumvalue options source_context syntax edition = { name; enumvalue; options; source_context; syntax; edition } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; enumvalue; options; source_context; syntax; edition } -> serialize name enumvalue options source_context syntax edition
      let from_json_exn =
        let constructor name enumvalue options source_context syntax edition = { name; enumvalue; options; source_context; syntax; edition } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and EnumValue : sig
      type t = {
      name: string;(** Enum value name. *)
      number: int;(** Enum value number. *)
      options: Option.t list;(** Protocol buffer options. *)
      }
      val make: ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = EnumValue
      let name () = ".google.protobuf.EnumValue"
      type t = {
      name: string;(** Enum value name. *)
      number: int;(** Enum value number. *)
      options: Option.t list;(** Protocol buffer options. *)
      }
      type make_t = ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      let make ?(name = {||}) ?(number = 0) ?(options = []) () = { name; number; options }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_number = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "number", "number"), int32_int, (0)) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "options", "options"), (message (module Option)), not_packed) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      number = (merge_number t1.number t2.number);
      options = (merge_options t1.options t2.options);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "number", "number"), int32_int, (0)) ^:: repeated ((3, "options", "options"), (message (module Option)), not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; number; options } -> serialize writer name number options

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name number options = { name; number; options } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; number; options } -> serialize name number options
      let from_json_exn =
        let constructor name number options = { name; number; options } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and Option : sig
      type t = {
      name: string;(** The option's name. For protobuf built-in options (options defined in
      descriptor.proto), this is the short name. For example, `"map_entry"`.
      For custom options, it should be the fully-qualified name. For example,
      `"google.api.http"`. *)
      value: Imported'modules.Any.Google.Protobuf.Any.t option;(** The option's value packed in an Any message. If the value is a primitive,
      the corresponding wrapper type defined in google/protobuf/wrappers.proto
      should be used. If the value is an enum, it should be stored as an int32
      value using the google.protobuf.Int32Value type. *)
      }
      val make: ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Option
      let name () = ".google.protobuf.Option"
      type t = {
      name: string;(** The option's name. For protobuf built-in options (options defined in
      descriptor.proto), this is the short name. For example, `"map_entry"`.
      For custom options, it should be the fully-qualified name. For example,
      `"google.api.http"`. *)
      value: Imported'modules.Any.Google.Protobuf.Any.t option;(** The option's value packed in an Any message. If the value is a primitive,
      the corresponding wrapper type defined in google/protobuf/wrappers.proto
      should be used. If the value is an enum, it should be stored as an int32
      value using the google.protobuf.Int32Value type. *)
      }
      type make_t = ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      let make ?(name = {||}) ?value () = { name; value }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_value = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "value", "value"), (message (module Imported'modules.Any.Google.Protobuf.Any))) ) in
      fun t1 t2 -> {
      name = (merge_name t1.name t2.name);
      value = (merge_value t1.value t2.value);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic_opt ((2, "value", "value"), (message (module Imported'modules.Any.Google.Protobuf.Any))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; value } -> serialize writer name value

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name value = { name; value } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; value } -> serialize name value
      let from_json_exn =
        let constructor name value = { name; value } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
  end
end

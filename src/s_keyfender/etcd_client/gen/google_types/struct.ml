(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: google/protobuf/struct.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec Google : sig
  module rec Protobuf : sig

    (**
      `NullValue` is a singleton enumeration to represent the null value for the
      `Value` type union.

      The JSON representation for `NullValue` is JSON `null`.
    *)
    module rec NullValue : sig
      type t =
        | NULL_VALUE
        (** Null value. *)

      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end

    (**
      `Struct` represents a structured data value, consisting of fields
      which map to dynamically typed values. In some languages, `Struct`
      might be supported by a native representation. For example, in
      scripting languages like JS a struct is represented as an
      object. The details of that representation are described together
      with the proto support for the language.

      The JSON representation for `Struct` is JSON object.
    *)
    and Struct : sig
      type t = ((string * Value.t option) list)
      (**
      Unordered map of dynamically typed values.
      *)

      val make: ?fields:(string * Value.t option) list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?fields:(string * Value.t option) list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      `Value` represents a dynamically typed value which can be either
      null, a number, a string, a boolean, a recursive struct value, or a
      list of values. A producer of value is expected to set one of these
      variants. Absence of any variant indicates an error.

      The JSON representation for `Value` is JSON value.
    *)
    and Value : sig
      type t = ([ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ])
      val make: ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      `ListValue` is a wrapper around a repeated field of values.

      The JSON representation for `ListValue` is JSON array.
    *)
    and ListValue : sig
      type t = (Value.t list)
      (**
      Repeated field of dynamically typed values.
      *)

      val make: ?values:Value.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?values:Value.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end
end = struct
  module rec Protobuf : sig

    (**
      `NullValue` is a singleton enumeration to represent the null value for the
      `Value` type union.

      The JSON representation for `NullValue` is JSON `null`.
    *)
    module rec NullValue : sig
      type t =
        | NULL_VALUE
        (** Null value. *)

      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end

    (**
      `Struct` represents a structured data value, consisting of fields
      which map to dynamically typed values. In some languages, `Struct`
      might be supported by a native representation. For example, in
      scripting languages like JS a struct is represented as an
      object. The details of that representation are described together
      with the proto support for the language.

      The JSON representation for `Struct` is JSON object.
    *)
    and Struct : sig
      type t = ((string * Value.t option) list)
      (**
      Unordered map of dynamically typed values.
      *)

      val make: ?fields:(string * Value.t option) list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?fields:(string * Value.t option) list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      `Value` represents a dynamically typed value which can be either
      null, a number, a string, a boolean, a recursive struct value, or a
      list of values. A producer of value is expected to set one of these
      variants. Absence of any variant indicates an error.

      The JSON representation for `Value` is JSON value.
    *)
    and Value : sig
      type t = ([ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ])
      val make: ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    (**
      `ListValue` is a wrapper around a repeated field of values.

      The JSON representation for `ListValue` is JSON array.
    *)
    and ListValue : sig
      type t = (Value.t list)
      (**
      Repeated field of dynamically typed values.
      *)

      val make: ?values:Value.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?values:Value.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end
  end = struct
    module rec NullValue : sig
      type t =
        | NULL_VALUE
        (** Null value. *)

      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = NullValue
      type t =
        | NULL_VALUE
        (** Null value. *)

      let name () = ".google.protobuf.NullValue"
      let to_int = function
        | NULL_VALUE -> 0
      let from_int_exn = function
        | 0 -> NULL_VALUE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | NULL_VALUE -> "NULL_VALUE"
      let from_string_exn = function
        | "NULL_VALUE" -> NULL_VALUE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    and Struct : sig
      type t = ((string * Value.t option) list)
      (**
      Unordered map of dynamically typed values.
      *)

      val make: ?fields:(string * Value.t option) list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?fields:(string * Value.t option) list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Struct
      let name () = ".google.protobuf.Struct"
      type t = ((string * Value.t option) list)
      (**
      Unordered map of dynamically typed values.
      *)

      type make_t = ?fields:(string * Value.t option) list -> unit -> t
      let make ?(fields = []) () = (fields)
      let merge =
      let merge_fields = Runtime'.Merge.merge Runtime'.Spec.( map ((1, "fields", "fields"), (string, basic_opt ((2, "value", "value"), (message (module Value))))) ) in
      fun (t1_fields) (t2_fields) -> merge_fields t1_fields t2_fields
      let spec () = Runtime'.Spec.( map ((1, "fields", "fields"), (string, basic_opt ((2, "value", "value"), (message (module Value))))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (fields) -> serialize writer fields

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor fields = (fields) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (fields) -> serialize fields
      let from_json_exn =
        let constructor fields = (fields) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and Value : sig
      type t = ([ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ])
      val make: ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Value
      let name () = ".google.protobuf.Value"
      type t = ([ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ])
      type make_t = ?kind:[ `not_set | `Null_value of NullValue.t | `Number_value of float | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
      let make ?(kind = `not_set) () = (kind)
      let merge =
      let merge_oneof_kind__Null_value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (enum (module NullValue))) ) in
      let merge_oneof_kind__Number_value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), double) ) in
      let merge_oneof_kind__String_value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), string) ) in
      let merge_oneof_kind__Bool_value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), bool) ) in
      let merge_oneof_kind__Struct_value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module Struct))) ) in
      let merge_oneof_kind__List_value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module ListValue))) ) in
      fun (t1_kind) (t2_kind) -> match (t1_kind, t2_kind) with
      | (`Null_value v1, `Null_value v2) -> `Null_value (merge_oneof_kind__Null_value v1 v2)
      | (`Number_value v1, `Number_value v2) -> `Number_value (merge_oneof_kind__Number_value v1 v2)
      | (`String_value v1, `String_value v2) -> `String_value (merge_oneof_kind__String_value v1 v2)
      | (`Bool_value v1, `Bool_value v2) -> `Bool_value (merge_oneof_kind__Bool_value v1 v2)
      | (`Struct_value v1, `Struct_value v2) -> `Struct_value (merge_oneof_kind__Struct_value v1 v2)
      | (`List_value v1, `List_value v2) -> `List_value (merge_oneof_kind__List_value v1 v2)
      | (v1, `not_set) -> v1
      | (_, v2) -> v2
      let spec () = Runtime'.Spec.( oneof (([ oneof_elem ((1, "null_value", "nullValue"), (enum (module NullValue)), ((fun v -> `Null_value v), (function `Null_value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((2, "number_value", "numberValue"), double, ((fun v -> `Number_value v), (function `Number_value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((3, "string_value", "stringValue"), string, ((fun v -> `String_value v), (function `String_value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((4, "bool_value", "boolValue"), bool, ((fun v -> `Bool_value v), (function `Bool_value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((5, "struct_value", "structValue"), (message (module Struct)), ((fun v -> `Struct_value v), (function `Struct_value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((6, "list_value", "listValue"), (message (module ListValue)), ((fun v -> `List_value v), (function `List_value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `Null_value _ -> 0 | `Number_value _ -> 1 | `String_value _ -> 2 | `Bool_value _ -> 3 | `Struct_value _ -> 4 | `List_value _ -> 5))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (kind) -> serialize writer kind

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor kind = (kind) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (kind) -> serialize kind
      let from_json_exn =
        let constructor kind = (kind) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and ListValue : sig
      type t = (Value.t list)
      (**
      Repeated field of dynamically typed values.
      *)

      val make: ?values:Value.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?values:Value.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = ListValue
      let name () = ".google.protobuf.ListValue"
      type t = (Value.t list)
      (**
      Repeated field of dynamically typed values.
      *)

      type make_t = ?values:Value.t list -> unit -> t
      let make ?(values = []) () = (values)
      let merge =
      let merge_values = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "values", "values"), (message (module Value)), not_packed) ) in
      fun (t1_values) (t2_values) -> merge_values t1_values t2_values
      let spec () = Runtime'.Spec.( repeated ((1, "values", "values"), (message (module Value)), not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (values) -> serialize writer values

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor values = (values) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (values) -> serialize values
      let from_json_exn =
        let constructor values = (values) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
  end
end

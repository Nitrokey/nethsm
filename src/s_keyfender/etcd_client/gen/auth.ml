(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: etcd/api/authpb/auth.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show { with_path = false}]'
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
  module Gogo = Gogo
end
(**/**)
module rec Authpb : sig
  module rec UserAddOptions : sig
    type t = (bool)[@@deriving show { with_path = false}]
    val make: ?no_password:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?no_password:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end

  (** User is a single entry in the bucket authUsers *)
  and User : sig
    type t = {
    name: bytes;
    password: bytes;
    roles: string list;
    options: UserAddOptions.t option;
    }[@@deriving show { with_path = false}]
    val make: ?name:bytes -> ?password:bytes -> ?roles:string list -> ?options:UserAddOptions.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:bytes -> ?password:bytes -> ?roles:string list -> ?options:UserAddOptions.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end

  (** Permission is a single entity *)
  and Permission : sig
    module rec Type : sig
      type t =
        | READ
        | WRITE
        | READWRITE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    permType: Type.t;
    key: bytes;
    range_end: bytes;
    }[@@deriving show { with_path = false}]
    val make: ?permType:Type.t -> ?key:bytes -> ?range_end:bytes -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?permType:Type.t -> ?key:bytes -> ?range_end:bytes -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end

  (** Role is a single entry in the bucket authRoles *)
  and Role : sig
    type t = {
    name: bytes;
    keyPermission: Permission.t list;
    }[@@deriving show { with_path = false}]
    val make: ?name:bytes -> ?keyPermission:Permission.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:bytes -> ?keyPermission:Permission.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
end = struct
  module rec UserAddOptions : sig
    type t = (bool)[@@deriving show { with_path = false}]
    val make: ?no_password:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?no_password:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = UserAddOptions
    let name () = ".authpb.UserAddOptions"
    type t = (bool)[@@deriving show { with_path = false}]
    type make_t = ?no_password:bool -> unit -> t
    let make ?(no_password = false) () = (no_password)
    let merge =
    let merge_no_password = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "no_password", "noPassword"), bool, (false)) ) in
    fun (t1_no_password) (t2_no_password) -> merge_no_password t1_no_password t2_no_password
    let spec () = Runtime'.Spec.( basic ((1, "no_password", "noPassword"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (no_password) -> serialize writer no_password

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor no_password = (no_password) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (no_password) -> serialize no_password
    let from_json_exn =
      let constructor no_password = (no_password) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and User : sig
    type t = {
    name: bytes;
    password: bytes;
    roles: string list;
    options: UserAddOptions.t option;
    }[@@deriving show { with_path = false}]
    val make: ?name:bytes -> ?password:bytes -> ?roles:string list -> ?options:UserAddOptions.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:bytes -> ?password:bytes -> ?roles:string list -> ?options:UserAddOptions.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = User
    let name () = ".authpb.User"
    type t = {
    name: bytes;
    password: bytes;
    roles: string list;
    options: UserAddOptions.t option;
    }[@@deriving show { with_path = false}]
    type make_t = ?name:bytes -> ?password:bytes -> ?roles:string list -> ?options:UserAddOptions.t -> unit -> t
    let make ?(name = (Bytes.of_string {||})) ?(password = (Bytes.of_string {||})) ?(roles = []) ?options () = { name; password; roles; options }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_password = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "password", "password"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_roles = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "roles", "roles"), string, not_packed) ) in
    let merge_options = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "options", "options"), (message (module UserAddOptions))) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    password = (merge_password t1.password t2.password);
    roles = (merge_roles t1.roles t2.roles);
    options = (merge_options t1.options t2.options);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), bytes, ((Bytes.of_string {||}))) ^:: basic ((2, "password", "password"), bytes, ((Bytes.of_string {||}))) ^:: repeated ((3, "roles", "roles"), string, not_packed) ^:: basic_opt ((4, "options", "options"), (message (module UserAddOptions))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; password; roles; options } -> serialize writer name password roles options

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name password roles options = { name; password; roles; options } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; password; roles; options } -> serialize name password roles options
    let from_json_exn =
      let constructor name password roles options = { name; password; roles; options } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and Permission : sig
    module rec Type : sig
      type t =
        | READ
        | WRITE
        | READWRITE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    permType: Type.t;
    key: bytes;
    range_end: bytes;
    }[@@deriving show { with_path = false}]
    val make: ?permType:Type.t -> ?key:bytes -> ?range_end:bytes -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?permType:Type.t -> ?key:bytes -> ?range_end:bytes -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = Permission
    module rec Type : sig
      type t =
        | READ
        | WRITE
        | READWRITE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = Type
      type t =
        | READ
        | WRITE
        | READWRITE
      [@@deriving show { with_path = false}]
      let name () = ".authpb.Permission.Type"
      let to_int = function
        | READ -> 0
        | WRITE -> 1
        | READWRITE -> 2
      let from_int_exn = function
        | 0 -> READ
        | 1 -> WRITE
        | 2 -> READWRITE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | READ -> "READ"
        | WRITE -> "WRITE"
        | READWRITE -> "READWRITE"
      let from_string_exn = function
        | "READ" -> READ
        | "WRITE" -> WRITE
        | "READWRITE" -> READWRITE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".authpb.Permission"
    type t = {
    permType: Type.t;
    key: bytes;
    range_end: bytes;
    }[@@deriving show { with_path = false}]
    type make_t = ?permType:Type.t -> ?key:bytes -> ?range_end:bytes -> unit -> t
    let make ?(permType = Type.from_int_exn 0) ?(key = (Bytes.of_string {||})) ?(range_end = (Bytes.of_string {||})) () = { permType; key; range_end }
    let merge =
    let merge_permType = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "permType", "permType"), (enum (module Type)), (Type.from_int_exn 0)) ) in
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_range_end = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ) in
    fun t1 t2 -> {
    permType = (merge_permType t1.permType t2.permType);
    key = (merge_key t1.key t2.key);
    range_end = (merge_range_end t1.range_end t2.range_end);
     }
    let spec () = Runtime'.Spec.( basic ((1, "permType", "permType"), (enum (module Type)), (Type.from_int_exn 0)) ^:: basic ((2, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((3, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { permType; key; range_end } -> serialize writer permType key range_end

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor permType key range_end = { permType; key; range_end } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { permType; key; range_end } -> serialize permType key range_end
    let from_json_exn =
      let constructor permType key range_end = { permType; key; range_end } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and Role : sig
    type t = {
    name: bytes;
    keyPermission: Permission.t list;
    }[@@deriving show { with_path = false}]
    val make: ?name:bytes -> ?keyPermission:Permission.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:bytes -> ?keyPermission:Permission.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = Role
    let name () = ".authpb.Role"
    type t = {
    name: bytes;
    keyPermission: Permission.t list;
    }[@@deriving show { with_path = false}]
    type make_t = ?name:bytes -> ?keyPermission:Permission.t list -> unit -> t
    let make ?(name = (Bytes.of_string {||})) ?(keyPermission = []) () = { name; keyPermission }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_keyPermission = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "keyPermission", "keyPermission"), (message (module Permission)), not_packed) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    keyPermission = (merge_keyPermission t1.keyPermission t2.keyPermission);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), bytes, ((Bytes.of_string {||}))) ^:: repeated ((2, "keyPermission", "keyPermission"), (message (module Permission)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; keyPermission } -> serialize writer name keyPermission

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name keyPermission = { name; keyPermission } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; keyPermission } -> serialize name keyPermission
    let from_json_exn =
      let constructor name keyPermission = { name; keyPermission } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
end

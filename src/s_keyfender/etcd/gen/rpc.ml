(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: etcd/api/etcdserverpb/rpc.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show { with_path = false}]'
    opens=[Stubs; Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

open Stubs [@@warning "-33"]
open Google_types [@@warning "-33"]
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
  module Gogo = Gogo
  module Kv = Kv
  module Auth = Auth
  module Version = Version
  module Annotations = Annotations
end
(**/**)
module rec Etcdserverpb : sig
  module rec AlarmType : sig
    type t =
      | NONE
      (** default, used to query if any alarm is active *)
      | NOSPACE
      (** space quota is exhausted *)
      | CORRUPT
      (** kv store corruption detected *)
    [@@deriving show { with_path = false}]
    val name: unit -> string
    (** Fully qualified protobuf name of this enum *)

    (**/**)
    val to_int: t -> int
    val from_int: int -> t Runtime'.Result.t
    val from_int_exn: int -> t
    val to_string: t -> string
    val from_string_exn: string -> t
    (**/**)
  end
  and ResponseHeader : sig
    type t = {
    cluster_id: int;(** cluster_id is the ID of the cluster which sent the response. *)
    member_id: int;(** member_id is the ID of the member which sent the response. *)
    revision: int;(** revision is the key-value store revision when the request was applied.
    For watch progress responses, the header.revision indicates progress. All future events
    received in this stream are guaranteed to have a higher revision number than the
    header.revision number. *)
    raft_term: int;(** raft_term is the raft term when the request was applied. *)
    }[@@deriving show { with_path = false}]
    val make: ?cluster_id:int -> ?member_id:int -> ?revision:int -> ?raft_term:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?cluster_id:int -> ?member_id:int -> ?revision:int -> ?raft_term:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and RangeRequest : sig
    module rec SortOrder : sig
      type t =
        | NONE
        (** default, no sorting *)
        | ASCEND
        (** lowest target value first *)
        | DESCEND
        (** highest target value first *)
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    and SortTarget : sig
      type t =
        | KEY
        | VERSION
        | CREATE
        | MOD
        | VALUE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    key: bytes;(** key is the first key for the range. If range_end is not given, the request only looks up key. *)
    range_end: bytes;(** range_end is the upper bound on the requested range \[key, range_end).
    If range_end is '\\0', the range is all keys >= key.
    If range_end is key plus one (e.g., "aa"+1 == "ab", "a\\xff"+1 == "b"),
    then the range request gets all keys prefixed with key.
    If both key and range_end are '\\0', then the range request returns all keys. *)
    limit: int;(** limit is a limit on the number of keys returned for the request. When limit is set to 0,
    it is treated as no limit. *)
    revision: int;(** revision is the point-in-time of the key-value store to use for the range.
    If revision is less or equal to zero, the range is over the newest key-value store.
    If the revision has been compacted, ErrCompacted is returned as a response. *)
    sort_order: SortOrder.t;(** sort_order is the order for returned sorted results. *)
    sort_target: SortTarget.t;(** sort_target is the key-value field to use for sorting. *)
    serializable: bool;(** serializable sets the range request to use serializable member-local reads.
    Range requests are linearizable by default; linearizable requests have higher
    latency and lower throughput than serializable requests but reflect the current
    consensus of the cluster. For better performance, in exchange for possible stale reads,
    a serializable range request is served locally without needing to reach consensus
    with other nodes in the cluster. *)
    keys_only: bool;(** keys_only when set returns only the keys and not the values. *)
    count_only: bool;(** count_only when set returns only the count of the keys in the range. *)
    min_mod_revision: int;(** min_mod_revision is the lower bound for returned key mod revisions; all keys with
    lesser mod revisions will be filtered away. *)
    max_mod_revision: int;(** max_mod_revision is the upper bound for returned key mod revisions; all keys with
    greater mod revisions will be filtered away. *)
    min_create_revision: int;(** min_create_revision is the lower bound for returned key create revisions; all keys with
    lesser create revisions will be filtered away. *)
    max_create_revision: int;(** max_create_revision is the upper bound for returned key create revisions; all keys with
    greater create revisions will be filtered away. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?range_end:bytes -> ?limit:int -> ?revision:int -> ?sort_order:SortOrder.t -> ?sort_target:SortTarget.t -> ?serializable:bool -> ?keys_only:bool -> ?count_only:bool -> ?min_mod_revision:int -> ?max_mod_revision:int -> ?min_create_revision:int -> ?max_create_revision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?range_end:bytes -> ?limit:int -> ?revision:int -> ?sort_order:SortOrder.t -> ?sort_target:SortTarget.t -> ?serializable:bool -> ?keys_only:bool -> ?count_only:bool -> ?min_mod_revision:int -> ?max_mod_revision:int -> ?min_create_revision:int -> ?max_create_revision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and RangeResponse : sig
    type t = {
    header: ResponseHeader.t option;
    kvs: Imported'modules.Kv.Mvccpb.KeyValue.t list;(** kvs is the list of key-value pairs matched by the range request.
    kvs is empty when count is requested. *)
    more: bool;(** more indicates if there are more keys to return in the requested range. *)
    count: int;(** count is set to the number of keys within the range when requested. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> ?more:bool -> ?count:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> ?more:bool -> ?count:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and PutRequest : sig
    type t = {
    key: bytes;(** key is the key, in bytes, to put into the key-value store. *)
    value: bytes;(** value is the value, in bytes, to associate with the key in the key-value store. *)
    lease: int;(** lease is the lease ID to associate with the key in the key-value store. A lease
    value of 0 indicates no lease. *)
    prev_kv: bool;(** If prev_kv is set, etcd gets the previous key-value pair before changing it.
    The previous key-value pair will be returned in the put response. *)
    ignore_value: bool;(** If ignore_value is set, etcd updates the key using its current value.
    Returns an error if the key does not exist. *)
    ignore_lease: bool;(** If ignore_lease is set, etcd updates the key using its current lease.
    Returns an error if the key does not exist. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?value:bytes -> ?lease:int -> ?prev_kv:bool -> ?ignore_value:bool -> ?ignore_lease:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?value:bytes -> ?lease:int -> ?prev_kv:bool -> ?ignore_value:bool -> ?ignore_lease:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and PutResponse : sig
    type t = {
    header: ResponseHeader.t option;
    prev_kv: Imported'modules.Kv.Mvccpb.KeyValue.t option;(** if prev_kv is set in the request, the previous key-value pair will be returned. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?prev_kv:Imported'modules.Kv.Mvccpb.KeyValue.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?prev_kv:Imported'modules.Kv.Mvccpb.KeyValue.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and DeleteRangeRequest : sig
    type t = {
    key: bytes;(** key is the first key to delete in the range. *)
    range_end: bytes;(** range_end is the key following the last key to delete for the range \[key, range_end).
    If range_end is not given, the range is defined to contain only the key argument.
    If range_end is one bit larger than the given key, then the range is all the keys
    with the prefix (the given key).
    If range_end is '\\0', the range is all keys greater than or equal to the key argument. *)
    prev_kv: bool;(** If prev_kv is set, etcd gets the previous key-value pairs before deleting it.
    The previous key-value pairs will be returned in the delete response. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?range_end:bytes -> ?prev_kv:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?range_end:bytes -> ?prev_kv:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and DeleteRangeResponse : sig
    type t = {
    header: ResponseHeader.t option;
    deleted: int;(** deleted is the number of keys deleted by the delete range request. *)
    prev_kvs: Imported'modules.Kv.Mvccpb.KeyValue.t list;(** if prev_kv is set in the request, the previous key-value pairs will be returned. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?deleted:int -> ?prev_kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?deleted:int -> ?prev_kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and RequestOp : sig
    type t = ([ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ])[@@deriving show { with_path = false}]
    val make: ?request:[ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ] -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?request:[ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ] -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and ResponseOp : sig
    type t = ([ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ])[@@deriving show { with_path = false}]
    val make: ?response:[ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ] -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?response:[ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ] -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and Compare : sig
    module rec CompareResult : sig
      type t =
        | EQUAL
        | GREATER
        | LESS
        | NOT_EQUAL
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    and CompareTarget : sig
      type t =
        | VERSION
        | CREATE
        | MOD
        | VALUE
        | LEASE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    result: CompareResult.t;(** result is logical comparison operation for this comparison. *)
    target: CompareTarget.t;(** target is the key-value field to inspect for the comparison. *)
    key: bytes;(** key is the subject key for the comparison operation. *)
    target_union: [ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ];
    range_end: bytes;(** range_end compares the given target to all keys in the range \[key, range_end).
    See RangeRequest for more details on key ranges.


    TODO: fill out with most of the rest of RangeRequest fields when needed. *)
    }[@@deriving show { with_path = false}]
    val make: ?result:CompareResult.t -> ?target:CompareTarget.t -> ?key:bytes -> ?target_union:[ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ] -> ?range_end:bytes -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?result:CompareResult.t -> ?target:CompareTarget.t -> ?key:bytes -> ?target_union:[ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ] -> ?range_end:bytes -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end

  (**
    From google paxosdb paper:
    Our implementation hinges around a powerful primitive which we call MultiOp. All other database
    operations except for iteration are implemented as a single call to MultiOp. A MultiOp is applied atomically
    and consists of three components:
    1. A list of tests called guard. Each test in guard checks a single entry in the database. It may check
    for the absence or presence of a value, or compare with a given value. Two different tests in the guard
    may apply to the same or different entries in the database. All tests in the guard are applied and
    MultiOp returns the results. If all tests are true, MultiOp executes t op (see item 2 below), otherwise
    it executes f op (see item 3 below).
    2. A list of database operations called t op. Each operation in the list is either an insert, delete, or
    lookup operation, and applies to a single database entry. Two different operations in the list may apply
    to the same or different entries in the database. These operations are executed
    if guard evaluates to
    true.
    3. A list of database operations called f op. Like t op, but executed if guard evaluates to false.
  *)
  and TxnRequest : sig
    type t = {
    compare: Compare.t list;(** compare is a list of predicates representing a conjunction of terms.
    If the comparisons succeed, then the success requests will be processed in order,
    and the response will contain their respective responses in order.
    If the comparisons fail, then the failure requests will be processed in order,
    and the response will contain their respective responses in order. *)
    success: RequestOp.t list;(** success is a list of requests which will be applied when compare evaluates to true. *)
    failure: RequestOp.t list;(** failure is a list of requests which will be applied when compare evaluates to false. *)
    }[@@deriving show { with_path = false}]
    val make: ?compare:Compare.t list -> ?success:RequestOp.t list -> ?failure:RequestOp.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?compare:Compare.t list -> ?success:RequestOp.t list -> ?failure:RequestOp.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and TxnResponse : sig
    type t = {
    header: ResponseHeader.t option;
    succeeded: bool;(** succeeded is set to true if the compare evaluated to true or false otherwise. *)
    responses: ResponseOp.t list;(** responses is a list of responses corresponding to the results from applying
    success if succeeded is true or failure if succeeded is false. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?succeeded:bool -> ?responses:ResponseOp.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?succeeded:bool -> ?responses:ResponseOp.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end

  (**
    CompactionRequest compacts the key-value store up to a given revision. All superseded keys
    with a revision less than the compaction revision will be removed.
  *)
  and CompactionRequest : sig
    type t = {
    revision: int;(** revision is the key-value store revision for the compaction operation. *)
    physical: bool;(** physical is set so the RPC will wait until the compaction is physically
    applied to the local database such that compacted entries are totally
    removed from the backend database. *)
    }[@@deriving show { with_path = false}]
    val make: ?revision:int -> ?physical:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?revision:int -> ?physical:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and CompactionResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and HashRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and HashKVRequest : sig
    type t = (int)
    (**
    revision is the key-value store revision for the hash operation.
    *)
    [@@deriving show { with_path = false}]
    val make: ?revision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?revision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and HashKVResponse : sig
    type t = {
    header: ResponseHeader.t option;
    hash: int;(** hash is the hash value computed from the responding member's MVCC keys up to a given revision. *)
    compact_revision: int;(** compact_revision is the compacted revision of key-value store when hash begins. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?hash:int -> ?compact_revision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?hash:int -> ?compact_revision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and HashResponse : sig
    type t = {
    header: ResponseHeader.t option;
    hash: int;(** hash is the hash value computed from the responding member's KV's backend. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?hash:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?hash:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and SnapshotRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and SnapshotResponse : sig
    type t = {
    header: ResponseHeader.t option;(** header has the current key-value store information. The first header in the snapshot
    stream indicates the point in time of the snapshot. *)
    remaining_bytes: int;(** remaining_bytes is the number of blob bytes to be sent after this message *)
    blob: bytes;(** blob contains the next chunk of the snapshot in the snapshot stream. *)
    version: string;(** local version of server that created the snapshot.
    In cluster with binaries with different version, each cluster can return different result.
    Informs which etcd server version should be used when restoring the snapshot. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?remaining_bytes:int -> ?blob:bytes -> ?version:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?remaining_bytes:int -> ?blob:bytes -> ?version:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and WatchRequest : sig
    type t = ([ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ])[@@deriving show { with_path = false}]
    val make: ?request_union:[ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ] -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?request_union:[ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ] -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and WatchCreateRequest : sig
    module rec FilterType : sig
      type t =
        | NOPUT
        (** filter out put event. *)
        | NODELETE
        (** filter out delete event. *)
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    key: bytes;(** key is the key to register for watching. *)
    range_end: bytes;(** range_end is the end of the range \[key, range_end) to watch. If range_end is not given,
    only the key argument is watched. If range_end is equal to '\\0', all keys greater than
    or equal to the key argument are watched.
    If the range_end is one bit larger than the given key,
    then all keys with the prefix (the given key) will be watched. *)
    start_revision: int;(** start_revision is an optional revision to watch from (inclusive). No start_revision is "now". *)
    progress_notify: bool;(** progress_notify is set so that the etcd server will periodically send a WatchResponse with
    no events to the new watcher if there are no recent events. It is useful when clients
    wish to recover a disconnected watcher starting from a recent known revision.
    The etcd server may decide how often it will send notifications based on current load. *)
    filters: FilterType.t list;(** filters filter the events at server side before it sends back to the watcher. *)
    prev_kv: bool;(** If prev_kv is set, created watcher gets the previous KV before the event happens.
    If the previous KV is already compacted, nothing will be returned. *)
    watch_id: int;(** If watch_id is provided and non-zero, it will be assigned to this watcher.
    Since creating a watcher in etcd is not a synchronous operation,
    this can be used ensure that ordering is correct when creating multiple
    watchers on the same stream. Creating a watcher with an ID already in
    use on the stream will cause an error to be returned. *)
    fragment: bool;(** fragment enables splitting large revisions into multiple watch responses. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?range_end:bytes -> ?start_revision:int -> ?progress_notify:bool -> ?filters:FilterType.t list -> ?prev_kv:bool -> ?watch_id:int -> ?fragment:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?range_end:bytes -> ?start_revision:int -> ?progress_notify:bool -> ?filters:FilterType.t list -> ?prev_kv:bool -> ?watch_id:int -> ?fragment:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and WatchCancelRequest : sig
    type t = (int)
    (**
    watch_id is the watcher id to cancel so that no more events are transmitted.
    *)
    [@@deriving show { with_path = false}]
    val make: ?watch_id:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?watch_id:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end

  (**
    Requests the a watch stream progress status be sent in the watch response stream as soon as
    possible.
  *)
  and WatchProgressRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and WatchResponse : sig
    type t = {
    header: ResponseHeader.t option;
    watch_id: int;(** watch_id is the ID of the watcher that corresponds to the response. *)
    created: bool;(** created is set to true if the response is for a create watch request.
    The client should record the watch_id and expect to receive events for
    the created watcher from the same stream.
    All events sent to the created watcher will attach with the same watch_id. *)
    canceled: bool;(** canceled is set to true if the response is for a cancel watch request.
    No further events will be sent to the canceled watcher. *)
    compact_revision: int;(** compact_revision is set to the minimum index if a watcher tries to watch
    at a compacted index.

    This happens when creating a watcher at a compacted revision or the watcher cannot
    catch up with the progress of the key-value store.

    The client should treat the watcher as canceled and should not try to create any
    watcher with the same start_revision again. *)
    cancel_reason: string;(** cancel_reason indicates the reason for canceling the watcher. *)
    fragment: bool;(** framgment is true if large watch response was split over multiple responses. *)
    events: Imported'modules.Kv.Mvccpb.Event.t list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?watch_id:int -> ?created:bool -> ?canceled:bool -> ?compact_revision:int -> ?cancel_reason:string -> ?fragment:bool -> ?events:Imported'modules.Kv.Mvccpb.Event.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?watch_id:int -> ?created:bool -> ?canceled:bool -> ?compact_revision:int -> ?cancel_reason:string -> ?fragment:bool -> ?events:Imported'modules.Kv.Mvccpb.Event.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseGrantRequest : sig
    type t = {
    tTL: int;(** TTL is the advisory time-to-live in seconds. Expired lease will return -1. *)
    iD: int;(** ID is the requested ID for the lease. If ID is set to 0, the lessor chooses an ID. *)
    }[@@deriving show { with_path = false}]
    val make: ?tTL:int -> ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?tTL:int -> ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseGrantResponse : sig
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID for the granted lease. *)
    tTL: int;(** TTL is the server chosen lease time-to-live in seconds. *)
    error: string;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?error:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?error:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseRevokeRequest : sig
    type t = (int)
    (**
    ID is the lease ID to revoke. When the ID is revoked, all associated keys will be deleted.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseRevokeResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseCheckpoint : sig
    type t = {
    iD: int;(** ID is the lease ID to checkpoint. *)
    remaining_TTL: int;(** Remaining_TTL is the remaining time until expiry of the lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?remaining_TTL:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?remaining_TTL:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseCheckpointRequest : sig
    type t = (LeaseCheckpoint.t list)[@@deriving show { with_path = false}]
    val make: ?checkpoints:LeaseCheckpoint.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?checkpoints:LeaseCheckpoint.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseCheckpointResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseKeepAliveRequest : sig
    type t = (int)
    (**
    ID is the lease ID for the lease to keep alive.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseKeepAliveResponse : sig
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID from the keep alive request. *)
    tTL: int;(** TTL is the new time-to-live for the lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseTimeToLiveRequest : sig
    type t = {
    iD: int;(** ID is the lease ID for the lease. *)
    keys: bool;(** keys is true to query all the keys attached to this lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?keys:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?keys:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseTimeToLiveResponse : sig
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID from the keep alive request. *)
    tTL: int;(** TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds. *)
    grantedTTL: int;(** GrantedTTL is the initial granted time in seconds upon lease creation/renewal. *)
    keys: bytes list;(** Keys is the list of keys attached to this lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?grantedTTL:int -> ?keys:bytes list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?grantedTTL:int -> ?keys:bytes list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseLeasesRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseStatus : sig
    type t = (int)
    (**
    TODO: int64 TTL = 2;
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and LeaseLeasesResponse : sig
    type t = {
    header: ResponseHeader.t option;
    leases: LeaseStatus.t list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?leases:LeaseStatus.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?leases:LeaseStatus.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and Member : sig
    type t = {
    iD: int;(** ID is the member ID for this member. *)
    name: string;(** name is the human-readable name of the member. If the member is not started, the name will be an empty string. *)
    peerURLs: string list;(** peerURLs is the list of URLs the member exposes to the cluster for communication. *)
    clientURLs: string list;(** clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty. *)
    isLearner: bool;(** isLearner indicates if the member is raft learner. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?name:string -> ?peerURLs:string list -> ?clientURLs:string list -> ?isLearner:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?name:string -> ?peerURLs:string list -> ?clientURLs:string list -> ?isLearner:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberAddRequest : sig
    type t = {
    peerURLs: string list;(** peerURLs is the list of URLs the added member will use to communicate with the cluster. *)
    isLearner: bool;(** isLearner indicates if the added member is raft learner. *)
    }[@@deriving show { with_path = false}]
    val make: ?peerURLs:string list -> ?isLearner:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?peerURLs:string list -> ?isLearner:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberAddResponse : sig
    type t = {
    header: ResponseHeader.t option;
    member: Member.t option;(** member is the member information for the added member. *)
    members: Member.t list;(** members is a list of all members after adding the new member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?member:Member.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?member:Member.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberRemoveRequest : sig
    type t = (int)
    (**
    ID is the member ID of the member to remove.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberRemoveResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after removing the member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberUpdateRequest : sig
    type t = {
    iD: int;(** ID is the member ID of the member to update. *)
    peerURLs: string list;(** peerURLs is the new list of URLs the member will use to communicate with the cluster. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?peerURLs:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?peerURLs:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberUpdateResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after updating the member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberListRequest : sig
    type t = (bool)[@@deriving show { with_path = false}]
    val make: ?linearizable:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?linearizable:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberListResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members associated with the cluster. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberPromoteRequest : sig
    type t = (int)
    (**
    ID is the member ID of the member to promote.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MemberPromoteResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after promoting the member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and DefragmentRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and DefragmentResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MoveLeaderRequest : sig
    type t = (int)
    (**
    targetID is the node ID for the new leader.
    *)
    [@@deriving show { with_path = false}]
    val make: ?targetID:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?targetID:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and MoveLeaderResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AlarmRequest : sig
    module rec AlarmAction : sig
      type t =
        | GET
        | ACTIVATE
        | DEACTIVATE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    action: AlarmAction.t;(** action is the kind of alarm request to issue. The action
    may GET alarm statuses, ACTIVATE an alarm, or DEACTIVATE a
    raised alarm. *)
    memberID: int;(** memberID is the ID of the member associated with the alarm. If memberID is 0, the
    alarm request covers all members. *)
    alarm: AlarmType.t;(** alarm is the type of alarm to consider for this request. *)
    }[@@deriving show { with_path = false}]
    val make: ?action:AlarmAction.t -> ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?action:AlarmAction.t -> ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AlarmMember : sig
    type t = {
    memberID: int;(** memberID is the ID of the member associated with the raised alarm. *)
    alarm: AlarmType.t;(** alarm is the type of alarm which has been raised. *)
    }[@@deriving show { with_path = false}]
    val make: ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AlarmResponse : sig
    type t = {
    header: ResponseHeader.t option;
    alarms: AlarmMember.t list;(** alarms is a list of alarms associated with the alarm request. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?alarms:AlarmMember.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?alarms:AlarmMember.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and DowngradeRequest : sig
    module rec DowngradeAction : sig
      type t =
        | VALIDATE
        | ENABLE
        | CANCEL
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    action: DowngradeAction.t;(** action is the kind of downgrade request to issue. The action may
    VALIDATE the target version, DOWNGRADE the cluster version,
    or CANCEL the current downgrading job. *)
    version: string;(** version is the target version to downgrade. *)
    }[@@deriving show { with_path = false}]
    val make: ?action:DowngradeAction.t -> ?version:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?action:DowngradeAction.t -> ?version:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and DowngradeResponse : sig
    type t = {
    header: ResponseHeader.t option;
    version: string;(** version is the current cluster version. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?version:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?version:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and StatusRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and StatusResponse : sig
    type t = {
    header: ResponseHeader.t option;
    version: string;(** version is the cluster protocol version used by the responding member. *)
    dbSize: int;(** dbSize is the size of the backend database physically allocated, in bytes, of the responding member. *)
    leader: int;(** leader is the member ID which the responding member believes is the current leader. *)
    raftIndex: int;(** raftIndex is the current raft committed index of the responding member. *)
    raftTerm: int;(** raftTerm is the current raft term of the responding member. *)
    raftAppliedIndex: int;(** raftAppliedIndex is the current raft applied index of the responding member. *)
    errors: string list;(** errors contains alarm/health information and status. *)
    dbSizeInUse: int;(** dbSizeInUse is the size of the backend database logically in use, in bytes, of the responding member. *)
    isLearner: bool;(** isLearner indicates if the member is raft learner. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?version:string -> ?dbSize:int -> ?leader:int -> ?raftIndex:int -> ?raftTerm:int -> ?raftAppliedIndex:int -> ?errors:string list -> ?dbSizeInUse:int -> ?isLearner:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?version:string -> ?dbSize:int -> ?leader:int -> ?raftIndex:int -> ?raftTerm:int -> ?raftAppliedIndex:int -> ?errors:string list -> ?dbSizeInUse:int -> ?isLearner:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthEnableRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthDisableRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthStatusRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthenticateRequest : sig
    type t = {
    name: string;
    password: string;
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?password:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?password:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserAddRequest : sig
    type t = {
    name: string;
    password: string;
    options: Imported'modules.Auth.Authpb.UserAddOptions.t option;
    hashedPassword: string;
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?password:string -> ?options:Imported'modules.Auth.Authpb.UserAddOptions.t -> ?hashedPassword:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?password:string -> ?options:Imported'modules.Auth.Authpb.UserAddOptions.t -> ?hashedPassword:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserGetRequest : sig
    type t = (string)[@@deriving show { with_path = false}]
    val make: ?name:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserDeleteRequest : sig
    type t = (string)
    (**
    name is the name of the user to delete.
    *)
    [@@deriving show { with_path = false}]
    val make: ?name:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserChangePasswordRequest : sig
    type t = {
    name: string;(** name is the name of the user whose password is being changed. *)
    password: string;(** password is the new password for the user. Note that this field will be removed in the API layer. *)
    hashedPassword: string;(** hashedPassword is the new password for the user. Note that this field will be initialized in the API layer. *)
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?password:string -> ?hashedPassword:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?password:string -> ?hashedPassword:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserGrantRoleRequest : sig
    type t = {
    user: string;(** user is the name of the user which should be granted a given role. *)
    role: string;(** role is the name of the role to grant to the user. *)
    }[@@deriving show { with_path = false}]
    val make: ?user:string -> ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?user:string -> ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserRevokeRoleRequest : sig
    type t = {
    name: string;
    role: string;
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleAddRequest : sig
    type t = (string)
    (**
    name is the name of the role to add to the authentication system.
    *)
    [@@deriving show { with_path = false}]
    val make: ?name:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleGetRequest : sig
    type t = (string)[@@deriving show { with_path = false}]
    val make: ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserListRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleListRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleDeleteRequest : sig
    type t = (string)[@@deriving show { with_path = false}]
    val make: ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleGrantPermissionRequest : sig
    type t = {
    name: string;(** name is the name of the role which will be granted the permission. *)
    perm: Imported'modules.Auth.Authpb.Permission.t option;(** perm is the permission to grant to the role. *)
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?perm:Imported'modules.Auth.Authpb.Permission.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?perm:Imported'modules.Auth.Authpb.Permission.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleRevokePermissionRequest : sig
    type t = {
    role: string;
    key: bytes;
    range_end: bytes;
    }[@@deriving show { with_path = false}]
    val make: ?role:string -> ?key:bytes -> ?range_end:bytes -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?role:string -> ?key:bytes -> ?range_end:bytes -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthEnableResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthDisableResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthStatusResponse : sig
    type t = {
    header: ResponseHeader.t option;
    enabled: bool;
    authRevision: int;(** authRevision is the current revision of auth store *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?enabled:bool -> ?authRevision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?enabled:bool -> ?authRevision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthenticateResponse : sig
    type t = {
    header: ResponseHeader.t option;
    token: string;(** token is an authorized token that can be used in succeeding RPCs *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?token:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?token:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserAddResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserGetResponse : sig
    type t = {
    header: ResponseHeader.t option;
    roles: string list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserDeleteResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserChangePasswordResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserGrantRoleResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserRevokeRoleResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleAddResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleGetResponse : sig
    type t = {
    header: ResponseHeader.t option;
    perm: Imported'modules.Auth.Authpb.Permission.t list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?perm:Imported'modules.Auth.Authpb.Permission.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?perm:Imported'modules.Auth.Authpb.Permission.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleListResponse : sig
    type t = {
    header: ResponseHeader.t option;
    roles: string list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthUserListResponse : sig
    type t = {
    header: ResponseHeader.t option;
    users: string list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?users:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?users:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleDeleteResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleGrantPermissionResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and AuthRoleRevokePermissionResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  module KV : sig
    module Range : sig
      include Runtime'.Service.Rpc with type Request.t = RangeRequest.t and type Response.t = RangeResponse.t
      module Request : Runtime'.Spec.Message with type t = RangeRequest.t and type make_t = RangeRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = RangeResponse.t and type make_t = RangeResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val range : (module Runtime'.Spec.Message with type t = RangeRequest.t) * (module Runtime'.Spec.Message with type t = RangeResponse.t)
    module Put : sig
      include Runtime'.Service.Rpc with type Request.t = PutRequest.t and type Response.t = PutResponse.t
      module Request : Runtime'.Spec.Message with type t = PutRequest.t and type make_t = PutRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = PutResponse.t and type make_t = PutResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val put : (module Runtime'.Spec.Message with type t = PutRequest.t) * (module Runtime'.Spec.Message with type t = PutResponse.t)
    module DeleteRange : sig
      include Runtime'.Service.Rpc with type Request.t = DeleteRangeRequest.t and type Response.t = DeleteRangeResponse.t
      module Request : Runtime'.Spec.Message with type t = DeleteRangeRequest.t and type make_t = DeleteRangeRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = DeleteRangeResponse.t and type make_t = DeleteRangeResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val deleteRange : (module Runtime'.Spec.Message with type t = DeleteRangeRequest.t) * (module Runtime'.Spec.Message with type t = DeleteRangeResponse.t)
    module Txn : sig
      include Runtime'.Service.Rpc with type Request.t = TxnRequest.t and type Response.t = TxnResponse.t
      module Request : Runtime'.Spec.Message with type t = TxnRequest.t and type make_t = TxnRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = TxnResponse.t and type make_t = TxnResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val txn : (module Runtime'.Spec.Message with type t = TxnRequest.t) * (module Runtime'.Spec.Message with type t = TxnResponse.t)
    module Compact : sig
      include Runtime'.Service.Rpc with type Request.t = CompactionRequest.t and type Response.t = CompactionResponse.t
      module Request : Runtime'.Spec.Message with type t = CompactionRequest.t and type make_t = CompactionRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = CompactionResponse.t and type make_t = CompactionResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val compact : (module Runtime'.Spec.Message with type t = CompactionRequest.t) * (module Runtime'.Spec.Message with type t = CompactionResponse.t)
  end
  module Watch : sig
    module Watch : sig
      include Runtime'.Service.Rpc with type Request.t = WatchRequest.t and type Response.t = WatchResponse.t
      module Request : Runtime'.Spec.Message with type t = WatchRequest.t and type make_t = WatchRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = WatchResponse.t and type make_t = WatchResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val watch : (module Runtime'.Spec.Message with type t = WatchRequest.t) * (module Runtime'.Spec.Message with type t = WatchResponse.t)
  end
  module Lease : sig
    module LeaseGrant : sig
      include Runtime'.Service.Rpc with type Request.t = LeaseGrantRequest.t and type Response.t = LeaseGrantResponse.t
      module Request : Runtime'.Spec.Message with type t = LeaseGrantRequest.t and type make_t = LeaseGrantRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = LeaseGrantResponse.t and type make_t = LeaseGrantResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val leaseGrant : (module Runtime'.Spec.Message with type t = LeaseGrantRequest.t) * (module Runtime'.Spec.Message with type t = LeaseGrantResponse.t)
    module LeaseRevoke : sig
      include Runtime'.Service.Rpc with type Request.t = LeaseRevokeRequest.t and type Response.t = LeaseRevokeResponse.t
      module Request : Runtime'.Spec.Message with type t = LeaseRevokeRequest.t and type make_t = LeaseRevokeRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = LeaseRevokeResponse.t and type make_t = LeaseRevokeResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val leaseRevoke : (module Runtime'.Spec.Message with type t = LeaseRevokeRequest.t) * (module Runtime'.Spec.Message with type t = LeaseRevokeResponse.t)
    module LeaseKeepAlive : sig
      include Runtime'.Service.Rpc with type Request.t = LeaseKeepAliveRequest.t and type Response.t = LeaseKeepAliveResponse.t
      module Request : Runtime'.Spec.Message with type t = LeaseKeepAliveRequest.t and type make_t = LeaseKeepAliveRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = LeaseKeepAliveResponse.t and type make_t = LeaseKeepAliveResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val leaseKeepAlive : (module Runtime'.Spec.Message with type t = LeaseKeepAliveRequest.t) * (module Runtime'.Spec.Message with type t = LeaseKeepAliveResponse.t)
    module LeaseTimeToLive : sig
      include Runtime'.Service.Rpc with type Request.t = LeaseTimeToLiveRequest.t and type Response.t = LeaseTimeToLiveResponse.t
      module Request : Runtime'.Spec.Message with type t = LeaseTimeToLiveRequest.t and type make_t = LeaseTimeToLiveRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = LeaseTimeToLiveResponse.t and type make_t = LeaseTimeToLiveResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val leaseTimeToLive : (module Runtime'.Spec.Message with type t = LeaseTimeToLiveRequest.t) * (module Runtime'.Spec.Message with type t = LeaseTimeToLiveResponse.t)
    module LeaseLeases : sig
      include Runtime'.Service.Rpc with type Request.t = LeaseLeasesRequest.t and type Response.t = LeaseLeasesResponse.t
      module Request : Runtime'.Spec.Message with type t = LeaseLeasesRequest.t and type make_t = LeaseLeasesRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = LeaseLeasesResponse.t and type make_t = LeaseLeasesResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val leaseLeases : (module Runtime'.Spec.Message with type t = LeaseLeasesRequest.t) * (module Runtime'.Spec.Message with type t = LeaseLeasesResponse.t)
  end
  module Cluster : sig
    module MemberAdd : sig
      include Runtime'.Service.Rpc with type Request.t = MemberAddRequest.t and type Response.t = MemberAddResponse.t
      module Request : Runtime'.Spec.Message with type t = MemberAddRequest.t and type make_t = MemberAddRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = MemberAddResponse.t and type make_t = MemberAddResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val memberAdd : (module Runtime'.Spec.Message with type t = MemberAddRequest.t) * (module Runtime'.Spec.Message with type t = MemberAddResponse.t)
    module MemberRemove : sig
      include Runtime'.Service.Rpc with type Request.t = MemberRemoveRequest.t and type Response.t = MemberRemoveResponse.t
      module Request : Runtime'.Spec.Message with type t = MemberRemoveRequest.t and type make_t = MemberRemoveRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = MemberRemoveResponse.t and type make_t = MemberRemoveResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val memberRemove : (module Runtime'.Spec.Message with type t = MemberRemoveRequest.t) * (module Runtime'.Spec.Message with type t = MemberRemoveResponse.t)
    module MemberUpdate : sig
      include Runtime'.Service.Rpc with type Request.t = MemberUpdateRequest.t and type Response.t = MemberUpdateResponse.t
      module Request : Runtime'.Spec.Message with type t = MemberUpdateRequest.t and type make_t = MemberUpdateRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = MemberUpdateResponse.t and type make_t = MemberUpdateResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val memberUpdate : (module Runtime'.Spec.Message with type t = MemberUpdateRequest.t) * (module Runtime'.Spec.Message with type t = MemberUpdateResponse.t)
    module MemberList : sig
      include Runtime'.Service.Rpc with type Request.t = MemberListRequest.t and type Response.t = MemberListResponse.t
      module Request : Runtime'.Spec.Message with type t = MemberListRequest.t and type make_t = MemberListRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = MemberListResponse.t and type make_t = MemberListResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val memberList : (module Runtime'.Spec.Message with type t = MemberListRequest.t) * (module Runtime'.Spec.Message with type t = MemberListResponse.t)
    module MemberPromote : sig
      include Runtime'.Service.Rpc with type Request.t = MemberPromoteRequest.t and type Response.t = MemberPromoteResponse.t
      module Request : Runtime'.Spec.Message with type t = MemberPromoteRequest.t and type make_t = MemberPromoteRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = MemberPromoteResponse.t and type make_t = MemberPromoteResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val memberPromote : (module Runtime'.Spec.Message with type t = MemberPromoteRequest.t) * (module Runtime'.Spec.Message with type t = MemberPromoteResponse.t)
  end
  module Maintenance : sig
    module Alarm : sig
      include Runtime'.Service.Rpc with type Request.t = AlarmRequest.t and type Response.t = AlarmResponse.t
      module Request : Runtime'.Spec.Message with type t = AlarmRequest.t and type make_t = AlarmRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AlarmResponse.t and type make_t = AlarmResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val alarm : (module Runtime'.Spec.Message with type t = AlarmRequest.t) * (module Runtime'.Spec.Message with type t = AlarmResponse.t)
    module Status : sig
      include Runtime'.Service.Rpc with type Request.t = StatusRequest.t and type Response.t = StatusResponse.t
      module Request : Runtime'.Spec.Message with type t = StatusRequest.t and type make_t = StatusRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = StatusResponse.t and type make_t = StatusResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val status : (module Runtime'.Spec.Message with type t = StatusRequest.t) * (module Runtime'.Spec.Message with type t = StatusResponse.t)
    module Defragment : sig
      include Runtime'.Service.Rpc with type Request.t = DefragmentRequest.t and type Response.t = DefragmentResponse.t
      module Request : Runtime'.Spec.Message with type t = DefragmentRequest.t and type make_t = DefragmentRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = DefragmentResponse.t and type make_t = DefragmentResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val defragment : (module Runtime'.Spec.Message with type t = DefragmentRequest.t) * (module Runtime'.Spec.Message with type t = DefragmentResponse.t)
    module Hash : sig
      include Runtime'.Service.Rpc with type Request.t = HashRequest.t and type Response.t = HashResponse.t
      module Request : Runtime'.Spec.Message with type t = HashRequest.t and type make_t = HashRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = HashResponse.t and type make_t = HashResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val hash : (module Runtime'.Spec.Message with type t = HashRequest.t) * (module Runtime'.Spec.Message with type t = HashResponse.t)
    module HashKV : sig
      include Runtime'.Service.Rpc with type Request.t = HashKVRequest.t and type Response.t = HashKVResponse.t
      module Request : Runtime'.Spec.Message with type t = HashKVRequest.t and type make_t = HashKVRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = HashKVResponse.t and type make_t = HashKVResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val hashKV : (module Runtime'.Spec.Message with type t = HashKVRequest.t) * (module Runtime'.Spec.Message with type t = HashKVResponse.t)
    module Snapshot : sig
      include Runtime'.Service.Rpc with type Request.t = SnapshotRequest.t and type Response.t = SnapshotResponse.t
      module Request : Runtime'.Spec.Message with type t = SnapshotRequest.t and type make_t = SnapshotRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = SnapshotResponse.t and type make_t = SnapshotResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val snapshot : (module Runtime'.Spec.Message with type t = SnapshotRequest.t) * (module Runtime'.Spec.Message with type t = SnapshotResponse.t)
    module MoveLeader : sig
      include Runtime'.Service.Rpc with type Request.t = MoveLeaderRequest.t and type Response.t = MoveLeaderResponse.t
      module Request : Runtime'.Spec.Message with type t = MoveLeaderRequest.t and type make_t = MoveLeaderRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = MoveLeaderResponse.t and type make_t = MoveLeaderResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val moveLeader : (module Runtime'.Spec.Message with type t = MoveLeaderRequest.t) * (module Runtime'.Spec.Message with type t = MoveLeaderResponse.t)
    module Downgrade : sig
      include Runtime'.Service.Rpc with type Request.t = DowngradeRequest.t and type Response.t = DowngradeResponse.t
      module Request : Runtime'.Spec.Message with type t = DowngradeRequest.t and type make_t = DowngradeRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = DowngradeResponse.t and type make_t = DowngradeResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val downgrade : (module Runtime'.Spec.Message with type t = DowngradeRequest.t) * (module Runtime'.Spec.Message with type t = DowngradeResponse.t)
  end
  module Auth : sig
    module AuthEnable : sig
      include Runtime'.Service.Rpc with type Request.t = AuthEnableRequest.t and type Response.t = AuthEnableResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthEnableRequest.t and type make_t = AuthEnableRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthEnableResponse.t and type make_t = AuthEnableResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val authEnable : (module Runtime'.Spec.Message with type t = AuthEnableRequest.t) * (module Runtime'.Spec.Message with type t = AuthEnableResponse.t)
    module AuthDisable : sig
      include Runtime'.Service.Rpc with type Request.t = AuthDisableRequest.t and type Response.t = AuthDisableResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthDisableRequest.t and type make_t = AuthDisableRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthDisableResponse.t and type make_t = AuthDisableResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val authDisable : (module Runtime'.Spec.Message with type t = AuthDisableRequest.t) * (module Runtime'.Spec.Message with type t = AuthDisableResponse.t)
    module AuthStatus : sig
      include Runtime'.Service.Rpc with type Request.t = AuthStatusRequest.t and type Response.t = AuthStatusResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthStatusRequest.t and type make_t = AuthStatusRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthStatusResponse.t and type make_t = AuthStatusResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val authStatus : (module Runtime'.Spec.Message with type t = AuthStatusRequest.t) * (module Runtime'.Spec.Message with type t = AuthStatusResponse.t)
    module Authenticate : sig
      include Runtime'.Service.Rpc with type Request.t = AuthenticateRequest.t and type Response.t = AuthenticateResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthenticateRequest.t and type make_t = AuthenticateRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthenticateResponse.t and type make_t = AuthenticateResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val authenticate : (module Runtime'.Spec.Message with type t = AuthenticateRequest.t) * (module Runtime'.Spec.Message with type t = AuthenticateResponse.t)
    module UserAdd : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserAddRequest.t and type Response.t = AuthUserAddResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserAddRequest.t and type make_t = AuthUserAddRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserAddResponse.t and type make_t = AuthUserAddResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userAdd : (module Runtime'.Spec.Message with type t = AuthUserAddRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserAddResponse.t)
    module UserGet : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserGetRequest.t and type Response.t = AuthUserGetResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserGetRequest.t and type make_t = AuthUserGetRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserGetResponse.t and type make_t = AuthUserGetResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userGet : (module Runtime'.Spec.Message with type t = AuthUserGetRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserGetResponse.t)
    module UserList : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserListRequest.t and type Response.t = AuthUserListResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserListRequest.t and type make_t = AuthUserListRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserListResponse.t and type make_t = AuthUserListResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userList : (module Runtime'.Spec.Message with type t = AuthUserListRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserListResponse.t)
    module UserDelete : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserDeleteRequest.t and type Response.t = AuthUserDeleteResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserDeleteRequest.t and type make_t = AuthUserDeleteRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserDeleteResponse.t and type make_t = AuthUserDeleteResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userDelete : (module Runtime'.Spec.Message with type t = AuthUserDeleteRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserDeleteResponse.t)
    module UserChangePassword : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserChangePasswordRequest.t and type Response.t = AuthUserChangePasswordResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserChangePasswordRequest.t and type make_t = AuthUserChangePasswordRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserChangePasswordResponse.t and type make_t = AuthUserChangePasswordResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userChangePassword : (module Runtime'.Spec.Message with type t = AuthUserChangePasswordRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserChangePasswordResponse.t)
    module UserGrantRole : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserGrantRoleRequest.t and type Response.t = AuthUserGrantRoleResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserGrantRoleRequest.t and type make_t = AuthUserGrantRoleRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserGrantRoleResponse.t and type make_t = AuthUserGrantRoleResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userGrantRole : (module Runtime'.Spec.Message with type t = AuthUserGrantRoleRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserGrantRoleResponse.t)
    module UserRevokeRole : sig
      include Runtime'.Service.Rpc with type Request.t = AuthUserRevokeRoleRequest.t and type Response.t = AuthUserRevokeRoleResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthUserRevokeRoleRequest.t and type make_t = AuthUserRevokeRoleRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthUserRevokeRoleResponse.t and type make_t = AuthUserRevokeRoleResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val userRevokeRole : (module Runtime'.Spec.Message with type t = AuthUserRevokeRoleRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserRevokeRoleResponse.t)
    module RoleAdd : sig
      include Runtime'.Service.Rpc with type Request.t = AuthRoleAddRequest.t and type Response.t = AuthRoleAddResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthRoleAddRequest.t and type make_t = AuthRoleAddRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthRoleAddResponse.t and type make_t = AuthRoleAddResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val roleAdd : (module Runtime'.Spec.Message with type t = AuthRoleAddRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleAddResponse.t)
    module RoleGet : sig
      include Runtime'.Service.Rpc with type Request.t = AuthRoleGetRequest.t and type Response.t = AuthRoleGetResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthRoleGetRequest.t and type make_t = AuthRoleGetRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthRoleGetResponse.t and type make_t = AuthRoleGetResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val roleGet : (module Runtime'.Spec.Message with type t = AuthRoleGetRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleGetResponse.t)
    module RoleList : sig
      include Runtime'.Service.Rpc with type Request.t = AuthRoleListRequest.t and type Response.t = AuthRoleListResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthRoleListRequest.t and type make_t = AuthRoleListRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthRoleListResponse.t and type make_t = AuthRoleListResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val roleList : (module Runtime'.Spec.Message with type t = AuthRoleListRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleListResponse.t)
    module RoleDelete : sig
      include Runtime'.Service.Rpc with type Request.t = AuthRoleDeleteRequest.t and type Response.t = AuthRoleDeleteResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthRoleDeleteRequest.t and type make_t = AuthRoleDeleteRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthRoleDeleteResponse.t and type make_t = AuthRoleDeleteResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val roleDelete : (module Runtime'.Spec.Message with type t = AuthRoleDeleteRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleDeleteResponse.t)
    module RoleGrantPermission : sig
      include Runtime'.Service.Rpc with type Request.t = AuthRoleGrantPermissionRequest.t and type Response.t = AuthRoleGrantPermissionResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthRoleGrantPermissionRequest.t and type make_t = AuthRoleGrantPermissionRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthRoleGrantPermissionResponse.t and type make_t = AuthRoleGrantPermissionResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val roleGrantPermission : (module Runtime'.Spec.Message with type t = AuthRoleGrantPermissionRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleGrantPermissionResponse.t)
    module RoleRevokePermission : sig
      include Runtime'.Service.Rpc with type Request.t = AuthRoleRevokePermissionRequest.t and type Response.t = AuthRoleRevokePermissionResponse.t
      module Request : Runtime'.Spec.Message with type t = AuthRoleRevokePermissionRequest.t and type make_t = AuthRoleRevokePermissionRequest.make_t
      (** Module alias for the request message for this method call *)

      module Response : Runtime'.Spec.Message with type t = AuthRoleRevokePermissionResponse.t and type make_t = AuthRoleRevokePermissionResponse.make_t
      (** Module alias for the response message for this method call *)

    end
    val roleRevokePermission : (module Runtime'.Spec.Message with type t = AuthRoleRevokePermissionRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleRevokePermissionResponse.t)
  end
end = struct
  module rec AlarmType : sig
    type t =
      | NONE
      (** default, used to query if any alarm is active *)
      | NOSPACE
      (** space quota is exhausted *)
      | CORRUPT
      (** kv store corruption detected *)
    [@@deriving show { with_path = false}]
    val name: unit -> string
    (** Fully qualified protobuf name of this enum *)

    (**/**)
    val to_int: t -> int
    val from_int: int -> t Runtime'.Result.t
    val from_int_exn: int -> t
    val to_string: t -> string
    val from_string_exn: string -> t
    (**/**)
  end = struct
    module This'_ = AlarmType
    type t =
      | NONE
      (** default, used to query if any alarm is active *)
      | NOSPACE
      (** space quota is exhausted *)
      | CORRUPT
      (** kv store corruption detected *)
    [@@deriving show { with_path = false}]
    let name () = ".etcdserverpb.AlarmType"
    let to_int = function
      | NONE -> 0
      | NOSPACE -> 1
      | CORRUPT -> 2
    let from_int_exn = function
      | 0 -> NONE
      | 1 -> NOSPACE
      | 2 -> CORRUPT
      | n -> Runtime'.Result.raise (`Unknown_enum_value n)
    let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
    let to_string = function
      | NONE -> "NONE"
      | NOSPACE -> "NOSPACE"
      | CORRUPT -> "CORRUPT"
    let from_string_exn = function
      | "NONE" -> NONE
      | "NOSPACE" -> NOSPACE
      | "CORRUPT" -> CORRUPT
      | s -> Runtime'.Result.raise (`Unknown_enum_name s)

  end
  and ResponseHeader : sig
    type t = {
    cluster_id: int;(** cluster_id is the ID of the cluster which sent the response. *)
    member_id: int;(** member_id is the ID of the member which sent the response. *)
    revision: int;(** revision is the key-value store revision when the request was applied.
    For watch progress responses, the header.revision indicates progress. All future events
    received in this stream are guaranteed to have a higher revision number than the
    header.revision number. *)
    raft_term: int;(** raft_term is the raft term when the request was applied. *)
    }[@@deriving show { with_path = false}]
    val make: ?cluster_id:int -> ?member_id:int -> ?revision:int -> ?raft_term:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?cluster_id:int -> ?member_id:int -> ?revision:int -> ?raft_term:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = ResponseHeader
    let name () = ".etcdserverpb.ResponseHeader"
    type t = {
    cluster_id: int;(** cluster_id is the ID of the cluster which sent the response. *)
    member_id: int;(** member_id is the ID of the member which sent the response. *)
    revision: int;(** revision is the key-value store revision when the request was applied.
    For watch progress responses, the header.revision indicates progress. All future events
    received in this stream are guaranteed to have a higher revision number than the
    header.revision number. *)
    raft_term: int;(** raft_term is the raft term when the request was applied. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?cluster_id:int -> ?member_id:int -> ?revision:int -> ?raft_term:int -> unit -> t
    let make ?(cluster_id = 0) ?(member_id = 0) ?(revision = 0) ?(raft_term = 0) () = { cluster_id; member_id; revision; raft_term }
    let merge =
    let merge_cluster_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "cluster_id", "clusterId"), uint64_int, (0)) ) in
    let merge_member_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "member_id", "memberId"), uint64_int, (0)) ) in
    let merge_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "revision", "revision"), int64_int, (0)) ) in
    let merge_raft_term = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "raft_term", "raftTerm"), uint64_int, (0)) ) in
    fun t1 t2 -> {
    cluster_id = (merge_cluster_id t1.cluster_id t2.cluster_id);
    member_id = (merge_member_id t1.member_id t2.member_id);
    revision = (merge_revision t1.revision t2.revision);
    raft_term = (merge_raft_term t1.raft_term t2.raft_term);
     }
    let spec () = Runtime'.Spec.( basic ((1, "cluster_id", "clusterId"), uint64_int, (0)) ^:: basic ((2, "member_id", "memberId"), uint64_int, (0)) ^:: basic ((3, "revision", "revision"), int64_int, (0)) ^:: basic ((4, "raft_term", "raftTerm"), uint64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { cluster_id; member_id; revision; raft_term } -> serialize writer cluster_id member_id revision raft_term

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor cluster_id member_id revision raft_term = { cluster_id; member_id; revision; raft_term } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { cluster_id; member_id; revision; raft_term } -> serialize cluster_id member_id revision raft_term
    let from_json_exn =
      let constructor cluster_id member_id revision raft_term = { cluster_id; member_id; revision; raft_term } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and RangeRequest : sig
    module rec SortOrder : sig
      type t =
        | NONE
        (** default, no sorting *)
        | ASCEND
        (** lowest target value first *)
        | DESCEND
        (** highest target value first *)
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    and SortTarget : sig
      type t =
        | KEY
        | VERSION
        | CREATE
        | MOD
        | VALUE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    key: bytes;(** key is the first key for the range. If range_end is not given, the request only looks up key. *)
    range_end: bytes;(** range_end is the upper bound on the requested range \[key, range_end).
    If range_end is '\\0', the range is all keys >= key.
    If range_end is key plus one (e.g., "aa"+1 == "ab", "a\\xff"+1 == "b"),
    then the range request gets all keys prefixed with key.
    If both key and range_end are '\\0', then the range request returns all keys. *)
    limit: int;(** limit is a limit on the number of keys returned for the request. When limit is set to 0,
    it is treated as no limit. *)
    revision: int;(** revision is the point-in-time of the key-value store to use for the range.
    If revision is less or equal to zero, the range is over the newest key-value store.
    If the revision has been compacted, ErrCompacted is returned as a response. *)
    sort_order: SortOrder.t;(** sort_order is the order for returned sorted results. *)
    sort_target: SortTarget.t;(** sort_target is the key-value field to use for sorting. *)
    serializable: bool;(** serializable sets the range request to use serializable member-local reads.
    Range requests are linearizable by default; linearizable requests have higher
    latency and lower throughput than serializable requests but reflect the current
    consensus of the cluster. For better performance, in exchange for possible stale reads,
    a serializable range request is served locally without needing to reach consensus
    with other nodes in the cluster. *)
    keys_only: bool;(** keys_only when set returns only the keys and not the values. *)
    count_only: bool;(** count_only when set returns only the count of the keys in the range. *)
    min_mod_revision: int;(** min_mod_revision is the lower bound for returned key mod revisions; all keys with
    lesser mod revisions will be filtered away. *)
    max_mod_revision: int;(** max_mod_revision is the upper bound for returned key mod revisions; all keys with
    greater mod revisions will be filtered away. *)
    min_create_revision: int;(** min_create_revision is the lower bound for returned key create revisions; all keys with
    lesser create revisions will be filtered away. *)
    max_create_revision: int;(** max_create_revision is the upper bound for returned key create revisions; all keys with
    greater create revisions will be filtered away. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?range_end:bytes -> ?limit:int -> ?revision:int -> ?sort_order:SortOrder.t -> ?sort_target:SortTarget.t -> ?serializable:bool -> ?keys_only:bool -> ?count_only:bool -> ?min_mod_revision:int -> ?max_mod_revision:int -> ?min_create_revision:int -> ?max_create_revision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?range_end:bytes -> ?limit:int -> ?revision:int -> ?sort_order:SortOrder.t -> ?sort_target:SortTarget.t -> ?serializable:bool -> ?keys_only:bool -> ?count_only:bool -> ?min_mod_revision:int -> ?max_mod_revision:int -> ?min_create_revision:int -> ?max_create_revision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = RangeRequest
    module rec SortOrder : sig
      type t =
        | NONE
        (** default, no sorting *)
        | ASCEND
        (** lowest target value first *)
        | DESCEND
        (** highest target value first *)
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = SortOrder
      type t =
        | NONE
        (** default, no sorting *)
        | ASCEND
        (** lowest target value first *)
        | DESCEND
        (** highest target value first *)
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.RangeRequest.SortOrder"
      let to_int = function
        | NONE -> 0
        | ASCEND -> 1
        | DESCEND -> 2
      let from_int_exn = function
        | 0 -> NONE
        | 1 -> ASCEND
        | 2 -> DESCEND
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | NONE -> "NONE"
        | ASCEND -> "ASCEND"
        | DESCEND -> "DESCEND"
      let from_string_exn = function
        | "NONE" -> NONE
        | "ASCEND" -> ASCEND
        | "DESCEND" -> DESCEND
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    and SortTarget : sig
      type t =
        | KEY
        | VERSION
        | CREATE
        | MOD
        | VALUE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = SortTarget
      type t =
        | KEY
        | VERSION
        | CREATE
        | MOD
        | VALUE
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.RangeRequest.SortTarget"
      let to_int = function
        | KEY -> 0
        | VERSION -> 1
        | CREATE -> 2
        | MOD -> 3
        | VALUE -> 4
      let from_int_exn = function
        | 0 -> KEY
        | 1 -> VERSION
        | 2 -> CREATE
        | 3 -> MOD
        | 4 -> VALUE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | KEY -> "KEY"
        | VERSION -> "VERSION"
        | CREATE -> "CREATE"
        | MOD -> "MOD"
        | VALUE -> "VALUE"
      let from_string_exn = function
        | "KEY" -> KEY
        | "VERSION" -> VERSION
        | "CREATE" -> CREATE
        | "MOD" -> MOD
        | "VALUE" -> VALUE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".etcdserverpb.RangeRequest"
    type t = {
    key: bytes;(** key is the first key for the range. If range_end is not given, the request only looks up key. *)
    range_end: bytes;(** range_end is the upper bound on the requested range \[key, range_end).
    If range_end is '\\0', the range is all keys >= key.
    If range_end is key plus one (e.g., "aa"+1 == "ab", "a\\xff"+1 == "b"),
    then the range request gets all keys prefixed with key.
    If both key and range_end are '\\0', then the range request returns all keys. *)
    limit: int;(** limit is a limit on the number of keys returned for the request. When limit is set to 0,
    it is treated as no limit. *)
    revision: int;(** revision is the point-in-time of the key-value store to use for the range.
    If revision is less or equal to zero, the range is over the newest key-value store.
    If the revision has been compacted, ErrCompacted is returned as a response. *)
    sort_order: SortOrder.t;(** sort_order is the order for returned sorted results. *)
    sort_target: SortTarget.t;(** sort_target is the key-value field to use for sorting. *)
    serializable: bool;(** serializable sets the range request to use serializable member-local reads.
    Range requests are linearizable by default; linearizable requests have higher
    latency and lower throughput than serializable requests but reflect the current
    consensus of the cluster. For better performance, in exchange for possible stale reads,
    a serializable range request is served locally without needing to reach consensus
    with other nodes in the cluster. *)
    keys_only: bool;(** keys_only when set returns only the keys and not the values. *)
    count_only: bool;(** count_only when set returns only the count of the keys in the range. *)
    min_mod_revision: int;(** min_mod_revision is the lower bound for returned key mod revisions; all keys with
    lesser mod revisions will be filtered away. *)
    max_mod_revision: int;(** max_mod_revision is the upper bound for returned key mod revisions; all keys with
    greater mod revisions will be filtered away. *)
    min_create_revision: int;(** min_create_revision is the lower bound for returned key create revisions; all keys with
    lesser create revisions will be filtered away. *)
    max_create_revision: int;(** max_create_revision is the upper bound for returned key create revisions; all keys with
    greater create revisions will be filtered away. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?key:bytes -> ?range_end:bytes -> ?limit:int -> ?revision:int -> ?sort_order:SortOrder.t -> ?sort_target:SortTarget.t -> ?serializable:bool -> ?keys_only:bool -> ?count_only:bool -> ?min_mod_revision:int -> ?max_mod_revision:int -> ?min_create_revision:int -> ?max_create_revision:int -> unit -> t
    let make ?(key = (Bytes.of_string {||})) ?(range_end = (Bytes.of_string {||})) ?(limit = 0) ?(revision = 0) ?(sort_order = SortOrder.from_int_exn 0) ?(sort_target = SortTarget.from_int_exn 0) ?(serializable = false) ?(keys_only = false) ?(count_only = false) ?(min_mod_revision = 0) ?(max_mod_revision = 0) ?(min_create_revision = 0) ?(max_create_revision = 0) () = { key; range_end; limit; revision; sort_order; sort_target; serializable; keys_only; count_only; min_mod_revision; max_mod_revision; min_create_revision; max_create_revision }
    let merge =
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_range_end = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_limit = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "limit", "limit"), int64_int, (0)) ) in
    let merge_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "revision", "revision"), int64_int, (0)) ) in
    let merge_sort_order = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "sort_order", "sortOrder"), (enum (module SortOrder)), (SortOrder.from_int_exn 0)) ) in
    let merge_sort_target = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "sort_target", "sortTarget"), (enum (module SortTarget)), (SortTarget.from_int_exn 0)) ) in
    let merge_serializable = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "serializable", "serializable"), bool, (false)) ) in
    let merge_keys_only = Runtime'.Merge.merge Runtime'.Spec.( basic ((8, "keys_only", "keysOnly"), bool, (false)) ) in
    let merge_count_only = Runtime'.Merge.merge Runtime'.Spec.( basic ((9, "count_only", "countOnly"), bool, (false)) ) in
    let merge_min_mod_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((10, "min_mod_revision", "minModRevision"), int64_int, (0)) ) in
    let merge_max_mod_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((11, "max_mod_revision", "maxModRevision"), int64_int, (0)) ) in
    let merge_min_create_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((12, "min_create_revision", "minCreateRevision"), int64_int, (0)) ) in
    let merge_max_create_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((13, "max_create_revision", "maxCreateRevision"), int64_int, (0)) ) in
    fun t1 t2 -> {
    key = (merge_key t1.key t2.key);
    range_end = (merge_range_end t1.range_end t2.range_end);
    limit = (merge_limit t1.limit t2.limit);
    revision = (merge_revision t1.revision t2.revision);
    sort_order = (merge_sort_order t1.sort_order t2.sort_order);
    sort_target = (merge_sort_target t1.sort_target t2.sort_target);
    serializable = (merge_serializable t1.serializable t2.serializable);
    keys_only = (merge_keys_only t1.keys_only t2.keys_only);
    count_only = (merge_count_only t1.count_only t2.count_only);
    min_mod_revision = (merge_min_mod_revision t1.min_mod_revision t2.min_mod_revision);
    max_mod_revision = (merge_max_mod_revision t1.max_mod_revision t2.max_mod_revision);
    min_create_revision = (merge_min_create_revision t1.min_create_revision t2.min_create_revision);
    max_create_revision = (merge_max_create_revision t1.max_create_revision t2.max_create_revision);
     }
    let spec () = Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((2, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ^:: basic ((3, "limit", "limit"), int64_int, (0)) ^:: basic ((4, "revision", "revision"), int64_int, (0)) ^:: basic ((5, "sort_order", "sortOrder"), (enum (module SortOrder)), (SortOrder.from_int_exn 0)) ^:: basic ((6, "sort_target", "sortTarget"), (enum (module SortTarget)), (SortTarget.from_int_exn 0)) ^:: basic ((7, "serializable", "serializable"), bool, (false)) ^:: basic ((8, "keys_only", "keysOnly"), bool, (false)) ^:: basic ((9, "count_only", "countOnly"), bool, (false)) ^:: basic ((10, "min_mod_revision", "minModRevision"), int64_int, (0)) ^:: basic ((11, "max_mod_revision", "maxModRevision"), int64_int, (0)) ^:: basic ((12, "min_create_revision", "minCreateRevision"), int64_int, (0)) ^:: basic ((13, "max_create_revision", "maxCreateRevision"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { key; range_end; limit; revision; sort_order; sort_target; serializable; keys_only; count_only; min_mod_revision; max_mod_revision; min_create_revision; max_create_revision } -> serialize writer key range_end limit revision sort_order sort_target serializable keys_only count_only min_mod_revision max_mod_revision min_create_revision max_create_revision

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor key range_end limit revision sort_order sort_target serializable keys_only count_only min_mod_revision max_mod_revision min_create_revision max_create_revision = { key; range_end; limit; revision; sort_order; sort_target; serializable; keys_only; count_only; min_mod_revision; max_mod_revision; min_create_revision; max_create_revision } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { key; range_end; limit; revision; sort_order; sort_target; serializable; keys_only; count_only; min_mod_revision; max_mod_revision; min_create_revision; max_create_revision } -> serialize key range_end limit revision sort_order sort_target serializable keys_only count_only min_mod_revision max_mod_revision min_create_revision max_create_revision
    let from_json_exn =
      let constructor key range_end limit revision sort_order sort_target serializable keys_only count_only min_mod_revision max_mod_revision min_create_revision max_create_revision = { key; range_end; limit; revision; sort_order; sort_target; serializable; keys_only; count_only; min_mod_revision; max_mod_revision; min_create_revision; max_create_revision } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and RangeResponse : sig
    type t = {
    header: ResponseHeader.t option;
    kvs: Imported'modules.Kv.Mvccpb.KeyValue.t list;(** kvs is the list of key-value pairs matched by the range request.
    kvs is empty when count is requested. *)
    more: bool;(** more indicates if there are more keys to return in the requested range. *)
    count: int;(** count is set to the number of keys within the range when requested. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> ?more:bool -> ?count:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> ?more:bool -> ?count:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = RangeResponse
    let name () = ".etcdserverpb.RangeResponse"
    type t = {
    header: ResponseHeader.t option;
    kvs: Imported'modules.Kv.Mvccpb.KeyValue.t list;(** kvs is the list of key-value pairs matched by the range request.
    kvs is empty when count is requested. *)
    more: bool;(** more indicates if there are more keys to return in the requested range. *)
    count: int;(** count is set to the number of keys within the range when requested. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> ?more:bool -> ?count:int -> unit -> t
    let make ?header ?(kvs = []) ?(more = false) ?(count = 0) () = { header; kvs; more; count }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_kvs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "kvs", "kvs"), (message (module Imported'modules.Kv.Mvccpb.KeyValue)), not_packed) ) in
    let merge_more = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "more", "more"), bool, (false)) ) in
    let merge_count = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "count", "count"), int64_int, (0)) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    kvs = (merge_kvs t1.kvs t2.kvs);
    more = (merge_more t1.more t2.more);
    count = (merge_count t1.count t2.count);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "kvs", "kvs"), (message (module Imported'modules.Kv.Mvccpb.KeyValue)), not_packed) ^:: basic ((3, "more", "more"), bool, (false)) ^:: basic ((4, "count", "count"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; kvs; more; count } -> serialize writer header kvs more count

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header kvs more count = { header; kvs; more; count } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; kvs; more; count } -> serialize header kvs more count
    let from_json_exn =
      let constructor header kvs more count = { header; kvs; more; count } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and PutRequest : sig
    type t = {
    key: bytes;(** key is the key, in bytes, to put into the key-value store. *)
    value: bytes;(** value is the value, in bytes, to associate with the key in the key-value store. *)
    lease: int;(** lease is the lease ID to associate with the key in the key-value store. A lease
    value of 0 indicates no lease. *)
    prev_kv: bool;(** If prev_kv is set, etcd gets the previous key-value pair before changing it.
    The previous key-value pair will be returned in the put response. *)
    ignore_value: bool;(** If ignore_value is set, etcd updates the key using its current value.
    Returns an error if the key does not exist. *)
    ignore_lease: bool;(** If ignore_lease is set, etcd updates the key using its current lease.
    Returns an error if the key does not exist. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?value:bytes -> ?lease:int -> ?prev_kv:bool -> ?ignore_value:bool -> ?ignore_lease:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?value:bytes -> ?lease:int -> ?prev_kv:bool -> ?ignore_value:bool -> ?ignore_lease:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = PutRequest
    let name () = ".etcdserverpb.PutRequest"
    type t = {
    key: bytes;(** key is the key, in bytes, to put into the key-value store. *)
    value: bytes;(** value is the value, in bytes, to associate with the key in the key-value store. *)
    lease: int;(** lease is the lease ID to associate with the key in the key-value store. A lease
    value of 0 indicates no lease. *)
    prev_kv: bool;(** If prev_kv is set, etcd gets the previous key-value pair before changing it.
    The previous key-value pair will be returned in the put response. *)
    ignore_value: bool;(** If ignore_value is set, etcd updates the key using its current value.
    Returns an error if the key does not exist. *)
    ignore_lease: bool;(** If ignore_lease is set, etcd updates the key using its current lease.
    Returns an error if the key does not exist. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?key:bytes -> ?value:bytes -> ?lease:int -> ?prev_kv:bool -> ?ignore_value:bool -> ?ignore_lease:bool -> unit -> t
    let make ?(key = (Bytes.of_string {||})) ?(value = (Bytes.of_string {||})) ?(lease = 0) ?(prev_kv = false) ?(ignore_value = false) ?(ignore_lease = false) () = { key; value; lease; prev_kv; ignore_value; ignore_lease }
    let merge =
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_value = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "value", "value"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_lease = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "lease", "lease"), int64_int, (0)) ) in
    let merge_prev_kv = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "prev_kv", "prevKv"), bool, (false)) ) in
    let merge_ignore_value = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "ignore_value", "ignoreValue"), bool, (false)) ) in
    let merge_ignore_lease = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "ignore_lease", "ignoreLease"), bool, (false)) ) in
    fun t1 t2 -> {
    key = (merge_key t1.key t2.key);
    value = (merge_value t1.value t2.value);
    lease = (merge_lease t1.lease t2.lease);
    prev_kv = (merge_prev_kv t1.prev_kv t2.prev_kv);
    ignore_value = (merge_ignore_value t1.ignore_value t2.ignore_value);
    ignore_lease = (merge_ignore_lease t1.ignore_lease t2.ignore_lease);
     }
    let spec () = Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((2, "value", "value"), bytes, ((Bytes.of_string {||}))) ^:: basic ((3, "lease", "lease"), int64_int, (0)) ^:: basic ((4, "prev_kv", "prevKv"), bool, (false)) ^:: basic ((5, "ignore_value", "ignoreValue"), bool, (false)) ^:: basic ((6, "ignore_lease", "ignoreLease"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { key; value; lease; prev_kv; ignore_value; ignore_lease } -> serialize writer key value lease prev_kv ignore_value ignore_lease

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor key value lease prev_kv ignore_value ignore_lease = { key; value; lease; prev_kv; ignore_value; ignore_lease } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { key; value; lease; prev_kv; ignore_value; ignore_lease } -> serialize key value lease prev_kv ignore_value ignore_lease
    let from_json_exn =
      let constructor key value lease prev_kv ignore_value ignore_lease = { key; value; lease; prev_kv; ignore_value; ignore_lease } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and PutResponse : sig
    type t = {
    header: ResponseHeader.t option;
    prev_kv: Imported'modules.Kv.Mvccpb.KeyValue.t option;(** if prev_kv is set in the request, the previous key-value pair will be returned. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?prev_kv:Imported'modules.Kv.Mvccpb.KeyValue.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?prev_kv:Imported'modules.Kv.Mvccpb.KeyValue.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = PutResponse
    let name () = ".etcdserverpb.PutResponse"
    type t = {
    header: ResponseHeader.t option;
    prev_kv: Imported'modules.Kv.Mvccpb.KeyValue.t option;(** if prev_kv is set in the request, the previous key-value pair will be returned. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?prev_kv:Imported'modules.Kv.Mvccpb.KeyValue.t -> unit -> t
    let make ?header ?prev_kv () = { header; prev_kv }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_prev_kv = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "prev_kv", "prevKv"), (message (module Imported'modules.Kv.Mvccpb.KeyValue))) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    prev_kv = (merge_prev_kv t1.prev_kv t2.prev_kv);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic_opt ((2, "prev_kv", "prevKv"), (message (module Imported'modules.Kv.Mvccpb.KeyValue))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; prev_kv } -> serialize writer header prev_kv

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header prev_kv = { header; prev_kv } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; prev_kv } -> serialize header prev_kv
    let from_json_exn =
      let constructor header prev_kv = { header; prev_kv } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and DeleteRangeRequest : sig
    type t = {
    key: bytes;(** key is the first key to delete in the range. *)
    range_end: bytes;(** range_end is the key following the last key to delete for the range \[key, range_end).
    If range_end is not given, the range is defined to contain only the key argument.
    If range_end is one bit larger than the given key, then the range is all the keys
    with the prefix (the given key).
    If range_end is '\\0', the range is all keys greater than or equal to the key argument. *)
    prev_kv: bool;(** If prev_kv is set, etcd gets the previous key-value pairs before deleting it.
    The previous key-value pairs will be returned in the delete response. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?range_end:bytes -> ?prev_kv:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?range_end:bytes -> ?prev_kv:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = DeleteRangeRequest
    let name () = ".etcdserverpb.DeleteRangeRequest"
    type t = {
    key: bytes;(** key is the first key to delete in the range. *)
    range_end: bytes;(** range_end is the key following the last key to delete for the range \[key, range_end).
    If range_end is not given, the range is defined to contain only the key argument.
    If range_end is one bit larger than the given key, then the range is all the keys
    with the prefix (the given key).
    If range_end is '\\0', the range is all keys greater than or equal to the key argument. *)
    prev_kv: bool;(** If prev_kv is set, etcd gets the previous key-value pairs before deleting it.
    The previous key-value pairs will be returned in the delete response. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?key:bytes -> ?range_end:bytes -> ?prev_kv:bool -> unit -> t
    let make ?(key = (Bytes.of_string {||})) ?(range_end = (Bytes.of_string {||})) ?(prev_kv = false) () = { key; range_end; prev_kv }
    let merge =
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_range_end = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_prev_kv = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "prev_kv", "prevKv"), bool, (false)) ) in
    fun t1 t2 -> {
    key = (merge_key t1.key t2.key);
    range_end = (merge_range_end t1.range_end t2.range_end);
    prev_kv = (merge_prev_kv t1.prev_kv t2.prev_kv);
     }
    let spec () = Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((2, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ^:: basic ((3, "prev_kv", "prevKv"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { key; range_end; prev_kv } -> serialize writer key range_end prev_kv

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor key range_end prev_kv = { key; range_end; prev_kv } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { key; range_end; prev_kv } -> serialize key range_end prev_kv
    let from_json_exn =
      let constructor key range_end prev_kv = { key; range_end; prev_kv } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and DeleteRangeResponse : sig
    type t = {
    header: ResponseHeader.t option;
    deleted: int;(** deleted is the number of keys deleted by the delete range request. *)
    prev_kvs: Imported'modules.Kv.Mvccpb.KeyValue.t list;(** if prev_kv is set in the request, the previous key-value pairs will be returned. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?deleted:int -> ?prev_kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?deleted:int -> ?prev_kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = DeleteRangeResponse
    let name () = ".etcdserverpb.DeleteRangeResponse"
    type t = {
    header: ResponseHeader.t option;
    deleted: int;(** deleted is the number of keys deleted by the delete range request. *)
    prev_kvs: Imported'modules.Kv.Mvccpb.KeyValue.t list;(** if prev_kv is set in the request, the previous key-value pairs will be returned. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?deleted:int -> ?prev_kvs:Imported'modules.Kv.Mvccpb.KeyValue.t list -> unit -> t
    let make ?header ?(deleted = 0) ?(prev_kvs = []) () = { header; deleted; prev_kvs }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_deleted = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "deleted", "deleted"), int64_int, (0)) ) in
    let merge_prev_kvs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "prev_kvs", "prevKvs"), (message (module Imported'modules.Kv.Mvccpb.KeyValue)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    deleted = (merge_deleted t1.deleted t2.deleted);
    prev_kvs = (merge_prev_kvs t1.prev_kvs t2.prev_kvs);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "deleted", "deleted"), int64_int, (0)) ^:: repeated ((3, "prev_kvs", "prevKvs"), (message (module Imported'modules.Kv.Mvccpb.KeyValue)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; deleted; prev_kvs } -> serialize writer header deleted prev_kvs

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header deleted prev_kvs = { header; deleted; prev_kvs } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; deleted; prev_kvs } -> serialize header deleted prev_kvs
    let from_json_exn =
      let constructor header deleted prev_kvs = { header; deleted; prev_kvs } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and RequestOp : sig
    type t = ([ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ])[@@deriving show { with_path = false}]
    val make: ?request:[ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ] -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?request:[ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ] -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = RequestOp
    let name () = ".etcdserverpb.RequestOp"
    type t = ([ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ])[@@deriving show { with_path = false}]
    type make_t = ?request:[ `not_set | `Request_range of RangeRequest.t | `Request_put of PutRequest.t | `Request_delete_range of DeleteRangeRequest.t | `Request_txn of TxnRequest.t ] -> unit -> t
    let make ?(request = `not_set) () = (request)
    let merge =
    let merge_oneof_request__Request_range = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module RangeRequest))) ) in
    let merge_oneof_request__Request_put = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module PutRequest))) ) in
    let merge_oneof_request__Request_delete_range = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module DeleteRangeRequest))) ) in
    let merge_oneof_request__Request_txn = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module TxnRequest))) ) in
    fun (t1_request) (t2_request) -> match (t1_request, t2_request) with
    | (`Request_range v1, `Request_range v2) -> `Request_range (merge_oneof_request__Request_range v1 v2)
    | (`Request_put v1, `Request_put v2) -> `Request_put (merge_oneof_request__Request_put v1 v2)
    | (`Request_delete_range v1, `Request_delete_range v2) -> `Request_delete_range (merge_oneof_request__Request_delete_range v1 v2)
    | (`Request_txn v1, `Request_txn v2) -> `Request_txn (merge_oneof_request__Request_txn v1 v2)
    | (v1, `not_set) -> v1
    | (_, v2) -> v2
    let spec () = Runtime'.Spec.( oneof (([ oneof_elem ((1, "request_range", "requestRange"), (message (module RangeRequest)), ((fun v -> `Request_range v), (function `Request_range v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((2, "request_put", "requestPut"), (message (module PutRequest)), ((fun v -> `Request_put v), (function `Request_put v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((3, "request_delete_range", "requestDeleteRange"), (message (module DeleteRangeRequest)), ((fun v -> `Request_delete_range v), (function `Request_delete_range v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((4, "request_txn", "requestTxn"), (message (module TxnRequest)), ((fun v -> `Request_txn v), (function `Request_txn v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `Request_range _ -> 0 | `Request_put _ -> 1 | `Request_delete_range _ -> 2 | `Request_txn _ -> 3))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (request) -> serialize writer request

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor request = (request) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (request) -> serialize request
    let from_json_exn =
      let constructor request = (request) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and ResponseOp : sig
    type t = ([ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ])[@@deriving show { with_path = false}]
    val make: ?response:[ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ] -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?response:[ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ] -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = ResponseOp
    let name () = ".etcdserverpb.ResponseOp"
    type t = ([ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ])[@@deriving show { with_path = false}]
    type make_t = ?response:[ `not_set | `Response_range of RangeResponse.t | `Response_put of PutResponse.t | `Response_delete_range of DeleteRangeResponse.t | `Response_txn of TxnResponse.t ] -> unit -> t
    let make ?(response = `not_set) () = (response)
    let merge =
    let merge_oneof_response__Response_range = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module RangeResponse))) ) in
    let merge_oneof_response__Response_put = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module PutResponse))) ) in
    let merge_oneof_response__Response_delete_range = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module DeleteRangeResponse))) ) in
    let merge_oneof_response__Response_txn = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module TxnResponse))) ) in
    fun (t1_response) (t2_response) -> match (t1_response, t2_response) with
    | (`Response_range v1, `Response_range v2) -> `Response_range (merge_oneof_response__Response_range v1 v2)
    | (`Response_put v1, `Response_put v2) -> `Response_put (merge_oneof_response__Response_put v1 v2)
    | (`Response_delete_range v1, `Response_delete_range v2) -> `Response_delete_range (merge_oneof_response__Response_delete_range v1 v2)
    | (`Response_txn v1, `Response_txn v2) -> `Response_txn (merge_oneof_response__Response_txn v1 v2)
    | (v1, `not_set) -> v1
    | (_, v2) -> v2
    let spec () = Runtime'.Spec.( oneof (([ oneof_elem ((1, "response_range", "responseRange"), (message (module RangeResponse)), ((fun v -> `Response_range v), (function `Response_range v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((2, "response_put", "responsePut"), (message (module PutResponse)), ((fun v -> `Response_put v), (function `Response_put v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((3, "response_delete_range", "responseDeleteRange"), (message (module DeleteRangeResponse)), ((fun v -> `Response_delete_range v), (function `Response_delete_range v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((4, "response_txn", "responseTxn"), (message (module TxnResponse)), ((fun v -> `Response_txn v), (function `Response_txn v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `Response_range _ -> 0 | `Response_put _ -> 1 | `Response_delete_range _ -> 2 | `Response_txn _ -> 3))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (response) -> serialize writer response

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor response = (response) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (response) -> serialize response
    let from_json_exn =
      let constructor response = (response) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and Compare : sig
    module rec CompareResult : sig
      type t =
        | EQUAL
        | GREATER
        | LESS
        | NOT_EQUAL
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    and CompareTarget : sig
      type t =
        | VERSION
        | CREATE
        | MOD
        | VALUE
        | LEASE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    result: CompareResult.t;(** result is logical comparison operation for this comparison. *)
    target: CompareTarget.t;(** target is the key-value field to inspect for the comparison. *)
    key: bytes;(** key is the subject key for the comparison operation. *)
    target_union: [ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ];
    range_end: bytes;(** range_end compares the given target to all keys in the range \[key, range_end).
    See RangeRequest for more details on key ranges.


    TODO: fill out with most of the rest of RangeRequest fields when needed. *)
    }[@@deriving show { with_path = false}]
    val make: ?result:CompareResult.t -> ?target:CompareTarget.t -> ?key:bytes -> ?target_union:[ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ] -> ?range_end:bytes -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?result:CompareResult.t -> ?target:CompareTarget.t -> ?key:bytes -> ?target_union:[ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ] -> ?range_end:bytes -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = Compare
    module rec CompareResult : sig
      type t =
        | EQUAL
        | GREATER
        | LESS
        | NOT_EQUAL
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = CompareResult
      type t =
        | EQUAL
        | GREATER
        | LESS
        | NOT_EQUAL
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.Compare.CompareResult"
      let to_int = function
        | EQUAL -> 0
        | GREATER -> 1
        | LESS -> 2
        | NOT_EQUAL -> 3
      let from_int_exn = function
        | 0 -> EQUAL
        | 1 -> GREATER
        | 2 -> LESS
        | 3 -> NOT_EQUAL
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | EQUAL -> "EQUAL"
        | GREATER -> "GREATER"
        | LESS -> "LESS"
        | NOT_EQUAL -> "NOT_EQUAL"
      let from_string_exn = function
        | "EQUAL" -> EQUAL
        | "GREATER" -> GREATER
        | "LESS" -> LESS
        | "NOT_EQUAL" -> NOT_EQUAL
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    and CompareTarget : sig
      type t =
        | VERSION
        | CREATE
        | MOD
        | VALUE
        | LEASE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = CompareTarget
      type t =
        | VERSION
        | CREATE
        | MOD
        | VALUE
        | LEASE
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.Compare.CompareTarget"
      let to_int = function
        | VERSION -> 0
        | CREATE -> 1
        | MOD -> 2
        | VALUE -> 3
        | LEASE -> 4
      let from_int_exn = function
        | 0 -> VERSION
        | 1 -> CREATE
        | 2 -> MOD
        | 3 -> VALUE
        | 4 -> LEASE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | VERSION -> "VERSION"
        | CREATE -> "CREATE"
        | MOD -> "MOD"
        | VALUE -> "VALUE"
        | LEASE -> "LEASE"
      let from_string_exn = function
        | "VERSION" -> VERSION
        | "CREATE" -> CREATE
        | "MOD" -> MOD
        | "VALUE" -> VALUE
        | "LEASE" -> LEASE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".etcdserverpb.Compare"
    type t = {
    result: CompareResult.t;(** result is logical comparison operation for this comparison. *)
    target: CompareTarget.t;(** target is the key-value field to inspect for the comparison. *)
    key: bytes;(** key is the subject key for the comparison operation. *)
    target_union: [ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ];
    range_end: bytes;(** range_end compares the given target to all keys in the range \[key, range_end).
    See RangeRequest for more details on key ranges.


    TODO: fill out with most of the rest of RangeRequest fields when needed. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?result:CompareResult.t -> ?target:CompareTarget.t -> ?key:bytes -> ?target_union:[ `not_set | `Version of int | `Create_revision of int | `Mod_revision of int | `Value of bytes | `Lease of int ] -> ?range_end:bytes -> unit -> t
    let make ?(result = CompareResult.from_int_exn 0) ?(target = CompareTarget.from_int_exn 0) ?(key = (Bytes.of_string {||})) ?(target_union = `not_set) ?(range_end = (Bytes.of_string {||})) () = { result; target; key; target_union; range_end }
    let merge =
    let merge_result = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "result", "result"), (enum (module CompareResult)), (CompareResult.from_int_exn 0)) ) in
    let merge_target = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "target", "target"), (enum (module CompareTarget)), (CompareTarget.from_int_exn 0)) ) in
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_oneof_target_union__Version = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), int64_int) ) in
    let merge_oneof_target_union__Create_revision = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), int64_int) ) in
    let merge_oneof_target_union__Mod_revision = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), int64_int) ) in
    let merge_oneof_target_union__Value = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), bytes) ) in
    let merge_oneof_target_union__Lease = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), int64_int) ) in
    let merge_range_end = Runtime'.Merge.merge Runtime'.Spec.( basic ((64, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ) in
    fun t1 t2 -> {
    result = (merge_result t1.result t2.result);
    target = (merge_target t1.target t2.target);
    key = (merge_key t1.key t2.key);
    target_union = (match (t1.target_union, t2.target_union) with
    | (`Version v1, `Version v2) -> `Version (merge_oneof_target_union__Version v1 v2)
    | (`Create_revision v1, `Create_revision v2) -> `Create_revision (merge_oneof_target_union__Create_revision v1 v2)
    | (`Mod_revision v1, `Mod_revision v2) -> `Mod_revision (merge_oneof_target_union__Mod_revision v1 v2)
    | (`Value v1, `Value v2) -> `Value (merge_oneof_target_union__Value v1 v2)
    | (`Lease v1, `Lease v2) -> `Lease (merge_oneof_target_union__Lease v1 v2)
    | (v1, `not_set) -> v1
    | (_, v2) -> v2);
    range_end = (merge_range_end t1.range_end t2.range_end);
     }
    let spec () = Runtime'.Spec.( basic ((1, "result", "result"), (enum (module CompareResult)), (CompareResult.from_int_exn 0)) ^:: basic ((2, "target", "target"), (enum (module CompareTarget)), (CompareTarget.from_int_exn 0)) ^:: basic ((3, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: oneof (([ oneof_elem ((4, "version", "version"), int64_int, ((fun v -> `Version v), (function `Version v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((5, "create_revision", "createRevision"), int64_int, ((fun v -> `Create_revision v), (function `Create_revision v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((6, "mod_revision", "modRevision"), int64_int, ((fun v -> `Mod_revision v), (function `Mod_revision v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((7, "value", "value"), bytes, ((fun v -> `Value v), (function `Value v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((8, "lease", "lease"), int64_int, ((fun v -> `Lease v), (function `Lease v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `Version _ -> 0 | `Create_revision _ -> 1 | `Mod_revision _ -> 2 | `Value _ -> 3 | `Lease _ -> 4))) ^:: basic ((64, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { result; target; key; target_union; range_end } -> serialize writer result target key target_union range_end

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor result target key target_union range_end = { result; target; key; target_union; range_end } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { result; target; key; target_union; range_end } -> serialize result target key target_union range_end
    let from_json_exn =
      let constructor result target key target_union range_end = { result; target; key; target_union; range_end } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and TxnRequest : sig
    type t = {
    compare: Compare.t list;(** compare is a list of predicates representing a conjunction of terms.
    If the comparisons succeed, then the success requests will be processed in order,
    and the response will contain their respective responses in order.
    If the comparisons fail, then the failure requests will be processed in order,
    and the response will contain their respective responses in order. *)
    success: RequestOp.t list;(** success is a list of requests which will be applied when compare evaluates to true. *)
    failure: RequestOp.t list;(** failure is a list of requests which will be applied when compare evaluates to false. *)
    }[@@deriving show { with_path = false}]
    val make: ?compare:Compare.t list -> ?success:RequestOp.t list -> ?failure:RequestOp.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?compare:Compare.t list -> ?success:RequestOp.t list -> ?failure:RequestOp.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = TxnRequest
    let name () = ".etcdserverpb.TxnRequest"
    type t = {
    compare: Compare.t list;(** compare is a list of predicates representing a conjunction of terms.
    If the comparisons succeed, then the success requests will be processed in order,
    and the response will contain their respective responses in order.
    If the comparisons fail, then the failure requests will be processed in order,
    and the response will contain their respective responses in order. *)
    success: RequestOp.t list;(** success is a list of requests which will be applied when compare evaluates to true. *)
    failure: RequestOp.t list;(** failure is a list of requests which will be applied when compare evaluates to false. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?compare:Compare.t list -> ?success:RequestOp.t list -> ?failure:RequestOp.t list -> unit -> t
    let make ?(compare = []) ?(success = []) ?(failure = []) () = { compare; success; failure }
    let merge =
    let merge_compare = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "compare", "compare"), (message (module Compare)), not_packed) ) in
    let merge_success = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "success", "success"), (message (module RequestOp)), not_packed) ) in
    let merge_failure = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "failure", "failure"), (message (module RequestOp)), not_packed) ) in
    fun t1 t2 -> {
    compare = (merge_compare t1.compare t2.compare);
    success = (merge_success t1.success t2.success);
    failure = (merge_failure t1.failure t2.failure);
     }
    let spec () = Runtime'.Spec.( repeated ((1, "compare", "compare"), (message (module Compare)), not_packed) ^:: repeated ((2, "success", "success"), (message (module RequestOp)), not_packed) ^:: repeated ((3, "failure", "failure"), (message (module RequestOp)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { compare; success; failure } -> serialize writer compare success failure

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor compare success failure = { compare; success; failure } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { compare; success; failure } -> serialize compare success failure
    let from_json_exn =
      let constructor compare success failure = { compare; success; failure } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and TxnResponse : sig
    type t = {
    header: ResponseHeader.t option;
    succeeded: bool;(** succeeded is set to true if the compare evaluated to true or false otherwise. *)
    responses: ResponseOp.t list;(** responses is a list of responses corresponding to the results from applying
    success if succeeded is true or failure if succeeded is false. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?succeeded:bool -> ?responses:ResponseOp.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?succeeded:bool -> ?responses:ResponseOp.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = TxnResponse
    let name () = ".etcdserverpb.TxnResponse"
    type t = {
    header: ResponseHeader.t option;
    succeeded: bool;(** succeeded is set to true if the compare evaluated to true or false otherwise. *)
    responses: ResponseOp.t list;(** responses is a list of responses corresponding to the results from applying
    success if succeeded is true or failure if succeeded is false. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?succeeded:bool -> ?responses:ResponseOp.t list -> unit -> t
    let make ?header ?(succeeded = false) ?(responses = []) () = { header; succeeded; responses }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_succeeded = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "succeeded", "succeeded"), bool, (false)) ) in
    let merge_responses = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "responses", "responses"), (message (module ResponseOp)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    succeeded = (merge_succeeded t1.succeeded t2.succeeded);
    responses = (merge_responses t1.responses t2.responses);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "succeeded", "succeeded"), bool, (false)) ^:: repeated ((3, "responses", "responses"), (message (module ResponseOp)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; succeeded; responses } -> serialize writer header succeeded responses

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header succeeded responses = { header; succeeded; responses } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; succeeded; responses } -> serialize header succeeded responses
    let from_json_exn =
      let constructor header succeeded responses = { header; succeeded; responses } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and CompactionRequest : sig
    type t = {
    revision: int;(** revision is the key-value store revision for the compaction operation. *)
    physical: bool;(** physical is set so the RPC will wait until the compaction is physically
    applied to the local database such that compacted entries are totally
    removed from the backend database. *)
    }[@@deriving show { with_path = false}]
    val make: ?revision:int -> ?physical:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?revision:int -> ?physical:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = CompactionRequest
    let name () = ".etcdserverpb.CompactionRequest"
    type t = {
    revision: int;(** revision is the key-value store revision for the compaction operation. *)
    physical: bool;(** physical is set so the RPC will wait until the compaction is physically
    applied to the local database such that compacted entries are totally
    removed from the backend database. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?revision:int -> ?physical:bool -> unit -> t
    let make ?(revision = 0) ?(physical = false) () = { revision; physical }
    let merge =
    let merge_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "revision", "revision"), int64_int, (0)) ) in
    let merge_physical = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "physical", "physical"), bool, (false)) ) in
    fun t1 t2 -> {
    revision = (merge_revision t1.revision t2.revision);
    physical = (merge_physical t1.physical t2.physical);
     }
    let spec () = Runtime'.Spec.( basic ((1, "revision", "revision"), int64_int, (0)) ^:: basic ((2, "physical", "physical"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { revision; physical } -> serialize writer revision physical

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor revision physical = { revision; physical } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { revision; physical } -> serialize revision physical
    let from_json_exn =
      let constructor revision physical = { revision; physical } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and CompactionResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = CompactionResponse
    let name () = ".etcdserverpb.CompactionResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and HashRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = HashRequest
    let name () = ".etcdserverpb.HashRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and HashKVRequest : sig
    type t = (int)
    (**
    revision is the key-value store revision for the hash operation.
    *)
    [@@deriving show { with_path = false}]
    val make: ?revision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?revision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = HashKVRequest
    let name () = ".etcdserverpb.HashKVRequest"
    type t = (int)
    (**
    revision is the key-value store revision for the hash operation.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?revision:int -> unit -> t
    let make ?(revision = 0) () = (revision)
    let merge =
    let merge_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "revision", "revision"), int64_int, (0)) ) in
    fun (t1_revision) (t2_revision) -> merge_revision t1_revision t2_revision
    let spec () = Runtime'.Spec.( basic ((1, "revision", "revision"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (revision) -> serialize writer revision

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor revision = (revision) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (revision) -> serialize revision
    let from_json_exn =
      let constructor revision = (revision) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and HashKVResponse : sig
    type t = {
    header: ResponseHeader.t option;
    hash: int;(** hash is the hash value computed from the responding member's MVCC keys up to a given revision. *)
    compact_revision: int;(** compact_revision is the compacted revision of key-value store when hash begins. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?hash:int -> ?compact_revision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?hash:int -> ?compact_revision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = HashKVResponse
    let name () = ".etcdserverpb.HashKVResponse"
    type t = {
    header: ResponseHeader.t option;
    hash: int;(** hash is the hash value computed from the responding member's MVCC keys up to a given revision. *)
    compact_revision: int;(** compact_revision is the compacted revision of key-value store when hash begins. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?hash:int -> ?compact_revision:int -> unit -> t
    let make ?header ?(hash = 0) ?(compact_revision = 0) () = { header; hash; compact_revision }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_hash = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "hash", "hash"), uint32_int, (0)) ) in
    let merge_compact_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "compact_revision", "compactRevision"), int64_int, (0)) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    hash = (merge_hash t1.hash t2.hash);
    compact_revision = (merge_compact_revision t1.compact_revision t2.compact_revision);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "hash", "hash"), uint32_int, (0)) ^:: basic ((3, "compact_revision", "compactRevision"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; hash; compact_revision } -> serialize writer header hash compact_revision

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header hash compact_revision = { header; hash; compact_revision } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; hash; compact_revision } -> serialize header hash compact_revision
    let from_json_exn =
      let constructor header hash compact_revision = { header; hash; compact_revision } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and HashResponse : sig
    type t = {
    header: ResponseHeader.t option;
    hash: int;(** hash is the hash value computed from the responding member's KV's backend. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?hash:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?hash:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = HashResponse
    let name () = ".etcdserverpb.HashResponse"
    type t = {
    header: ResponseHeader.t option;
    hash: int;(** hash is the hash value computed from the responding member's KV's backend. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?hash:int -> unit -> t
    let make ?header ?(hash = 0) () = { header; hash }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_hash = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "hash", "hash"), uint32_int, (0)) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    hash = (merge_hash t1.hash t2.hash);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "hash", "hash"), uint32_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; hash } -> serialize writer header hash

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header hash = { header; hash } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; hash } -> serialize header hash
    let from_json_exn =
      let constructor header hash = { header; hash } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and SnapshotRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = SnapshotRequest
    let name () = ".etcdserverpb.SnapshotRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and SnapshotResponse : sig
    type t = {
    header: ResponseHeader.t option;(** header has the current key-value store information. The first header in the snapshot
    stream indicates the point in time of the snapshot. *)
    remaining_bytes: int;(** remaining_bytes is the number of blob bytes to be sent after this message *)
    blob: bytes;(** blob contains the next chunk of the snapshot in the snapshot stream. *)
    version: string;(** local version of server that created the snapshot.
    In cluster with binaries with different version, each cluster can return different result.
    Informs which etcd server version should be used when restoring the snapshot. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?remaining_bytes:int -> ?blob:bytes -> ?version:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?remaining_bytes:int -> ?blob:bytes -> ?version:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = SnapshotResponse
    let name () = ".etcdserverpb.SnapshotResponse"
    type t = {
    header: ResponseHeader.t option;(** header has the current key-value store information. The first header in the snapshot
    stream indicates the point in time of the snapshot. *)
    remaining_bytes: int;(** remaining_bytes is the number of blob bytes to be sent after this message *)
    blob: bytes;(** blob contains the next chunk of the snapshot in the snapshot stream. *)
    version: string;(** local version of server that created the snapshot.
    In cluster with binaries with different version, each cluster can return different result.
    Informs which etcd server version should be used when restoring the snapshot. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?remaining_bytes:int -> ?blob:bytes -> ?version:string -> unit -> t
    let make ?header ?(remaining_bytes = 0) ?(blob = (Bytes.of_string {||})) ?(version = {||}) () = { header; remaining_bytes; blob; version }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_remaining_bytes = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "remaining_bytes", "remainingBytes"), uint64_int, (0)) ) in
    let merge_blob = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "blob", "blob"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_version = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "version", "version"), string, ({||})) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    remaining_bytes = (merge_remaining_bytes t1.remaining_bytes t2.remaining_bytes);
    blob = (merge_blob t1.blob t2.blob);
    version = (merge_version t1.version t2.version);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "remaining_bytes", "remainingBytes"), uint64_int, (0)) ^:: basic ((3, "blob", "blob"), bytes, ((Bytes.of_string {||}))) ^:: basic ((4, "version", "version"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; remaining_bytes; blob; version } -> serialize writer header remaining_bytes blob version

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header remaining_bytes blob version = { header; remaining_bytes; blob; version } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; remaining_bytes; blob; version } -> serialize header remaining_bytes blob version
    let from_json_exn =
      let constructor header remaining_bytes blob version = { header; remaining_bytes; blob; version } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and WatchRequest : sig
    type t = ([ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ])[@@deriving show { with_path = false}]
    val make: ?request_union:[ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ] -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?request_union:[ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ] -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = WatchRequest
    let name () = ".etcdserverpb.WatchRequest"
    type t = ([ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ])[@@deriving show { with_path = false}]
    type make_t = ?request_union:[ `not_set | `Create_request of WatchCreateRequest.t | `Cancel_request of WatchCancelRequest.t | `Progress_request of WatchProgressRequest.t ] -> unit -> t
    let make ?(request_union = `not_set) () = (request_union)
    let merge =
    let merge_oneof_request_union__Create_request = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module WatchCreateRequest))) ) in
    let merge_oneof_request_union__Cancel_request = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module WatchCancelRequest))) ) in
    let merge_oneof_request_union__Progress_request = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module WatchProgressRequest))) ) in
    fun (t1_request_union) (t2_request_union) -> match (t1_request_union, t2_request_union) with
    | (`Create_request v1, `Create_request v2) -> `Create_request (merge_oneof_request_union__Create_request v1 v2)
    | (`Cancel_request v1, `Cancel_request v2) -> `Cancel_request (merge_oneof_request_union__Cancel_request v1 v2)
    | (`Progress_request v1, `Progress_request v2) -> `Progress_request (merge_oneof_request_union__Progress_request v1 v2)
    | (v1, `not_set) -> v1
    | (_, v2) -> v2
    let spec () = Runtime'.Spec.( oneof (([ oneof_elem ((1, "create_request", "createRequest"), (message (module WatchCreateRequest)), ((fun v -> `Create_request v), (function `Create_request v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((2, "cancel_request", "cancelRequest"), (message (module WatchCancelRequest)), ((fun v -> `Cancel_request v), (function `Cancel_request v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((3, "progress_request", "progressRequest"), (message (module WatchProgressRequest)), ((fun v -> `Progress_request v), (function `Progress_request v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `Create_request _ -> 0 | `Cancel_request _ -> 1 | `Progress_request _ -> 2))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (request_union) -> serialize writer request_union

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor request_union = (request_union) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (request_union) -> serialize request_union
    let from_json_exn =
      let constructor request_union = (request_union) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and WatchCreateRequest : sig
    module rec FilterType : sig
      type t =
        | NOPUT
        (** filter out put event. *)
        | NODELETE
        (** filter out delete event. *)
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    key: bytes;(** key is the key to register for watching. *)
    range_end: bytes;(** range_end is the end of the range \[key, range_end) to watch. If range_end is not given,
    only the key argument is watched. If range_end is equal to '\\0', all keys greater than
    or equal to the key argument are watched.
    If the range_end is one bit larger than the given key,
    then all keys with the prefix (the given key) will be watched. *)
    start_revision: int;(** start_revision is an optional revision to watch from (inclusive). No start_revision is "now". *)
    progress_notify: bool;(** progress_notify is set so that the etcd server will periodically send a WatchResponse with
    no events to the new watcher if there are no recent events. It is useful when clients
    wish to recover a disconnected watcher starting from a recent known revision.
    The etcd server may decide how often it will send notifications based on current load. *)
    filters: FilterType.t list;(** filters filter the events at server side before it sends back to the watcher. *)
    prev_kv: bool;(** If prev_kv is set, created watcher gets the previous KV before the event happens.
    If the previous KV is already compacted, nothing will be returned. *)
    watch_id: int;(** If watch_id is provided and non-zero, it will be assigned to this watcher.
    Since creating a watcher in etcd is not a synchronous operation,
    this can be used ensure that ordering is correct when creating multiple
    watchers on the same stream. Creating a watcher with an ID already in
    use on the stream will cause an error to be returned. *)
    fragment: bool;(** fragment enables splitting large revisions into multiple watch responses. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?range_end:bytes -> ?start_revision:int -> ?progress_notify:bool -> ?filters:FilterType.t list -> ?prev_kv:bool -> ?watch_id:int -> ?fragment:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?range_end:bytes -> ?start_revision:int -> ?progress_notify:bool -> ?filters:FilterType.t list -> ?prev_kv:bool -> ?watch_id:int -> ?fragment:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = WatchCreateRequest
    module rec FilterType : sig
      type t =
        | NOPUT
        (** filter out put event. *)
        | NODELETE
        (** filter out delete event. *)
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = FilterType
      type t =
        | NOPUT
        (** filter out put event. *)
        | NODELETE
        (** filter out delete event. *)
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.WatchCreateRequest.FilterType"
      let to_int = function
        | NOPUT -> 0
        | NODELETE -> 1
      let from_int_exn = function
        | 0 -> NOPUT
        | 1 -> NODELETE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | NOPUT -> "NOPUT"
        | NODELETE -> "NODELETE"
      let from_string_exn = function
        | "NOPUT" -> NOPUT
        | "NODELETE" -> NODELETE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".etcdserverpb.WatchCreateRequest"
    type t = {
    key: bytes;(** key is the key to register for watching. *)
    range_end: bytes;(** range_end is the end of the range \[key, range_end) to watch. If range_end is not given,
    only the key argument is watched. If range_end is equal to '\\0', all keys greater than
    or equal to the key argument are watched.
    If the range_end is one bit larger than the given key,
    then all keys with the prefix (the given key) will be watched. *)
    start_revision: int;(** start_revision is an optional revision to watch from (inclusive). No start_revision is "now". *)
    progress_notify: bool;(** progress_notify is set so that the etcd server will periodically send a WatchResponse with
    no events to the new watcher if there are no recent events. It is useful when clients
    wish to recover a disconnected watcher starting from a recent known revision.
    The etcd server may decide how often it will send notifications based on current load. *)
    filters: FilterType.t list;(** filters filter the events at server side before it sends back to the watcher. *)
    prev_kv: bool;(** If prev_kv is set, created watcher gets the previous KV before the event happens.
    If the previous KV is already compacted, nothing will be returned. *)
    watch_id: int;(** If watch_id is provided and non-zero, it will be assigned to this watcher.
    Since creating a watcher in etcd is not a synchronous operation,
    this can be used ensure that ordering is correct when creating multiple
    watchers on the same stream. Creating a watcher with an ID already in
    use on the stream will cause an error to be returned. *)
    fragment: bool;(** fragment enables splitting large revisions into multiple watch responses. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?key:bytes -> ?range_end:bytes -> ?start_revision:int -> ?progress_notify:bool -> ?filters:FilterType.t list -> ?prev_kv:bool -> ?watch_id:int -> ?fragment:bool -> unit -> t
    let make ?(key = (Bytes.of_string {||})) ?(range_end = (Bytes.of_string {||})) ?(start_revision = 0) ?(progress_notify = false) ?(filters = []) ?(prev_kv = false) ?(watch_id = 0) ?(fragment = false) () = { key; range_end; start_revision; progress_notify; filters; prev_kv; watch_id; fragment }
    let merge =
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_range_end = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_start_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "start_revision", "startRevision"), int64_int, (0)) ) in
    let merge_progress_notify = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "progress_notify", "progressNotify"), bool, (false)) ) in
    let merge_filters = Runtime'.Merge.merge Runtime'.Spec.( repeated ((5, "filters", "filters"), (enum (module FilterType)), packed) ) in
    let merge_prev_kv = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "prev_kv", "prevKv"), bool, (false)) ) in
    let merge_watch_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "watch_id", "watchId"), int64_int, (0)) ) in
    let merge_fragment = Runtime'.Merge.merge Runtime'.Spec.( basic ((8, "fragment", "fragment"), bool, (false)) ) in
    fun t1 t2 -> {
    key = (merge_key t1.key t2.key);
    range_end = (merge_range_end t1.range_end t2.range_end);
    start_revision = (merge_start_revision t1.start_revision t2.start_revision);
    progress_notify = (merge_progress_notify t1.progress_notify t2.progress_notify);
    filters = (merge_filters t1.filters t2.filters);
    prev_kv = (merge_prev_kv t1.prev_kv t2.prev_kv);
    watch_id = (merge_watch_id t1.watch_id t2.watch_id);
    fragment = (merge_fragment t1.fragment t2.fragment);
     }
    let spec () = Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((2, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ^:: basic ((3, "start_revision", "startRevision"), int64_int, (0)) ^:: basic ((4, "progress_notify", "progressNotify"), bool, (false)) ^:: repeated ((5, "filters", "filters"), (enum (module FilterType)), packed) ^:: basic ((6, "prev_kv", "prevKv"), bool, (false)) ^:: basic ((7, "watch_id", "watchId"), int64_int, (0)) ^:: basic ((8, "fragment", "fragment"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { key; range_end; start_revision; progress_notify; filters; prev_kv; watch_id; fragment } -> serialize writer key range_end start_revision progress_notify filters prev_kv watch_id fragment

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor key range_end start_revision progress_notify filters prev_kv watch_id fragment = { key; range_end; start_revision; progress_notify; filters; prev_kv; watch_id; fragment } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { key; range_end; start_revision; progress_notify; filters; prev_kv; watch_id; fragment } -> serialize key range_end start_revision progress_notify filters prev_kv watch_id fragment
    let from_json_exn =
      let constructor key range_end start_revision progress_notify filters prev_kv watch_id fragment = { key; range_end; start_revision; progress_notify; filters; prev_kv; watch_id; fragment } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and WatchCancelRequest : sig
    type t = (int)
    (**
    watch_id is the watcher id to cancel so that no more events are transmitted.
    *)
    [@@deriving show { with_path = false}]
    val make: ?watch_id:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?watch_id:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = WatchCancelRequest
    let name () = ".etcdserverpb.WatchCancelRequest"
    type t = (int)
    (**
    watch_id is the watcher id to cancel so that no more events are transmitted.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?watch_id:int -> unit -> t
    let make ?(watch_id = 0) () = (watch_id)
    let merge =
    let merge_watch_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "watch_id", "watchId"), int64_int, (0)) ) in
    fun (t1_watch_id) (t2_watch_id) -> merge_watch_id t1_watch_id t2_watch_id
    let spec () = Runtime'.Spec.( basic ((1, "watch_id", "watchId"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (watch_id) -> serialize writer watch_id

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor watch_id = (watch_id) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (watch_id) -> serialize watch_id
    let from_json_exn =
      let constructor watch_id = (watch_id) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and WatchProgressRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = WatchProgressRequest
    let name () = ".etcdserverpb.WatchProgressRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and WatchResponse : sig
    type t = {
    header: ResponseHeader.t option;
    watch_id: int;(** watch_id is the ID of the watcher that corresponds to the response. *)
    created: bool;(** created is set to true if the response is for a create watch request.
    The client should record the watch_id and expect to receive events for
    the created watcher from the same stream.
    All events sent to the created watcher will attach with the same watch_id. *)
    canceled: bool;(** canceled is set to true if the response is for a cancel watch request.
    No further events will be sent to the canceled watcher. *)
    compact_revision: int;(** compact_revision is set to the minimum index if a watcher tries to watch
    at a compacted index.

    This happens when creating a watcher at a compacted revision or the watcher cannot
    catch up with the progress of the key-value store.

    The client should treat the watcher as canceled and should not try to create any
    watcher with the same start_revision again. *)
    cancel_reason: string;(** cancel_reason indicates the reason for canceling the watcher. *)
    fragment: bool;(** framgment is true if large watch response was split over multiple responses. *)
    events: Imported'modules.Kv.Mvccpb.Event.t list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?watch_id:int -> ?created:bool -> ?canceled:bool -> ?compact_revision:int -> ?cancel_reason:string -> ?fragment:bool -> ?events:Imported'modules.Kv.Mvccpb.Event.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?watch_id:int -> ?created:bool -> ?canceled:bool -> ?compact_revision:int -> ?cancel_reason:string -> ?fragment:bool -> ?events:Imported'modules.Kv.Mvccpb.Event.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = WatchResponse
    let name () = ".etcdserverpb.WatchResponse"
    type t = {
    header: ResponseHeader.t option;
    watch_id: int;(** watch_id is the ID of the watcher that corresponds to the response. *)
    created: bool;(** created is set to true if the response is for a create watch request.
    The client should record the watch_id and expect to receive events for
    the created watcher from the same stream.
    All events sent to the created watcher will attach with the same watch_id. *)
    canceled: bool;(** canceled is set to true if the response is for a cancel watch request.
    No further events will be sent to the canceled watcher. *)
    compact_revision: int;(** compact_revision is set to the minimum index if a watcher tries to watch
    at a compacted index.

    This happens when creating a watcher at a compacted revision or the watcher cannot
    catch up with the progress of the key-value store.

    The client should treat the watcher as canceled and should not try to create any
    watcher with the same start_revision again. *)
    cancel_reason: string;(** cancel_reason indicates the reason for canceling the watcher. *)
    fragment: bool;(** framgment is true if large watch response was split over multiple responses. *)
    events: Imported'modules.Kv.Mvccpb.Event.t list;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?watch_id:int -> ?created:bool -> ?canceled:bool -> ?compact_revision:int -> ?cancel_reason:string -> ?fragment:bool -> ?events:Imported'modules.Kv.Mvccpb.Event.t list -> unit -> t
    let make ?header ?(watch_id = 0) ?(created = false) ?(canceled = false) ?(compact_revision = 0) ?(cancel_reason = {||}) ?(fragment = false) ?(events = []) () = { header; watch_id; created; canceled; compact_revision; cancel_reason; fragment; events }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_watch_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "watch_id", "watchId"), int64_int, (0)) ) in
    let merge_created = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "created", "created"), bool, (false)) ) in
    let merge_canceled = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "canceled", "canceled"), bool, (false)) ) in
    let merge_compact_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "compact_revision", "compactRevision"), int64_int, (0)) ) in
    let merge_cancel_reason = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "cancel_reason", "cancelReason"), string, ({||})) ) in
    let merge_fragment = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "fragment", "fragment"), bool, (false)) ) in
    let merge_events = Runtime'.Merge.merge Runtime'.Spec.( repeated ((11, "events", "events"), (message (module Imported'modules.Kv.Mvccpb.Event)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    watch_id = (merge_watch_id t1.watch_id t2.watch_id);
    created = (merge_created t1.created t2.created);
    canceled = (merge_canceled t1.canceled t2.canceled);
    compact_revision = (merge_compact_revision t1.compact_revision t2.compact_revision);
    cancel_reason = (merge_cancel_reason t1.cancel_reason t2.cancel_reason);
    fragment = (merge_fragment t1.fragment t2.fragment);
    events = (merge_events t1.events t2.events);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "watch_id", "watchId"), int64_int, (0)) ^:: basic ((3, "created", "created"), bool, (false)) ^:: basic ((4, "canceled", "canceled"), bool, (false)) ^:: basic ((5, "compact_revision", "compactRevision"), int64_int, (0)) ^:: basic ((6, "cancel_reason", "cancelReason"), string, ({||})) ^:: basic ((7, "fragment", "fragment"), bool, (false)) ^:: repeated ((11, "events", "events"), (message (module Imported'modules.Kv.Mvccpb.Event)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; watch_id; created; canceled; compact_revision; cancel_reason; fragment; events } -> serialize writer header watch_id created canceled compact_revision cancel_reason fragment events

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header watch_id created canceled compact_revision cancel_reason fragment events = { header; watch_id; created; canceled; compact_revision; cancel_reason; fragment; events } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; watch_id; created; canceled; compact_revision; cancel_reason; fragment; events } -> serialize header watch_id created canceled compact_revision cancel_reason fragment events
    let from_json_exn =
      let constructor header watch_id created canceled compact_revision cancel_reason fragment events = { header; watch_id; created; canceled; compact_revision; cancel_reason; fragment; events } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseGrantRequest : sig
    type t = {
    tTL: int;(** TTL is the advisory time-to-live in seconds. Expired lease will return -1. *)
    iD: int;(** ID is the requested ID for the lease. If ID is set to 0, the lessor chooses an ID. *)
    }[@@deriving show { with_path = false}]
    val make: ?tTL:int -> ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?tTL:int -> ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseGrantRequest
    let name () = ".etcdserverpb.LeaseGrantRequest"
    type t = {
    tTL: int;(** TTL is the advisory time-to-live in seconds. Expired lease will return -1. *)
    iD: int;(** ID is the requested ID for the lease. If ID is set to 0, the lessor chooses an ID. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?tTL:int -> ?iD:int -> unit -> t
    let make ?(tTL = 0) ?(iD = 0) () = { tTL; iD }
    let merge =
    let merge_tTL = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "TTL", "TTL"), int64_int, (0)) ) in
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "ID", "ID"), int64_int, (0)) ) in
    fun t1 t2 -> {
    tTL = (merge_tTL t1.tTL t2.tTL);
    iD = (merge_iD t1.iD t2.iD);
     }
    let spec () = Runtime'.Spec.( basic ((1, "TTL", "TTL"), int64_int, (0)) ^:: basic ((2, "ID", "ID"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { tTL; iD } -> serialize writer tTL iD

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor tTL iD = { tTL; iD } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { tTL; iD } -> serialize tTL iD
    let from_json_exn =
      let constructor tTL iD = { tTL; iD } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseGrantResponse : sig
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID for the granted lease. *)
    tTL: int;(** TTL is the server chosen lease time-to-live in seconds. *)
    error: string;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?error:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?error:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseGrantResponse
    let name () = ".etcdserverpb.LeaseGrantResponse"
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID for the granted lease. *)
    tTL: int;(** TTL is the server chosen lease time-to-live in seconds. *)
    error: string;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?error:string -> unit -> t
    let make ?header ?(iD = 0) ?(tTL = 0) ?(error = {||}) () = { header; iD; tTL; error }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "ID", "ID"), int64_int, (0)) ) in
    let merge_tTL = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "TTL", "TTL"), int64_int, (0)) ) in
    let merge_error = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "error", "error"), string, ({||})) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    iD = (merge_iD t1.iD t2.iD);
    tTL = (merge_tTL t1.tTL t2.tTL);
    error = (merge_error t1.error t2.error);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "ID", "ID"), int64_int, (0)) ^:: basic ((3, "TTL", "TTL"), int64_int, (0)) ^:: basic ((4, "error", "error"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; iD; tTL; error } -> serialize writer header iD tTL error

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header iD tTL error = { header; iD; tTL; error } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; iD; tTL; error } -> serialize header iD tTL error
    let from_json_exn =
      let constructor header iD tTL error = { header; iD; tTL; error } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseRevokeRequest : sig
    type t = (int)
    (**
    ID is the lease ID to revoke. When the ID is revoked, all associated keys will be deleted.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseRevokeRequest
    let name () = ".etcdserverpb.LeaseRevokeRequest"
    type t = (int)
    (**
    ID is the lease ID to revoke. When the ID is revoked, all associated keys will be deleted.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?iD:int -> unit -> t
    let make ?(iD = 0) () = (iD)
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ) in
    fun (t1_iD) (t2_iD) -> merge_iD t1_iD t2_iD
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (iD) -> serialize writer iD

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (iD) -> serialize iD
    let from_json_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseRevokeResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseRevokeResponse
    let name () = ".etcdserverpb.LeaseRevokeResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseCheckpoint : sig
    type t = {
    iD: int;(** ID is the lease ID to checkpoint. *)
    remaining_TTL: int;(** Remaining_TTL is the remaining time until expiry of the lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?remaining_TTL:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?remaining_TTL:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseCheckpoint
    let name () = ".etcdserverpb.LeaseCheckpoint"
    type t = {
    iD: int;(** ID is the lease ID to checkpoint. *)
    remaining_TTL: int;(** Remaining_TTL is the remaining time until expiry of the lease. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?iD:int -> ?remaining_TTL:int -> unit -> t
    let make ?(iD = 0) ?(remaining_TTL = 0) () = { iD; remaining_TTL }
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ) in
    let merge_remaining_TTL = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "remaining_TTL", "remainingTTL"), int64_int, (0)) ) in
    fun t1 t2 -> {
    iD = (merge_iD t1.iD t2.iD);
    remaining_TTL = (merge_remaining_TTL t1.remaining_TTL t2.remaining_TTL);
     }
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ^:: basic ((2, "remaining_TTL", "remainingTTL"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { iD; remaining_TTL } -> serialize writer iD remaining_TTL

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD remaining_TTL = { iD; remaining_TTL } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { iD; remaining_TTL } -> serialize iD remaining_TTL
    let from_json_exn =
      let constructor iD remaining_TTL = { iD; remaining_TTL } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseCheckpointRequest : sig
    type t = (LeaseCheckpoint.t list)[@@deriving show { with_path = false}]
    val make: ?checkpoints:LeaseCheckpoint.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?checkpoints:LeaseCheckpoint.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseCheckpointRequest
    let name () = ".etcdserverpb.LeaseCheckpointRequest"
    type t = (LeaseCheckpoint.t list)[@@deriving show { with_path = false}]
    type make_t = ?checkpoints:LeaseCheckpoint.t list -> unit -> t
    let make ?(checkpoints = []) () = (checkpoints)
    let merge =
    let merge_checkpoints = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "checkpoints", "checkpoints"), (message (module LeaseCheckpoint)), not_packed) ) in
    fun (t1_checkpoints) (t2_checkpoints) -> merge_checkpoints t1_checkpoints t2_checkpoints
    let spec () = Runtime'.Spec.( repeated ((1, "checkpoints", "checkpoints"), (message (module LeaseCheckpoint)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (checkpoints) -> serialize writer checkpoints

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor checkpoints = (checkpoints) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (checkpoints) -> serialize checkpoints
    let from_json_exn =
      let constructor checkpoints = (checkpoints) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseCheckpointResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseCheckpointResponse
    let name () = ".etcdserverpb.LeaseCheckpointResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseKeepAliveRequest : sig
    type t = (int)
    (**
    ID is the lease ID for the lease to keep alive.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseKeepAliveRequest
    let name () = ".etcdserverpb.LeaseKeepAliveRequest"
    type t = (int)
    (**
    ID is the lease ID for the lease to keep alive.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?iD:int -> unit -> t
    let make ?(iD = 0) () = (iD)
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ) in
    fun (t1_iD) (t2_iD) -> merge_iD t1_iD t2_iD
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (iD) -> serialize writer iD

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (iD) -> serialize iD
    let from_json_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseKeepAliveResponse : sig
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID from the keep alive request. *)
    tTL: int;(** TTL is the new time-to-live for the lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseKeepAliveResponse
    let name () = ".etcdserverpb.LeaseKeepAliveResponse"
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID from the keep alive request. *)
    tTL: int;(** TTL is the new time-to-live for the lease. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> unit -> t
    let make ?header ?(iD = 0) ?(tTL = 0) () = { header; iD; tTL }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "ID", "ID"), int64_int, (0)) ) in
    let merge_tTL = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "TTL", "TTL"), int64_int, (0)) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    iD = (merge_iD t1.iD t2.iD);
    tTL = (merge_tTL t1.tTL t2.tTL);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "ID", "ID"), int64_int, (0)) ^:: basic ((3, "TTL", "TTL"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; iD; tTL } -> serialize writer header iD tTL

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header iD tTL = { header; iD; tTL } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; iD; tTL } -> serialize header iD tTL
    let from_json_exn =
      let constructor header iD tTL = { header; iD; tTL } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseTimeToLiveRequest : sig
    type t = {
    iD: int;(** ID is the lease ID for the lease. *)
    keys: bool;(** keys is true to query all the keys attached to this lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?keys:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?keys:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseTimeToLiveRequest
    let name () = ".etcdserverpb.LeaseTimeToLiveRequest"
    type t = {
    iD: int;(** ID is the lease ID for the lease. *)
    keys: bool;(** keys is true to query all the keys attached to this lease. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?iD:int -> ?keys:bool -> unit -> t
    let make ?(iD = 0) ?(keys = false) () = { iD; keys }
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ) in
    let merge_keys = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "keys", "keys"), bool, (false)) ) in
    fun t1 t2 -> {
    iD = (merge_iD t1.iD t2.iD);
    keys = (merge_keys t1.keys t2.keys);
     }
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ^:: basic ((2, "keys", "keys"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { iD; keys } -> serialize writer iD keys

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD keys = { iD; keys } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { iD; keys } -> serialize iD keys
    let from_json_exn =
      let constructor iD keys = { iD; keys } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseTimeToLiveResponse : sig
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID from the keep alive request. *)
    tTL: int;(** TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds. *)
    grantedTTL: int;(** GrantedTTL is the initial granted time in seconds upon lease creation/renewal. *)
    keys: bytes list;(** Keys is the list of keys attached to this lease. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?grantedTTL:int -> ?keys:bytes list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?grantedTTL:int -> ?keys:bytes list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseTimeToLiveResponse
    let name () = ".etcdserverpb.LeaseTimeToLiveResponse"
    type t = {
    header: ResponseHeader.t option;
    iD: int;(** ID is the lease ID from the keep alive request. *)
    tTL: int;(** TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds. *)
    grantedTTL: int;(** GrantedTTL is the initial granted time in seconds upon lease creation/renewal. *)
    keys: bytes list;(** Keys is the list of keys attached to this lease. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?iD:int -> ?tTL:int -> ?grantedTTL:int -> ?keys:bytes list -> unit -> t
    let make ?header ?(iD = 0) ?(tTL = 0) ?(grantedTTL = 0) ?(keys = []) () = { header; iD; tTL; grantedTTL; keys }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "ID", "ID"), int64_int, (0)) ) in
    let merge_tTL = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "TTL", "TTL"), int64_int, (0)) ) in
    let merge_grantedTTL = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "grantedTTL", "grantedTTL"), int64_int, (0)) ) in
    let merge_keys = Runtime'.Merge.merge Runtime'.Spec.( repeated ((5, "keys", "keys"), bytes, not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    iD = (merge_iD t1.iD t2.iD);
    tTL = (merge_tTL t1.tTL t2.tTL);
    grantedTTL = (merge_grantedTTL t1.grantedTTL t2.grantedTTL);
    keys = (merge_keys t1.keys t2.keys);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "ID", "ID"), int64_int, (0)) ^:: basic ((3, "TTL", "TTL"), int64_int, (0)) ^:: basic ((4, "grantedTTL", "grantedTTL"), int64_int, (0)) ^:: repeated ((5, "keys", "keys"), bytes, not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; iD; tTL; grantedTTL; keys } -> serialize writer header iD tTL grantedTTL keys

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header iD tTL grantedTTL keys = { header; iD; tTL; grantedTTL; keys } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; iD; tTL; grantedTTL; keys } -> serialize header iD tTL grantedTTL keys
    let from_json_exn =
      let constructor header iD tTL grantedTTL keys = { header; iD; tTL; grantedTTL; keys } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseLeasesRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseLeasesRequest
    let name () = ".etcdserverpb.LeaseLeasesRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseStatus : sig
    type t = (int)
    (**
    TODO: int64 TTL = 2;
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseStatus
    let name () = ".etcdserverpb.LeaseStatus"
    type t = (int)
    (**
    TODO: int64 TTL = 2;
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?iD:int -> unit -> t
    let make ?(iD = 0) () = (iD)
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ) in
    fun (t1_iD) (t2_iD) -> merge_iD t1_iD t2_iD
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (iD) -> serialize writer iD

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (iD) -> serialize iD
    let from_json_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and LeaseLeasesResponse : sig
    type t = {
    header: ResponseHeader.t option;
    leases: LeaseStatus.t list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?leases:LeaseStatus.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?leases:LeaseStatus.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = LeaseLeasesResponse
    let name () = ".etcdserverpb.LeaseLeasesResponse"
    type t = {
    header: ResponseHeader.t option;
    leases: LeaseStatus.t list;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?leases:LeaseStatus.t list -> unit -> t
    let make ?header ?(leases = []) () = { header; leases }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_leases = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "leases", "leases"), (message (module LeaseStatus)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    leases = (merge_leases t1.leases t2.leases);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "leases", "leases"), (message (module LeaseStatus)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; leases } -> serialize writer header leases

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header leases = { header; leases } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; leases } -> serialize header leases
    let from_json_exn =
      let constructor header leases = { header; leases } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and Member : sig
    type t = {
    iD: int;(** ID is the member ID for this member. *)
    name: string;(** name is the human-readable name of the member. If the member is not started, the name will be an empty string. *)
    peerURLs: string list;(** peerURLs is the list of URLs the member exposes to the cluster for communication. *)
    clientURLs: string list;(** clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty. *)
    isLearner: bool;(** isLearner indicates if the member is raft learner. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?name:string -> ?peerURLs:string list -> ?clientURLs:string list -> ?isLearner:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?name:string -> ?peerURLs:string list -> ?clientURLs:string list -> ?isLearner:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = Member
    let name () = ".etcdserverpb.Member"
    type t = {
    iD: int;(** ID is the member ID for this member. *)
    name: string;(** name is the human-readable name of the member. If the member is not started, the name will be an empty string. *)
    peerURLs: string list;(** peerURLs is the list of URLs the member exposes to the cluster for communication. *)
    clientURLs: string list;(** clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty. *)
    isLearner: bool;(** isLearner indicates if the member is raft learner. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?iD:int -> ?name:string -> ?peerURLs:string list -> ?clientURLs:string list -> ?isLearner:bool -> unit -> t
    let make ?(iD = 0) ?(name = {||}) ?(peerURLs = []) ?(clientURLs = []) ?(isLearner = false) () = { iD; name; peerURLs; clientURLs; isLearner }
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ) in
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "name", "name"), string, ({||})) ) in
    let merge_peerURLs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "peerURLs", "peerURLs"), string, not_packed) ) in
    let merge_clientURLs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "clientURLs", "clientURLs"), string, not_packed) ) in
    let merge_isLearner = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "isLearner", "isLearner"), bool, (false)) ) in
    fun t1 t2 -> {
    iD = (merge_iD t1.iD t2.iD);
    name = (merge_name t1.name t2.name);
    peerURLs = (merge_peerURLs t1.peerURLs t2.peerURLs);
    clientURLs = (merge_clientURLs t1.clientURLs t2.clientURLs);
    isLearner = (merge_isLearner t1.isLearner t2.isLearner);
     }
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ^:: basic ((2, "name", "name"), string, ({||})) ^:: repeated ((3, "peerURLs", "peerURLs"), string, not_packed) ^:: repeated ((4, "clientURLs", "clientURLs"), string, not_packed) ^:: basic ((5, "isLearner", "isLearner"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { iD; name; peerURLs; clientURLs; isLearner } -> serialize writer iD name peerURLs clientURLs isLearner

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD name peerURLs clientURLs isLearner = { iD; name; peerURLs; clientURLs; isLearner } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { iD; name; peerURLs; clientURLs; isLearner } -> serialize iD name peerURLs clientURLs isLearner
    let from_json_exn =
      let constructor iD name peerURLs clientURLs isLearner = { iD; name; peerURLs; clientURLs; isLearner } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberAddRequest : sig
    type t = {
    peerURLs: string list;(** peerURLs is the list of URLs the added member will use to communicate with the cluster. *)
    isLearner: bool;(** isLearner indicates if the added member is raft learner. *)
    }[@@deriving show { with_path = false}]
    val make: ?peerURLs:string list -> ?isLearner:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?peerURLs:string list -> ?isLearner:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberAddRequest
    let name () = ".etcdserverpb.MemberAddRequest"
    type t = {
    peerURLs: string list;(** peerURLs is the list of URLs the added member will use to communicate with the cluster. *)
    isLearner: bool;(** isLearner indicates if the added member is raft learner. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?peerURLs:string list -> ?isLearner:bool -> unit -> t
    let make ?(peerURLs = []) ?(isLearner = false) () = { peerURLs; isLearner }
    let merge =
    let merge_peerURLs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "peerURLs", "peerURLs"), string, not_packed) ) in
    let merge_isLearner = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "isLearner", "isLearner"), bool, (false)) ) in
    fun t1 t2 -> {
    peerURLs = (merge_peerURLs t1.peerURLs t2.peerURLs);
    isLearner = (merge_isLearner t1.isLearner t2.isLearner);
     }
    let spec () = Runtime'.Spec.( repeated ((1, "peerURLs", "peerURLs"), string, not_packed) ^:: basic ((2, "isLearner", "isLearner"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { peerURLs; isLearner } -> serialize writer peerURLs isLearner

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor peerURLs isLearner = { peerURLs; isLearner } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { peerURLs; isLearner } -> serialize peerURLs isLearner
    let from_json_exn =
      let constructor peerURLs isLearner = { peerURLs; isLearner } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberAddResponse : sig
    type t = {
    header: ResponseHeader.t option;
    member: Member.t option;(** member is the member information for the added member. *)
    members: Member.t list;(** members is a list of all members after adding the new member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?member:Member.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?member:Member.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberAddResponse
    let name () = ".etcdserverpb.MemberAddResponse"
    type t = {
    header: ResponseHeader.t option;
    member: Member.t option;(** member is the member information for the added member. *)
    members: Member.t list;(** members is a list of all members after adding the new member. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?member:Member.t -> ?members:Member.t list -> unit -> t
    let make ?header ?member ?(members = []) () = { header; member; members }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_member = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "member", "member"), (message (module Member))) ) in
    let merge_members = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "members", "members"), (message (module Member)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    member = (merge_member t1.member t2.member);
    members = (merge_members t1.members t2.members);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic_opt ((2, "member", "member"), (message (module Member))) ^:: repeated ((3, "members", "members"), (message (module Member)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; member; members } -> serialize writer header member members

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header member members = { header; member; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; member; members } -> serialize header member members
    let from_json_exn =
      let constructor header member members = { header; member; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberRemoveRequest : sig
    type t = (int)
    (**
    ID is the member ID of the member to remove.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberRemoveRequest
    let name () = ".etcdserverpb.MemberRemoveRequest"
    type t = (int)
    (**
    ID is the member ID of the member to remove.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?iD:int -> unit -> t
    let make ?(iD = 0) () = (iD)
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ) in
    fun (t1_iD) (t2_iD) -> merge_iD t1_iD t2_iD
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (iD) -> serialize writer iD

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (iD) -> serialize iD
    let from_json_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberRemoveResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after removing the member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberRemoveResponse
    let name () = ".etcdserverpb.MemberRemoveResponse"
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after removing the member. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    let make ?header ?(members = []) () = { header; members }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_members = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "members", "members"), (message (module Member)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    members = (merge_members t1.members t2.members);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "members", "members"), (message (module Member)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; members } -> serialize writer header members

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; members } -> serialize header members
    let from_json_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberUpdateRequest : sig
    type t = {
    iD: int;(** ID is the member ID of the member to update. *)
    peerURLs: string list;(** peerURLs is the new list of URLs the member will use to communicate with the cluster. *)
    }[@@deriving show { with_path = false}]
    val make: ?iD:int -> ?peerURLs:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> ?peerURLs:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberUpdateRequest
    let name () = ".etcdserverpb.MemberUpdateRequest"
    type t = {
    iD: int;(** ID is the member ID of the member to update. *)
    peerURLs: string list;(** peerURLs is the new list of URLs the member will use to communicate with the cluster. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?iD:int -> ?peerURLs:string list -> unit -> t
    let make ?(iD = 0) ?(peerURLs = []) () = { iD; peerURLs }
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ) in
    let merge_peerURLs = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "peerURLs", "peerURLs"), string, not_packed) ) in
    fun t1 t2 -> {
    iD = (merge_iD t1.iD t2.iD);
    peerURLs = (merge_peerURLs t1.peerURLs t2.peerURLs);
     }
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ^:: repeated ((2, "peerURLs", "peerURLs"), string, not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { iD; peerURLs } -> serialize writer iD peerURLs

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD peerURLs = { iD; peerURLs } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { iD; peerURLs } -> serialize iD peerURLs
    let from_json_exn =
      let constructor iD peerURLs = { iD; peerURLs } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberUpdateResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after updating the member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberUpdateResponse
    let name () = ".etcdserverpb.MemberUpdateResponse"
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after updating the member. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    let make ?header ?(members = []) () = { header; members }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_members = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "members", "members"), (message (module Member)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    members = (merge_members t1.members t2.members);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "members", "members"), (message (module Member)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; members } -> serialize writer header members

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; members } -> serialize header members
    let from_json_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberListRequest : sig
    type t = (bool)[@@deriving show { with_path = false}]
    val make: ?linearizable:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?linearizable:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberListRequest
    let name () = ".etcdserverpb.MemberListRequest"
    type t = (bool)[@@deriving show { with_path = false}]
    type make_t = ?linearizable:bool -> unit -> t
    let make ?(linearizable = false) () = (linearizable)
    let merge =
    let merge_linearizable = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "linearizable", "linearizable"), bool, (false)) ) in
    fun (t1_linearizable) (t2_linearizable) -> merge_linearizable t1_linearizable t2_linearizable
    let spec () = Runtime'.Spec.( basic ((1, "linearizable", "linearizable"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (linearizable) -> serialize writer linearizable

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor linearizable = (linearizable) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (linearizable) -> serialize linearizable
    let from_json_exn =
      let constructor linearizable = (linearizable) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberListResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members associated with the cluster. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberListResponse
    let name () = ".etcdserverpb.MemberListResponse"
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members associated with the cluster. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    let make ?header ?(members = []) () = { header; members }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_members = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "members", "members"), (message (module Member)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    members = (merge_members t1.members t2.members);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "members", "members"), (message (module Member)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; members } -> serialize writer header members

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; members } -> serialize header members
    let from_json_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberPromoteRequest : sig
    type t = (int)
    (**
    ID is the member ID of the member to promote.
    *)
    [@@deriving show { with_path = false}]
    val make: ?iD:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?iD:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberPromoteRequest
    let name () = ".etcdserverpb.MemberPromoteRequest"
    type t = (int)
    (**
    ID is the member ID of the member to promote.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?iD:int -> unit -> t
    let make ?(iD = 0) () = (iD)
    let merge =
    let merge_iD = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ) in
    fun (t1_iD) (t2_iD) -> merge_iD t1_iD t2_iD
    let spec () = Runtime'.Spec.( basic ((1, "ID", "ID"), uint64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (iD) -> serialize writer iD

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (iD) -> serialize iD
    let from_json_exn =
      let constructor iD = (iD) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MemberPromoteResponse : sig
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after promoting the member. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MemberPromoteResponse
    let name () = ".etcdserverpb.MemberPromoteResponse"
    type t = {
    header: ResponseHeader.t option;
    members: Member.t list;(** members is a list of all members after promoting the member. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?members:Member.t list -> unit -> t
    let make ?header ?(members = []) () = { header; members }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_members = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "members", "members"), (message (module Member)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    members = (merge_members t1.members t2.members);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "members", "members"), (message (module Member)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; members } -> serialize writer header members

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; members } -> serialize header members
    let from_json_exn =
      let constructor header members = { header; members } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and DefragmentRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = DefragmentRequest
    let name () = ".etcdserverpb.DefragmentRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and DefragmentResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = DefragmentResponse
    let name () = ".etcdserverpb.DefragmentResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MoveLeaderRequest : sig
    type t = (int)
    (**
    targetID is the node ID for the new leader.
    *)
    [@@deriving show { with_path = false}]
    val make: ?targetID:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?targetID:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MoveLeaderRequest
    let name () = ".etcdserverpb.MoveLeaderRequest"
    type t = (int)
    (**
    targetID is the node ID for the new leader.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?targetID:int -> unit -> t
    let make ?(targetID = 0) () = (targetID)
    let merge =
    let merge_targetID = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "targetID", "targetID"), uint64_int, (0)) ) in
    fun (t1_targetID) (t2_targetID) -> merge_targetID t1_targetID t2_targetID
    let spec () = Runtime'.Spec.( basic ((1, "targetID", "targetID"), uint64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (targetID) -> serialize writer targetID

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor targetID = (targetID) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (targetID) -> serialize targetID
    let from_json_exn =
      let constructor targetID = (targetID) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and MoveLeaderResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = MoveLeaderResponse
    let name () = ".etcdserverpb.MoveLeaderResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AlarmRequest : sig
    module rec AlarmAction : sig
      type t =
        | GET
        | ACTIVATE
        | DEACTIVATE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    action: AlarmAction.t;(** action is the kind of alarm request to issue. The action
    may GET alarm statuses, ACTIVATE an alarm, or DEACTIVATE a
    raised alarm. *)
    memberID: int;(** memberID is the ID of the member associated with the alarm. If memberID is 0, the
    alarm request covers all members. *)
    alarm: AlarmType.t;(** alarm is the type of alarm to consider for this request. *)
    }[@@deriving show { with_path = false}]
    val make: ?action:AlarmAction.t -> ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?action:AlarmAction.t -> ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AlarmRequest
    module rec AlarmAction : sig
      type t =
        | GET
        | ACTIVATE
        | DEACTIVATE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = AlarmAction
      type t =
        | GET
        | ACTIVATE
        | DEACTIVATE
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.AlarmRequest.AlarmAction"
      let to_int = function
        | GET -> 0
        | ACTIVATE -> 1
        | DEACTIVATE -> 2
      let from_int_exn = function
        | 0 -> GET
        | 1 -> ACTIVATE
        | 2 -> DEACTIVATE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | GET -> "GET"
        | ACTIVATE -> "ACTIVATE"
        | DEACTIVATE -> "DEACTIVATE"
      let from_string_exn = function
        | "GET" -> GET
        | "ACTIVATE" -> ACTIVATE
        | "DEACTIVATE" -> DEACTIVATE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".etcdserverpb.AlarmRequest"
    type t = {
    action: AlarmAction.t;(** action is the kind of alarm request to issue. The action
    may GET alarm statuses, ACTIVATE an alarm, or DEACTIVATE a
    raised alarm. *)
    memberID: int;(** memberID is the ID of the member associated with the alarm. If memberID is 0, the
    alarm request covers all members. *)
    alarm: AlarmType.t;(** alarm is the type of alarm to consider for this request. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?action:AlarmAction.t -> ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    let make ?(action = AlarmAction.from_int_exn 0) ?(memberID = 0) ?(alarm = AlarmType.from_int_exn 0) () = { action; memberID; alarm }
    let merge =
    let merge_action = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "action", "action"), (enum (module AlarmAction)), (AlarmAction.from_int_exn 0)) ) in
    let merge_memberID = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "memberID", "memberID"), uint64_int, (0)) ) in
    let merge_alarm = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "alarm", "alarm"), (enum (module AlarmType)), (AlarmType.from_int_exn 0)) ) in
    fun t1 t2 -> {
    action = (merge_action t1.action t2.action);
    memberID = (merge_memberID t1.memberID t2.memberID);
    alarm = (merge_alarm t1.alarm t2.alarm);
     }
    let spec () = Runtime'.Spec.( basic ((1, "action", "action"), (enum (module AlarmAction)), (AlarmAction.from_int_exn 0)) ^:: basic ((2, "memberID", "memberID"), uint64_int, (0)) ^:: basic ((3, "alarm", "alarm"), (enum (module AlarmType)), (AlarmType.from_int_exn 0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { action; memberID; alarm } -> serialize writer action memberID alarm

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor action memberID alarm = { action; memberID; alarm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { action; memberID; alarm } -> serialize action memberID alarm
    let from_json_exn =
      let constructor action memberID alarm = { action; memberID; alarm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AlarmMember : sig
    type t = {
    memberID: int;(** memberID is the ID of the member associated with the raised alarm. *)
    alarm: AlarmType.t;(** alarm is the type of alarm which has been raised. *)
    }[@@deriving show { with_path = false}]
    val make: ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AlarmMember
    let name () = ".etcdserverpb.AlarmMember"
    type t = {
    memberID: int;(** memberID is the ID of the member associated with the raised alarm. *)
    alarm: AlarmType.t;(** alarm is the type of alarm which has been raised. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?memberID:int -> ?alarm:AlarmType.t -> unit -> t
    let make ?(memberID = 0) ?(alarm = AlarmType.from_int_exn 0) () = { memberID; alarm }
    let merge =
    let merge_memberID = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "memberID", "memberID"), uint64_int, (0)) ) in
    let merge_alarm = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "alarm", "alarm"), (enum (module AlarmType)), (AlarmType.from_int_exn 0)) ) in
    fun t1 t2 -> {
    memberID = (merge_memberID t1.memberID t2.memberID);
    alarm = (merge_alarm t1.alarm t2.alarm);
     }
    let spec () = Runtime'.Spec.( basic ((1, "memberID", "memberID"), uint64_int, (0)) ^:: basic ((2, "alarm", "alarm"), (enum (module AlarmType)), (AlarmType.from_int_exn 0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { memberID; alarm } -> serialize writer memberID alarm

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor memberID alarm = { memberID; alarm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { memberID; alarm } -> serialize memberID alarm
    let from_json_exn =
      let constructor memberID alarm = { memberID; alarm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AlarmResponse : sig
    type t = {
    header: ResponseHeader.t option;
    alarms: AlarmMember.t list;(** alarms is a list of alarms associated with the alarm request. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?alarms:AlarmMember.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?alarms:AlarmMember.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AlarmResponse
    let name () = ".etcdserverpb.AlarmResponse"
    type t = {
    header: ResponseHeader.t option;
    alarms: AlarmMember.t list;(** alarms is a list of alarms associated with the alarm request. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?alarms:AlarmMember.t list -> unit -> t
    let make ?header ?(alarms = []) () = { header; alarms }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_alarms = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "alarms", "alarms"), (message (module AlarmMember)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    alarms = (merge_alarms t1.alarms t2.alarms);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "alarms", "alarms"), (message (module AlarmMember)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; alarms } -> serialize writer header alarms

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header alarms = { header; alarms } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; alarms } -> serialize header alarms
    let from_json_exn =
      let constructor header alarms = { header; alarms } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and DowngradeRequest : sig
    module rec DowngradeAction : sig
      type t =
        | VALIDATE
        | ENABLE
        | CANCEL
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    action: DowngradeAction.t;(** action is the kind of downgrade request to issue. The action may
    VALIDATE the target version, DOWNGRADE the cluster version,
    or CANCEL the current downgrading job. *)
    version: string;(** version is the target version to downgrade. *)
    }[@@deriving show { with_path = false}]
    val make: ?action:DowngradeAction.t -> ?version:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?action:DowngradeAction.t -> ?version:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = DowngradeRequest
    module rec DowngradeAction : sig
      type t =
        | VALIDATE
        | ENABLE
        | CANCEL
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = DowngradeAction
      type t =
        | VALIDATE
        | ENABLE
        | CANCEL
      [@@deriving show { with_path = false}]
      let name () = ".etcdserverpb.DowngradeRequest.DowngradeAction"
      let to_int = function
        | VALIDATE -> 0
        | ENABLE -> 1
        | CANCEL -> 2
      let from_int_exn = function
        | 0 -> VALIDATE
        | 1 -> ENABLE
        | 2 -> CANCEL
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | VALIDATE -> "VALIDATE"
        | ENABLE -> "ENABLE"
        | CANCEL -> "CANCEL"
      let from_string_exn = function
        | "VALIDATE" -> VALIDATE
        | "ENABLE" -> ENABLE
        | "CANCEL" -> CANCEL
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".etcdserverpb.DowngradeRequest"
    type t = {
    action: DowngradeAction.t;(** action is the kind of downgrade request to issue. The action may
    VALIDATE the target version, DOWNGRADE the cluster version,
    or CANCEL the current downgrading job. *)
    version: string;(** version is the target version to downgrade. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?action:DowngradeAction.t -> ?version:string -> unit -> t
    let make ?(action = DowngradeAction.from_int_exn 0) ?(version = {||}) () = { action; version }
    let merge =
    let merge_action = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "action", "action"), (enum (module DowngradeAction)), (DowngradeAction.from_int_exn 0)) ) in
    let merge_version = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "version", "version"), string, ({||})) ) in
    fun t1 t2 -> {
    action = (merge_action t1.action t2.action);
    version = (merge_version t1.version t2.version);
     }
    let spec () = Runtime'.Spec.( basic ((1, "action", "action"), (enum (module DowngradeAction)), (DowngradeAction.from_int_exn 0)) ^:: basic ((2, "version", "version"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { action; version } -> serialize writer action version

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor action version = { action; version } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { action; version } -> serialize action version
    let from_json_exn =
      let constructor action version = { action; version } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and DowngradeResponse : sig
    type t = {
    header: ResponseHeader.t option;
    version: string;(** version is the current cluster version. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?version:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?version:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = DowngradeResponse
    let name () = ".etcdserverpb.DowngradeResponse"
    type t = {
    header: ResponseHeader.t option;
    version: string;(** version is the current cluster version. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?version:string -> unit -> t
    let make ?header ?(version = {||}) () = { header; version }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_version = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "version", "version"), string, ({||})) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    version = (merge_version t1.version t2.version);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "version", "version"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; version } -> serialize writer header version

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header version = { header; version } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; version } -> serialize header version
    let from_json_exn =
      let constructor header version = { header; version } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and StatusRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = StatusRequest
    let name () = ".etcdserverpb.StatusRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and StatusResponse : sig
    type t = {
    header: ResponseHeader.t option;
    version: string;(** version is the cluster protocol version used by the responding member. *)
    dbSize: int;(** dbSize is the size of the backend database physically allocated, in bytes, of the responding member. *)
    leader: int;(** leader is the member ID which the responding member believes is the current leader. *)
    raftIndex: int;(** raftIndex is the current raft committed index of the responding member. *)
    raftTerm: int;(** raftTerm is the current raft term of the responding member. *)
    raftAppliedIndex: int;(** raftAppliedIndex is the current raft applied index of the responding member. *)
    errors: string list;(** errors contains alarm/health information and status. *)
    dbSizeInUse: int;(** dbSizeInUse is the size of the backend database logically in use, in bytes, of the responding member. *)
    isLearner: bool;(** isLearner indicates if the member is raft learner. *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?version:string -> ?dbSize:int -> ?leader:int -> ?raftIndex:int -> ?raftTerm:int -> ?raftAppliedIndex:int -> ?errors:string list -> ?dbSizeInUse:int -> ?isLearner:bool -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?version:string -> ?dbSize:int -> ?leader:int -> ?raftIndex:int -> ?raftTerm:int -> ?raftAppliedIndex:int -> ?errors:string list -> ?dbSizeInUse:int -> ?isLearner:bool -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = StatusResponse
    let name () = ".etcdserverpb.StatusResponse"
    type t = {
    header: ResponseHeader.t option;
    version: string;(** version is the cluster protocol version used by the responding member. *)
    dbSize: int;(** dbSize is the size of the backend database physically allocated, in bytes, of the responding member. *)
    leader: int;(** leader is the member ID which the responding member believes is the current leader. *)
    raftIndex: int;(** raftIndex is the current raft committed index of the responding member. *)
    raftTerm: int;(** raftTerm is the current raft term of the responding member. *)
    raftAppliedIndex: int;(** raftAppliedIndex is the current raft applied index of the responding member. *)
    errors: string list;(** errors contains alarm/health information and status. *)
    dbSizeInUse: int;(** dbSizeInUse is the size of the backend database logically in use, in bytes, of the responding member. *)
    isLearner: bool;(** isLearner indicates if the member is raft learner. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?version:string -> ?dbSize:int -> ?leader:int -> ?raftIndex:int -> ?raftTerm:int -> ?raftAppliedIndex:int -> ?errors:string list -> ?dbSizeInUse:int -> ?isLearner:bool -> unit -> t
    let make ?header ?(version = {||}) ?(dbSize = 0) ?(leader = 0) ?(raftIndex = 0) ?(raftTerm = 0) ?(raftAppliedIndex = 0) ?(errors = []) ?(dbSizeInUse = 0) ?(isLearner = false) () = { header; version; dbSize; leader; raftIndex; raftTerm; raftAppliedIndex; errors; dbSizeInUse; isLearner }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_version = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "version", "version"), string, ({||})) ) in
    let merge_dbSize = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "dbSize", "dbSize"), int64_int, (0)) ) in
    let merge_leader = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "leader", "leader"), uint64_int, (0)) ) in
    let merge_raftIndex = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "raftIndex", "raftIndex"), uint64_int, (0)) ) in
    let merge_raftTerm = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "raftTerm", "raftTerm"), uint64_int, (0)) ) in
    let merge_raftAppliedIndex = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "raftAppliedIndex", "raftAppliedIndex"), uint64_int, (0)) ) in
    let merge_errors = Runtime'.Merge.merge Runtime'.Spec.( repeated ((8, "errors", "errors"), string, not_packed) ) in
    let merge_dbSizeInUse = Runtime'.Merge.merge Runtime'.Spec.( basic ((9, "dbSizeInUse", "dbSizeInUse"), int64_int, (0)) ) in
    let merge_isLearner = Runtime'.Merge.merge Runtime'.Spec.( basic ((10, "isLearner", "isLearner"), bool, (false)) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    version = (merge_version t1.version t2.version);
    dbSize = (merge_dbSize t1.dbSize t2.dbSize);
    leader = (merge_leader t1.leader t2.leader);
    raftIndex = (merge_raftIndex t1.raftIndex t2.raftIndex);
    raftTerm = (merge_raftTerm t1.raftTerm t2.raftTerm);
    raftAppliedIndex = (merge_raftAppliedIndex t1.raftAppliedIndex t2.raftAppliedIndex);
    errors = (merge_errors t1.errors t2.errors);
    dbSizeInUse = (merge_dbSizeInUse t1.dbSizeInUse t2.dbSizeInUse);
    isLearner = (merge_isLearner t1.isLearner t2.isLearner);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "version", "version"), string, ({||})) ^:: basic ((3, "dbSize", "dbSize"), int64_int, (0)) ^:: basic ((4, "leader", "leader"), uint64_int, (0)) ^:: basic ((5, "raftIndex", "raftIndex"), uint64_int, (0)) ^:: basic ((6, "raftTerm", "raftTerm"), uint64_int, (0)) ^:: basic ((7, "raftAppliedIndex", "raftAppliedIndex"), uint64_int, (0)) ^:: repeated ((8, "errors", "errors"), string, not_packed) ^:: basic ((9, "dbSizeInUse", "dbSizeInUse"), int64_int, (0)) ^:: basic ((10, "isLearner", "isLearner"), bool, (false)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; version; dbSize; leader; raftIndex; raftTerm; raftAppliedIndex; errors; dbSizeInUse; isLearner } -> serialize writer header version dbSize leader raftIndex raftTerm raftAppliedIndex errors dbSizeInUse isLearner

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header version dbSize leader raftIndex raftTerm raftAppliedIndex errors dbSizeInUse isLearner = { header; version; dbSize; leader; raftIndex; raftTerm; raftAppliedIndex; errors; dbSizeInUse; isLearner } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; version; dbSize; leader; raftIndex; raftTerm; raftAppliedIndex; errors; dbSizeInUse; isLearner } -> serialize header version dbSize leader raftIndex raftTerm raftAppliedIndex errors dbSizeInUse isLearner
    let from_json_exn =
      let constructor header version dbSize leader raftIndex raftTerm raftAppliedIndex errors dbSizeInUse isLearner = { header; version; dbSize; leader; raftIndex; raftTerm; raftAppliedIndex; errors; dbSizeInUse; isLearner } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthEnableRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthEnableRequest
    let name () = ".etcdserverpb.AuthEnableRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthDisableRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthDisableRequest
    let name () = ".etcdserverpb.AuthDisableRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthStatusRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthStatusRequest
    let name () = ".etcdserverpb.AuthStatusRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthenticateRequest : sig
    type t = {
    name: string;
    password: string;
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?password:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?password:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthenticateRequest
    let name () = ".etcdserverpb.AuthenticateRequest"
    type t = {
    name: string;
    password: string;
    }[@@deriving show { with_path = false}]
    type make_t = ?name:string -> ?password:string -> unit -> t
    let make ?(name = {||}) ?(password = {||}) () = { name; password }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    let merge_password = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "password", "password"), string, ({||})) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    password = (merge_password t1.password t2.password);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "password", "password"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; password } -> serialize writer name password

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name password = { name; password } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; password } -> serialize name password
    let from_json_exn =
      let constructor name password = { name; password } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserAddRequest : sig
    type t = {
    name: string;
    password: string;
    options: Imported'modules.Auth.Authpb.UserAddOptions.t option;
    hashedPassword: string;
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?password:string -> ?options:Imported'modules.Auth.Authpb.UserAddOptions.t -> ?hashedPassword:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?password:string -> ?options:Imported'modules.Auth.Authpb.UserAddOptions.t -> ?hashedPassword:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserAddRequest
    let name () = ".etcdserverpb.AuthUserAddRequest"
    type t = {
    name: string;
    password: string;
    options: Imported'modules.Auth.Authpb.UserAddOptions.t option;
    hashedPassword: string;
    }[@@deriving show { with_path = false}]
    type make_t = ?name:string -> ?password:string -> ?options:Imported'modules.Auth.Authpb.UserAddOptions.t -> ?hashedPassword:string -> unit -> t
    let make ?(name = {||}) ?(password = {||}) ?options ?(hashedPassword = {||}) () = { name; password; options; hashedPassword }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    let merge_password = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "password", "password"), string, ({||})) ) in
    let merge_options = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "options", "options"), (message (module Imported'modules.Auth.Authpb.UserAddOptions))) ) in
    let merge_hashedPassword = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "hashedPassword", "hashedPassword"), string, ({||})) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    password = (merge_password t1.password t2.password);
    options = (merge_options t1.options t2.options);
    hashedPassword = (merge_hashedPassword t1.hashedPassword t2.hashedPassword);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "password", "password"), string, ({||})) ^:: basic_opt ((3, "options", "options"), (message (module Imported'modules.Auth.Authpb.UserAddOptions))) ^:: basic ((4, "hashedPassword", "hashedPassword"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; password; options; hashedPassword } -> serialize writer name password options hashedPassword

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name password options hashedPassword = { name; password; options; hashedPassword } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; password; options; hashedPassword } -> serialize name password options hashedPassword
    let from_json_exn =
      let constructor name password options hashedPassword = { name; password; options; hashedPassword } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserGetRequest : sig
    type t = (string)[@@deriving show { with_path = false}]
    val make: ?name:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserGetRequest
    let name () = ".etcdserverpb.AuthUserGetRequest"
    type t = (string)[@@deriving show { with_path = false}]
    type make_t = ?name:string -> unit -> t
    let make ?(name = {||}) () = (name)
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    fun (t1_name) (t2_name) -> merge_name t1_name t2_name
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (name) -> serialize writer name

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name = (name) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (name) -> serialize name
    let from_json_exn =
      let constructor name = (name) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserDeleteRequest : sig
    type t = (string)
    (**
    name is the name of the user to delete.
    *)
    [@@deriving show { with_path = false}]
    val make: ?name:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserDeleteRequest
    let name () = ".etcdserverpb.AuthUserDeleteRequest"
    type t = (string)
    (**
    name is the name of the user to delete.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?name:string -> unit -> t
    let make ?(name = {||}) () = (name)
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    fun (t1_name) (t2_name) -> merge_name t1_name t2_name
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (name) -> serialize writer name

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name = (name) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (name) -> serialize name
    let from_json_exn =
      let constructor name = (name) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserChangePasswordRequest : sig
    type t = {
    name: string;(** name is the name of the user whose password is being changed. *)
    password: string;(** password is the new password for the user. Note that this field will be removed in the API layer. *)
    hashedPassword: string;(** hashedPassword is the new password for the user. Note that this field will be initialized in the API layer. *)
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?password:string -> ?hashedPassword:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?password:string -> ?hashedPassword:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserChangePasswordRequest
    let name () = ".etcdserverpb.AuthUserChangePasswordRequest"
    type t = {
    name: string;(** name is the name of the user whose password is being changed. *)
    password: string;(** password is the new password for the user. Note that this field will be removed in the API layer. *)
    hashedPassword: string;(** hashedPassword is the new password for the user. Note that this field will be initialized in the API layer. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?name:string -> ?password:string -> ?hashedPassword:string -> unit -> t
    let make ?(name = {||}) ?(password = {||}) ?(hashedPassword = {||}) () = { name; password; hashedPassword }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    let merge_password = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "password", "password"), string, ({||})) ) in
    let merge_hashedPassword = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "hashedPassword", "hashedPassword"), string, ({||})) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    password = (merge_password t1.password t2.password);
    hashedPassword = (merge_hashedPassword t1.hashedPassword t2.hashedPassword);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "password", "password"), string, ({||})) ^:: basic ((3, "hashedPassword", "hashedPassword"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; password; hashedPassword } -> serialize writer name password hashedPassword

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name password hashedPassword = { name; password; hashedPassword } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; password; hashedPassword } -> serialize name password hashedPassword
    let from_json_exn =
      let constructor name password hashedPassword = { name; password; hashedPassword } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserGrantRoleRequest : sig
    type t = {
    user: string;(** user is the name of the user which should be granted a given role. *)
    role: string;(** role is the name of the role to grant to the user. *)
    }[@@deriving show { with_path = false}]
    val make: ?user:string -> ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?user:string -> ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserGrantRoleRequest
    let name () = ".etcdserverpb.AuthUserGrantRoleRequest"
    type t = {
    user: string;(** user is the name of the user which should be granted a given role. *)
    role: string;(** role is the name of the role to grant to the user. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?user:string -> ?role:string -> unit -> t
    let make ?(user = {||}) ?(role = {||}) () = { user; role }
    let merge =
    let merge_user = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "user", "user"), string, ({||})) ) in
    let merge_role = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "role", "role"), string, ({||})) ) in
    fun t1 t2 -> {
    user = (merge_user t1.user t2.user);
    role = (merge_role t1.role t2.role);
     }
    let spec () = Runtime'.Spec.( basic ((1, "user", "user"), string, ({||})) ^:: basic ((2, "role", "role"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { user; role } -> serialize writer user role

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor user role = { user; role } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { user; role } -> serialize user role
    let from_json_exn =
      let constructor user role = { user; role } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserRevokeRoleRequest : sig
    type t = {
    name: string;
    role: string;
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserRevokeRoleRequest
    let name () = ".etcdserverpb.AuthUserRevokeRoleRequest"
    type t = {
    name: string;
    role: string;
    }[@@deriving show { with_path = false}]
    type make_t = ?name:string -> ?role:string -> unit -> t
    let make ?(name = {||}) ?(role = {||}) () = { name; role }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    let merge_role = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "role", "role"), string, ({||})) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    role = (merge_role t1.role t2.role);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "role", "role"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; role } -> serialize writer name role

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name role = { name; role } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; role } -> serialize name role
    let from_json_exn =
      let constructor name role = { name; role } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleAddRequest : sig
    type t = (string)
    (**
    name is the name of the role to add to the authentication system.
    *)
    [@@deriving show { with_path = false}]
    val make: ?name:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleAddRequest
    let name () = ".etcdserverpb.AuthRoleAddRequest"
    type t = (string)
    (**
    name is the name of the role to add to the authentication system.
    *)
    [@@deriving show { with_path = false}]
    type make_t = ?name:string -> unit -> t
    let make ?(name = {||}) () = (name)
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    fun (t1_name) (t2_name) -> merge_name t1_name t2_name
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (name) -> serialize writer name

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name = (name) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (name) -> serialize name
    let from_json_exn =
      let constructor name = (name) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleGetRequest : sig
    type t = (string)[@@deriving show { with_path = false}]
    val make: ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleGetRequest
    let name () = ".etcdserverpb.AuthRoleGetRequest"
    type t = (string)[@@deriving show { with_path = false}]
    type make_t = ?role:string -> unit -> t
    let make ?(role = {||}) () = (role)
    let merge =
    let merge_role = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "role", "role"), string, ({||})) ) in
    fun (t1_role) (t2_role) -> merge_role t1_role t2_role
    let spec () = Runtime'.Spec.( basic ((1, "role", "role"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (role) -> serialize writer role

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor role = (role) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (role) -> serialize role
    let from_json_exn =
      let constructor role = (role) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserListRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserListRequest
    let name () = ".etcdserverpb.AuthUserListRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleListRequest : sig
    type t = unit[@@deriving show { with_path = false}]
    val make: unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleListRequest
    let name () = ".etcdserverpb.AuthRoleListRequest"
    type t = unit[@@deriving show { with_path = false}]
    type make_t = unit -> t
    let make () = ()
    let merge =

    fun () () -> ()
    let spec () = Runtime'.Spec.( nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer () -> serialize writer

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun () -> serialize
    let from_json_exn =
      let constructor  = () in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleDeleteRequest : sig
    type t = (string)[@@deriving show { with_path = false}]
    val make: ?role:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?role:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleDeleteRequest
    let name () = ".etcdserverpb.AuthRoleDeleteRequest"
    type t = (string)[@@deriving show { with_path = false}]
    type make_t = ?role:string -> unit -> t
    let make ?(role = {||}) () = (role)
    let merge =
    let merge_role = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "role", "role"), string, ({||})) ) in
    fun (t1_role) (t2_role) -> merge_role t1_role t2_role
    let spec () = Runtime'.Spec.( basic ((1, "role", "role"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (role) -> serialize writer role

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor role = (role) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (role) -> serialize role
    let from_json_exn =
      let constructor role = (role) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleGrantPermissionRequest : sig
    type t = {
    name: string;(** name is the name of the role which will be granted the permission. *)
    perm: Imported'modules.Auth.Authpb.Permission.t option;(** perm is the permission to grant to the role. *)
    }[@@deriving show { with_path = false}]
    val make: ?name:string -> ?perm:Imported'modules.Auth.Authpb.Permission.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?name:string -> ?perm:Imported'modules.Auth.Authpb.Permission.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleGrantPermissionRequest
    let name () = ".etcdserverpb.AuthRoleGrantPermissionRequest"
    type t = {
    name: string;(** name is the name of the role which will be granted the permission. *)
    perm: Imported'modules.Auth.Authpb.Permission.t option;(** perm is the permission to grant to the role. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?name:string -> ?perm:Imported'modules.Auth.Authpb.Permission.t -> unit -> t
    let make ?(name = {||}) ?perm () = { name; perm }
    let merge =
    let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
    let merge_perm = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "perm", "perm"), (message (module Imported'modules.Auth.Authpb.Permission))) ) in
    fun t1 t2 -> {
    name = (merge_name t1.name t2.name);
    perm = (merge_perm t1.perm t2.perm);
     }
    let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic_opt ((2, "perm", "perm"), (message (module Imported'modules.Auth.Authpb.Permission))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { name; perm } -> serialize writer name perm

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor name perm = { name; perm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { name; perm } -> serialize name perm
    let from_json_exn =
      let constructor name perm = { name; perm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleRevokePermissionRequest : sig
    type t = {
    role: string;
    key: bytes;
    range_end: bytes;
    }[@@deriving show { with_path = false}]
    val make: ?role:string -> ?key:bytes -> ?range_end:bytes -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?role:string -> ?key:bytes -> ?range_end:bytes -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleRevokePermissionRequest
    let name () = ".etcdserverpb.AuthRoleRevokePermissionRequest"
    type t = {
    role: string;
    key: bytes;
    range_end: bytes;
    }[@@deriving show { with_path = false}]
    type make_t = ?role:string -> ?key:bytes -> ?range_end:bytes -> unit -> t
    let make ?(role = {||}) ?(key = (Bytes.of_string {||})) ?(range_end = (Bytes.of_string {||})) () = { role; key; range_end }
    let merge =
    let merge_role = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "role", "role"), string, ({||})) ) in
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_range_end = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ) in
    fun t1 t2 -> {
    role = (merge_role t1.role t2.role);
    key = (merge_key t1.key t2.key);
    range_end = (merge_range_end t1.range_end t2.range_end);
     }
    let spec () = Runtime'.Spec.( basic ((1, "role", "role"), string, ({||})) ^:: basic ((2, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((3, "range_end", "rangeEnd"), bytes, ((Bytes.of_string {||}))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { role; key; range_end } -> serialize writer role key range_end

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor role key range_end = { role; key; range_end } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { role; key; range_end } -> serialize role key range_end
    let from_json_exn =
      let constructor role key range_end = { role; key; range_end } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthEnableResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthEnableResponse
    let name () = ".etcdserverpb.AuthEnableResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthDisableResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthDisableResponse
    let name () = ".etcdserverpb.AuthDisableResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthStatusResponse : sig
    type t = {
    header: ResponseHeader.t option;
    enabled: bool;
    authRevision: int;(** authRevision is the current revision of auth store *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?enabled:bool -> ?authRevision:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?enabled:bool -> ?authRevision:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthStatusResponse
    let name () = ".etcdserverpb.AuthStatusResponse"
    type t = {
    header: ResponseHeader.t option;
    enabled: bool;
    authRevision: int;(** authRevision is the current revision of auth store *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?enabled:bool -> ?authRevision:int -> unit -> t
    let make ?header ?(enabled = false) ?(authRevision = 0) () = { header; enabled; authRevision }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_enabled = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "enabled", "enabled"), bool, (false)) ) in
    let merge_authRevision = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "authRevision", "authRevision"), uint64_int, (0)) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    enabled = (merge_enabled t1.enabled t2.enabled);
    authRevision = (merge_authRevision t1.authRevision t2.authRevision);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "enabled", "enabled"), bool, (false)) ^:: basic ((3, "authRevision", "authRevision"), uint64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; enabled; authRevision } -> serialize writer header enabled authRevision

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header enabled authRevision = { header; enabled; authRevision } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; enabled; authRevision } -> serialize header enabled authRevision
    let from_json_exn =
      let constructor header enabled authRevision = { header; enabled; authRevision } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthenticateResponse : sig
    type t = {
    header: ResponseHeader.t option;
    token: string;(** token is an authorized token that can be used in succeeding RPCs *)
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?token:string -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?token:string -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthenticateResponse
    let name () = ".etcdserverpb.AuthenticateResponse"
    type t = {
    header: ResponseHeader.t option;
    token: string;(** token is an authorized token that can be used in succeeding RPCs *)
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?token:string -> unit -> t
    let make ?header ?(token = {||}) () = { header; token }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_token = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "token", "token"), string, ({||})) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    token = (merge_token t1.token t2.token);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: basic ((2, "token", "token"), string, ({||})) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; token } -> serialize writer header token

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header token = { header; token } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; token } -> serialize header token
    let from_json_exn =
      let constructor header token = { header; token } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserAddResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserAddResponse
    let name () = ".etcdserverpb.AuthUserAddResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserGetResponse : sig
    type t = {
    header: ResponseHeader.t option;
    roles: string list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserGetResponse
    let name () = ".etcdserverpb.AuthUserGetResponse"
    type t = {
    header: ResponseHeader.t option;
    roles: string list;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    let make ?header ?(roles = []) () = { header; roles }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_roles = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "roles", "roles"), string, not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    roles = (merge_roles t1.roles t2.roles);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "roles", "roles"), string, not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; roles } -> serialize writer header roles

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header roles = { header; roles } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; roles } -> serialize header roles
    let from_json_exn =
      let constructor header roles = { header; roles } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserDeleteResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserDeleteResponse
    let name () = ".etcdserverpb.AuthUserDeleteResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserChangePasswordResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserChangePasswordResponse
    let name () = ".etcdserverpb.AuthUserChangePasswordResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserGrantRoleResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserGrantRoleResponse
    let name () = ".etcdserverpb.AuthUserGrantRoleResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserRevokeRoleResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserRevokeRoleResponse
    let name () = ".etcdserverpb.AuthUserRevokeRoleResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleAddResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleAddResponse
    let name () = ".etcdserverpb.AuthRoleAddResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleGetResponse : sig
    type t = {
    header: ResponseHeader.t option;
    perm: Imported'modules.Auth.Authpb.Permission.t list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?perm:Imported'modules.Auth.Authpb.Permission.t list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?perm:Imported'modules.Auth.Authpb.Permission.t list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleGetResponse
    let name () = ".etcdserverpb.AuthRoleGetResponse"
    type t = {
    header: ResponseHeader.t option;
    perm: Imported'modules.Auth.Authpb.Permission.t list;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?perm:Imported'modules.Auth.Authpb.Permission.t list -> unit -> t
    let make ?header ?(perm = []) () = { header; perm }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_perm = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "perm", "perm"), (message (module Imported'modules.Auth.Authpb.Permission)), not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    perm = (merge_perm t1.perm t2.perm);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "perm", "perm"), (message (module Imported'modules.Auth.Authpb.Permission)), not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; perm } -> serialize writer header perm

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header perm = { header; perm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; perm } -> serialize header perm
    let from_json_exn =
      let constructor header perm = { header; perm } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleListResponse : sig
    type t = {
    header: ResponseHeader.t option;
    roles: string list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleListResponse
    let name () = ".etcdserverpb.AuthRoleListResponse"
    type t = {
    header: ResponseHeader.t option;
    roles: string list;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?roles:string list -> unit -> t
    let make ?header ?(roles = []) () = { header; roles }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_roles = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "roles", "roles"), string, not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    roles = (merge_roles t1.roles t2.roles);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "roles", "roles"), string, not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; roles } -> serialize writer header roles

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header roles = { header; roles } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; roles } -> serialize header roles
    let from_json_exn =
      let constructor header roles = { header; roles } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthUserListResponse : sig
    type t = {
    header: ResponseHeader.t option;
    users: string list;
    }[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> ?users:string list -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> ?users:string list -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthUserListResponse
    let name () = ".etcdserverpb.AuthUserListResponse"
    type t = {
    header: ResponseHeader.t option;
    users: string list;
    }[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> ?users:string list -> unit -> t
    let make ?header ?(users = []) () = { header; users }
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    let merge_users = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "users", "users"), string, not_packed) ) in
    fun t1 t2 -> {
    header = (merge_header t1.header t2.header);
    users = (merge_users t1.users t2.users);
     }
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: repeated ((2, "users", "users"), string, not_packed) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { header; users } -> serialize writer header users

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header users = { header; users } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { header; users } -> serialize header users
    let from_json_exn =
      let constructor header users = { header; users } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleDeleteResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleDeleteResponse
    let name () = ".etcdserverpb.AuthRoleDeleteResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleGrantPermissionResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleGrantPermissionResponse
    let name () = ".etcdserverpb.AuthRoleGrantPermissionResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and AuthRoleRevokePermissionResponse : sig
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    val make: ?header:ResponseHeader.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?header:ResponseHeader.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = AuthRoleRevokePermissionResponse
    let name () = ".etcdserverpb.AuthRoleRevokePermissionResponse"
    type t = (ResponseHeader.t option)[@@deriving show { with_path = false}]
    type make_t = ?header:ResponseHeader.t -> unit -> t
    let make ?header () = (header)
    let merge =
    let merge_header = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ) in
    fun (t1_header) (t2_header) -> merge_header t1_header t2_header
    let spec () = Runtime'.Spec.( basic_opt ((1, "header", "header"), (message (module ResponseHeader))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer (header) -> serialize writer header

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun (header) -> serialize header
    let from_json_exn =
      let constructor header = (header) in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  module KV = struct
    module Range = struct
      let package_name = Some "etcdserverpb"
      let service_name = "KV"
      let method_name = "Range"
      let name = "/etcdserverpb.KV/Range"
      module Request = RangeRequest
      module Response = RangeResponse
    end
    let range : (module Runtime'.Spec.Message with type t = RangeRequest.t) * (module Runtime'.Spec.Message with type t = RangeResponse.t) =
      (module RangeRequest : Runtime'.Spec.Message with type t = RangeRequest.t ),
      (module RangeResponse : Runtime'.Spec.Message with type t = RangeResponse.t )

    module Put = struct
      let package_name = Some "etcdserverpb"
      let service_name = "KV"
      let method_name = "Put"
      let name = "/etcdserverpb.KV/Put"
      module Request = PutRequest
      module Response = PutResponse
    end
    let put : (module Runtime'.Spec.Message with type t = PutRequest.t) * (module Runtime'.Spec.Message with type t = PutResponse.t) =
      (module PutRequest : Runtime'.Spec.Message with type t = PutRequest.t ),
      (module PutResponse : Runtime'.Spec.Message with type t = PutResponse.t )

    module DeleteRange = struct
      let package_name = Some "etcdserverpb"
      let service_name = "KV"
      let method_name = "DeleteRange"
      let name = "/etcdserverpb.KV/DeleteRange"
      module Request = DeleteRangeRequest
      module Response = DeleteRangeResponse
    end
    let deleteRange : (module Runtime'.Spec.Message with type t = DeleteRangeRequest.t) * (module Runtime'.Spec.Message with type t = DeleteRangeResponse.t) =
      (module DeleteRangeRequest : Runtime'.Spec.Message with type t = DeleteRangeRequest.t ),
      (module DeleteRangeResponse : Runtime'.Spec.Message with type t = DeleteRangeResponse.t )

    module Txn = struct
      let package_name = Some "etcdserverpb"
      let service_name = "KV"
      let method_name = "Txn"
      let name = "/etcdserverpb.KV/Txn"
      module Request = TxnRequest
      module Response = TxnResponse
    end
    let txn : (module Runtime'.Spec.Message with type t = TxnRequest.t) * (module Runtime'.Spec.Message with type t = TxnResponse.t) =
      (module TxnRequest : Runtime'.Spec.Message with type t = TxnRequest.t ),
      (module TxnResponse : Runtime'.Spec.Message with type t = TxnResponse.t )

    module Compact = struct
      let package_name = Some "etcdserverpb"
      let service_name = "KV"
      let method_name = "Compact"
      let name = "/etcdserverpb.KV/Compact"
      module Request = CompactionRequest
      module Response = CompactionResponse
    end
    let compact : (module Runtime'.Spec.Message with type t = CompactionRequest.t) * (module Runtime'.Spec.Message with type t = CompactionResponse.t) =
      (module CompactionRequest : Runtime'.Spec.Message with type t = CompactionRequest.t ),
      (module CompactionResponse : Runtime'.Spec.Message with type t = CompactionResponse.t )

  end
  module Watch = struct
    module Watch = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Watch"
      let method_name = "Watch"
      let name = "/etcdserverpb.Watch/Watch"
      module Request = WatchRequest
      module Response = WatchResponse
    end
    let watch : (module Runtime'.Spec.Message with type t = WatchRequest.t) * (module Runtime'.Spec.Message with type t = WatchResponse.t) =
      (module WatchRequest : Runtime'.Spec.Message with type t = WatchRequest.t ),
      (module WatchResponse : Runtime'.Spec.Message with type t = WatchResponse.t )

  end
  module Lease = struct
    module LeaseGrant = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Lease"
      let method_name = "LeaseGrant"
      let name = "/etcdserverpb.Lease/LeaseGrant"
      module Request = LeaseGrantRequest
      module Response = LeaseGrantResponse
    end
    let leaseGrant : (module Runtime'.Spec.Message with type t = LeaseGrantRequest.t) * (module Runtime'.Spec.Message with type t = LeaseGrantResponse.t) =
      (module LeaseGrantRequest : Runtime'.Spec.Message with type t = LeaseGrantRequest.t ),
      (module LeaseGrantResponse : Runtime'.Spec.Message with type t = LeaseGrantResponse.t )

    module LeaseRevoke = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Lease"
      let method_name = "LeaseRevoke"
      let name = "/etcdserverpb.Lease/LeaseRevoke"
      module Request = LeaseRevokeRequest
      module Response = LeaseRevokeResponse
    end
    let leaseRevoke : (module Runtime'.Spec.Message with type t = LeaseRevokeRequest.t) * (module Runtime'.Spec.Message with type t = LeaseRevokeResponse.t) =
      (module LeaseRevokeRequest : Runtime'.Spec.Message with type t = LeaseRevokeRequest.t ),
      (module LeaseRevokeResponse : Runtime'.Spec.Message with type t = LeaseRevokeResponse.t )

    module LeaseKeepAlive = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Lease"
      let method_name = "LeaseKeepAlive"
      let name = "/etcdserverpb.Lease/LeaseKeepAlive"
      module Request = LeaseKeepAliveRequest
      module Response = LeaseKeepAliveResponse
    end
    let leaseKeepAlive : (module Runtime'.Spec.Message with type t = LeaseKeepAliveRequest.t) * (module Runtime'.Spec.Message with type t = LeaseKeepAliveResponse.t) =
      (module LeaseKeepAliveRequest : Runtime'.Spec.Message with type t = LeaseKeepAliveRequest.t ),
      (module LeaseKeepAliveResponse : Runtime'.Spec.Message with type t = LeaseKeepAliveResponse.t )

    module LeaseTimeToLive = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Lease"
      let method_name = "LeaseTimeToLive"
      let name = "/etcdserverpb.Lease/LeaseTimeToLive"
      module Request = LeaseTimeToLiveRequest
      module Response = LeaseTimeToLiveResponse
    end
    let leaseTimeToLive : (module Runtime'.Spec.Message with type t = LeaseTimeToLiveRequest.t) * (module Runtime'.Spec.Message with type t = LeaseTimeToLiveResponse.t) =
      (module LeaseTimeToLiveRequest : Runtime'.Spec.Message with type t = LeaseTimeToLiveRequest.t ),
      (module LeaseTimeToLiveResponse : Runtime'.Spec.Message with type t = LeaseTimeToLiveResponse.t )

    module LeaseLeases = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Lease"
      let method_name = "LeaseLeases"
      let name = "/etcdserverpb.Lease/LeaseLeases"
      module Request = LeaseLeasesRequest
      module Response = LeaseLeasesResponse
    end
    let leaseLeases : (module Runtime'.Spec.Message with type t = LeaseLeasesRequest.t) * (module Runtime'.Spec.Message with type t = LeaseLeasesResponse.t) =
      (module LeaseLeasesRequest : Runtime'.Spec.Message with type t = LeaseLeasesRequest.t ),
      (module LeaseLeasesResponse : Runtime'.Spec.Message with type t = LeaseLeasesResponse.t )

  end
  module Cluster = struct
    module MemberAdd = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Cluster"
      let method_name = "MemberAdd"
      let name = "/etcdserverpb.Cluster/MemberAdd"
      module Request = MemberAddRequest
      module Response = MemberAddResponse
    end
    let memberAdd : (module Runtime'.Spec.Message with type t = MemberAddRequest.t) * (module Runtime'.Spec.Message with type t = MemberAddResponse.t) =
      (module MemberAddRequest : Runtime'.Spec.Message with type t = MemberAddRequest.t ),
      (module MemberAddResponse : Runtime'.Spec.Message with type t = MemberAddResponse.t )

    module MemberRemove = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Cluster"
      let method_name = "MemberRemove"
      let name = "/etcdserverpb.Cluster/MemberRemove"
      module Request = MemberRemoveRequest
      module Response = MemberRemoveResponse
    end
    let memberRemove : (module Runtime'.Spec.Message with type t = MemberRemoveRequest.t) * (module Runtime'.Spec.Message with type t = MemberRemoveResponse.t) =
      (module MemberRemoveRequest : Runtime'.Spec.Message with type t = MemberRemoveRequest.t ),
      (module MemberRemoveResponse : Runtime'.Spec.Message with type t = MemberRemoveResponse.t )

    module MemberUpdate = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Cluster"
      let method_name = "MemberUpdate"
      let name = "/etcdserverpb.Cluster/MemberUpdate"
      module Request = MemberUpdateRequest
      module Response = MemberUpdateResponse
    end
    let memberUpdate : (module Runtime'.Spec.Message with type t = MemberUpdateRequest.t) * (module Runtime'.Spec.Message with type t = MemberUpdateResponse.t) =
      (module MemberUpdateRequest : Runtime'.Spec.Message with type t = MemberUpdateRequest.t ),
      (module MemberUpdateResponse : Runtime'.Spec.Message with type t = MemberUpdateResponse.t )

    module MemberList = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Cluster"
      let method_name = "MemberList"
      let name = "/etcdserverpb.Cluster/MemberList"
      module Request = MemberListRequest
      module Response = MemberListResponse
    end
    let memberList : (module Runtime'.Spec.Message with type t = MemberListRequest.t) * (module Runtime'.Spec.Message with type t = MemberListResponse.t) =
      (module MemberListRequest : Runtime'.Spec.Message with type t = MemberListRequest.t ),
      (module MemberListResponse : Runtime'.Spec.Message with type t = MemberListResponse.t )

    module MemberPromote = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Cluster"
      let method_name = "MemberPromote"
      let name = "/etcdserverpb.Cluster/MemberPromote"
      module Request = MemberPromoteRequest
      module Response = MemberPromoteResponse
    end
    let memberPromote : (module Runtime'.Spec.Message with type t = MemberPromoteRequest.t) * (module Runtime'.Spec.Message with type t = MemberPromoteResponse.t) =
      (module MemberPromoteRequest : Runtime'.Spec.Message with type t = MemberPromoteRequest.t ),
      (module MemberPromoteResponse : Runtime'.Spec.Message with type t = MemberPromoteResponse.t )

  end
  module Maintenance = struct
    module Alarm = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "Alarm"
      let name = "/etcdserverpb.Maintenance/Alarm"
      module Request = AlarmRequest
      module Response = AlarmResponse
    end
    let alarm : (module Runtime'.Spec.Message with type t = AlarmRequest.t) * (module Runtime'.Spec.Message with type t = AlarmResponse.t) =
      (module AlarmRequest : Runtime'.Spec.Message with type t = AlarmRequest.t ),
      (module AlarmResponse : Runtime'.Spec.Message with type t = AlarmResponse.t )

    module Status = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "Status"
      let name = "/etcdserverpb.Maintenance/Status"
      module Request = StatusRequest
      module Response = StatusResponse
    end
    let status : (module Runtime'.Spec.Message with type t = StatusRequest.t) * (module Runtime'.Spec.Message with type t = StatusResponse.t) =
      (module StatusRequest : Runtime'.Spec.Message with type t = StatusRequest.t ),
      (module StatusResponse : Runtime'.Spec.Message with type t = StatusResponse.t )

    module Defragment = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "Defragment"
      let name = "/etcdserverpb.Maintenance/Defragment"
      module Request = DefragmentRequest
      module Response = DefragmentResponse
    end
    let defragment : (module Runtime'.Spec.Message with type t = DefragmentRequest.t) * (module Runtime'.Spec.Message with type t = DefragmentResponse.t) =
      (module DefragmentRequest : Runtime'.Spec.Message with type t = DefragmentRequest.t ),
      (module DefragmentResponse : Runtime'.Spec.Message with type t = DefragmentResponse.t )

    module Hash = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "Hash"
      let name = "/etcdserverpb.Maintenance/Hash"
      module Request = HashRequest
      module Response = HashResponse
    end
    let hash : (module Runtime'.Spec.Message with type t = HashRequest.t) * (module Runtime'.Spec.Message with type t = HashResponse.t) =
      (module HashRequest : Runtime'.Spec.Message with type t = HashRequest.t ),
      (module HashResponse : Runtime'.Spec.Message with type t = HashResponse.t )

    module HashKV = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "HashKV"
      let name = "/etcdserverpb.Maintenance/HashKV"
      module Request = HashKVRequest
      module Response = HashKVResponse
    end
    let hashKV : (module Runtime'.Spec.Message with type t = HashKVRequest.t) * (module Runtime'.Spec.Message with type t = HashKVResponse.t) =
      (module HashKVRequest : Runtime'.Spec.Message with type t = HashKVRequest.t ),
      (module HashKVResponse : Runtime'.Spec.Message with type t = HashKVResponse.t )

    module Snapshot = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "Snapshot"
      let name = "/etcdserverpb.Maintenance/Snapshot"
      module Request = SnapshotRequest
      module Response = SnapshotResponse
    end
    let snapshot : (module Runtime'.Spec.Message with type t = SnapshotRequest.t) * (module Runtime'.Spec.Message with type t = SnapshotResponse.t) =
      (module SnapshotRequest : Runtime'.Spec.Message with type t = SnapshotRequest.t ),
      (module SnapshotResponse : Runtime'.Spec.Message with type t = SnapshotResponse.t )

    module MoveLeader = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "MoveLeader"
      let name = "/etcdserverpb.Maintenance/MoveLeader"
      module Request = MoveLeaderRequest
      module Response = MoveLeaderResponse
    end
    let moveLeader : (module Runtime'.Spec.Message with type t = MoveLeaderRequest.t) * (module Runtime'.Spec.Message with type t = MoveLeaderResponse.t) =
      (module MoveLeaderRequest : Runtime'.Spec.Message with type t = MoveLeaderRequest.t ),
      (module MoveLeaderResponse : Runtime'.Spec.Message with type t = MoveLeaderResponse.t )

    module Downgrade = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Maintenance"
      let method_name = "Downgrade"
      let name = "/etcdserverpb.Maintenance/Downgrade"
      module Request = DowngradeRequest
      module Response = DowngradeResponse
    end
    let downgrade : (module Runtime'.Spec.Message with type t = DowngradeRequest.t) * (module Runtime'.Spec.Message with type t = DowngradeResponse.t) =
      (module DowngradeRequest : Runtime'.Spec.Message with type t = DowngradeRequest.t ),
      (module DowngradeResponse : Runtime'.Spec.Message with type t = DowngradeResponse.t )

  end
  module Auth = struct
    module AuthEnable = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "AuthEnable"
      let name = "/etcdserverpb.Auth/AuthEnable"
      module Request = AuthEnableRequest
      module Response = AuthEnableResponse
    end
    let authEnable : (module Runtime'.Spec.Message with type t = AuthEnableRequest.t) * (module Runtime'.Spec.Message with type t = AuthEnableResponse.t) =
      (module AuthEnableRequest : Runtime'.Spec.Message with type t = AuthEnableRequest.t ),
      (module AuthEnableResponse : Runtime'.Spec.Message with type t = AuthEnableResponse.t )

    module AuthDisable = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "AuthDisable"
      let name = "/etcdserverpb.Auth/AuthDisable"
      module Request = AuthDisableRequest
      module Response = AuthDisableResponse
    end
    let authDisable : (module Runtime'.Spec.Message with type t = AuthDisableRequest.t) * (module Runtime'.Spec.Message with type t = AuthDisableResponse.t) =
      (module AuthDisableRequest : Runtime'.Spec.Message with type t = AuthDisableRequest.t ),
      (module AuthDisableResponse : Runtime'.Spec.Message with type t = AuthDisableResponse.t )

    module AuthStatus = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "AuthStatus"
      let name = "/etcdserverpb.Auth/AuthStatus"
      module Request = AuthStatusRequest
      module Response = AuthStatusResponse
    end
    let authStatus : (module Runtime'.Spec.Message with type t = AuthStatusRequest.t) * (module Runtime'.Spec.Message with type t = AuthStatusResponse.t) =
      (module AuthStatusRequest : Runtime'.Spec.Message with type t = AuthStatusRequest.t ),
      (module AuthStatusResponse : Runtime'.Spec.Message with type t = AuthStatusResponse.t )

    module Authenticate = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "Authenticate"
      let name = "/etcdserverpb.Auth/Authenticate"
      module Request = AuthenticateRequest
      module Response = AuthenticateResponse
    end
    let authenticate : (module Runtime'.Spec.Message with type t = AuthenticateRequest.t) * (module Runtime'.Spec.Message with type t = AuthenticateResponse.t) =
      (module AuthenticateRequest : Runtime'.Spec.Message with type t = AuthenticateRequest.t ),
      (module AuthenticateResponse : Runtime'.Spec.Message with type t = AuthenticateResponse.t )

    module UserAdd = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserAdd"
      let name = "/etcdserverpb.Auth/UserAdd"
      module Request = AuthUserAddRequest
      module Response = AuthUserAddResponse
    end
    let userAdd : (module Runtime'.Spec.Message with type t = AuthUserAddRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserAddResponse.t) =
      (module AuthUserAddRequest : Runtime'.Spec.Message with type t = AuthUserAddRequest.t ),
      (module AuthUserAddResponse : Runtime'.Spec.Message with type t = AuthUserAddResponse.t )

    module UserGet = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserGet"
      let name = "/etcdserverpb.Auth/UserGet"
      module Request = AuthUserGetRequest
      module Response = AuthUserGetResponse
    end
    let userGet : (module Runtime'.Spec.Message with type t = AuthUserGetRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserGetResponse.t) =
      (module AuthUserGetRequest : Runtime'.Spec.Message with type t = AuthUserGetRequest.t ),
      (module AuthUserGetResponse : Runtime'.Spec.Message with type t = AuthUserGetResponse.t )

    module UserList = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserList"
      let name = "/etcdserverpb.Auth/UserList"
      module Request = AuthUserListRequest
      module Response = AuthUserListResponse
    end
    let userList : (module Runtime'.Spec.Message with type t = AuthUserListRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserListResponse.t) =
      (module AuthUserListRequest : Runtime'.Spec.Message with type t = AuthUserListRequest.t ),
      (module AuthUserListResponse : Runtime'.Spec.Message with type t = AuthUserListResponse.t )

    module UserDelete = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserDelete"
      let name = "/etcdserverpb.Auth/UserDelete"
      module Request = AuthUserDeleteRequest
      module Response = AuthUserDeleteResponse
    end
    let userDelete : (module Runtime'.Spec.Message with type t = AuthUserDeleteRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserDeleteResponse.t) =
      (module AuthUserDeleteRequest : Runtime'.Spec.Message with type t = AuthUserDeleteRequest.t ),
      (module AuthUserDeleteResponse : Runtime'.Spec.Message with type t = AuthUserDeleteResponse.t )

    module UserChangePassword = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserChangePassword"
      let name = "/etcdserverpb.Auth/UserChangePassword"
      module Request = AuthUserChangePasswordRequest
      module Response = AuthUserChangePasswordResponse
    end
    let userChangePassword : (module Runtime'.Spec.Message with type t = AuthUserChangePasswordRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserChangePasswordResponse.t) =
      (module AuthUserChangePasswordRequest : Runtime'.Spec.Message with type t = AuthUserChangePasswordRequest.t ),
      (module AuthUserChangePasswordResponse : Runtime'.Spec.Message with type t = AuthUserChangePasswordResponse.t )

    module UserGrantRole = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserGrantRole"
      let name = "/etcdserverpb.Auth/UserGrantRole"
      module Request = AuthUserGrantRoleRequest
      module Response = AuthUserGrantRoleResponse
    end
    let userGrantRole : (module Runtime'.Spec.Message with type t = AuthUserGrantRoleRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserGrantRoleResponse.t) =
      (module AuthUserGrantRoleRequest : Runtime'.Spec.Message with type t = AuthUserGrantRoleRequest.t ),
      (module AuthUserGrantRoleResponse : Runtime'.Spec.Message with type t = AuthUserGrantRoleResponse.t )

    module UserRevokeRole = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "UserRevokeRole"
      let name = "/etcdserverpb.Auth/UserRevokeRole"
      module Request = AuthUserRevokeRoleRequest
      module Response = AuthUserRevokeRoleResponse
    end
    let userRevokeRole : (module Runtime'.Spec.Message with type t = AuthUserRevokeRoleRequest.t) * (module Runtime'.Spec.Message with type t = AuthUserRevokeRoleResponse.t) =
      (module AuthUserRevokeRoleRequest : Runtime'.Spec.Message with type t = AuthUserRevokeRoleRequest.t ),
      (module AuthUserRevokeRoleResponse : Runtime'.Spec.Message with type t = AuthUserRevokeRoleResponse.t )

    module RoleAdd = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "RoleAdd"
      let name = "/etcdserverpb.Auth/RoleAdd"
      module Request = AuthRoleAddRequest
      module Response = AuthRoleAddResponse
    end
    let roleAdd : (module Runtime'.Spec.Message with type t = AuthRoleAddRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleAddResponse.t) =
      (module AuthRoleAddRequest : Runtime'.Spec.Message with type t = AuthRoleAddRequest.t ),
      (module AuthRoleAddResponse : Runtime'.Spec.Message with type t = AuthRoleAddResponse.t )

    module RoleGet = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "RoleGet"
      let name = "/etcdserverpb.Auth/RoleGet"
      module Request = AuthRoleGetRequest
      module Response = AuthRoleGetResponse
    end
    let roleGet : (module Runtime'.Spec.Message with type t = AuthRoleGetRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleGetResponse.t) =
      (module AuthRoleGetRequest : Runtime'.Spec.Message with type t = AuthRoleGetRequest.t ),
      (module AuthRoleGetResponse : Runtime'.Spec.Message with type t = AuthRoleGetResponse.t )

    module RoleList = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "RoleList"
      let name = "/etcdserverpb.Auth/RoleList"
      module Request = AuthRoleListRequest
      module Response = AuthRoleListResponse
    end
    let roleList : (module Runtime'.Spec.Message with type t = AuthRoleListRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleListResponse.t) =
      (module AuthRoleListRequest : Runtime'.Spec.Message with type t = AuthRoleListRequest.t ),
      (module AuthRoleListResponse : Runtime'.Spec.Message with type t = AuthRoleListResponse.t )

    module RoleDelete = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "RoleDelete"
      let name = "/etcdserverpb.Auth/RoleDelete"
      module Request = AuthRoleDeleteRequest
      module Response = AuthRoleDeleteResponse
    end
    let roleDelete : (module Runtime'.Spec.Message with type t = AuthRoleDeleteRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleDeleteResponse.t) =
      (module AuthRoleDeleteRequest : Runtime'.Spec.Message with type t = AuthRoleDeleteRequest.t ),
      (module AuthRoleDeleteResponse : Runtime'.Spec.Message with type t = AuthRoleDeleteResponse.t )

    module RoleGrantPermission = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "RoleGrantPermission"
      let name = "/etcdserverpb.Auth/RoleGrantPermission"
      module Request = AuthRoleGrantPermissionRequest
      module Response = AuthRoleGrantPermissionResponse
    end
    let roleGrantPermission : (module Runtime'.Spec.Message with type t = AuthRoleGrantPermissionRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleGrantPermissionResponse.t) =
      (module AuthRoleGrantPermissionRequest : Runtime'.Spec.Message with type t = AuthRoleGrantPermissionRequest.t ),
      (module AuthRoleGrantPermissionResponse : Runtime'.Spec.Message with type t = AuthRoleGrantPermissionResponse.t )

    module RoleRevokePermission = struct
      let package_name = Some "etcdserverpb"
      let service_name = "Auth"
      let method_name = "RoleRevokePermission"
      let name = "/etcdserverpb.Auth/RoleRevokePermission"
      module Request = AuthRoleRevokePermissionRequest
      module Response = AuthRoleRevokePermissionResponse
    end
    let roleRevokePermission : (module Runtime'.Spec.Message with type t = AuthRoleRevokePermissionRequest.t) * (module Runtime'.Spec.Message with type t = AuthRoleRevokePermissionResponse.t) =
      (module AuthRoleRevokePermissionRequest : Runtime'.Spec.Message with type t = AuthRoleRevokePermissionRequest.t ),
      (module AuthRoleRevokePermissionResponse : Runtime'.Spec.Message with type t = AuthRoleRevokePermissionResponse.t )

  end
end

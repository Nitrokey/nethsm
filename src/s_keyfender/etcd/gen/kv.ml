(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: etcd/api/mvccpb/kv.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show { with_path = false}]'
    opens=[Stubs; Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)

open Stubs [@@warning "-33"]
open Google_types [@@warning "-33"]
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
  module Gogo = Gogo
end
(**/**)
module rec Mvccpb : sig
  module rec KeyValue : sig
    type t = {
    key: bytes;(** key is the key in bytes. An empty key is not allowed. *)
    create_revision: int;(** create_revision is the revision of last creation on this key. *)
    mod_revision: int;(** mod_revision is the revision of last modification on this key. *)
    version: int;(** version is the version of the key. A deletion resets
    the version to zero and any modification of the key
    increases its version. *)
    value: bytes;(** value is the value held by the key, in bytes. *)
    lease: int;(** lease is the ID of the lease that attached to key.
    When the attached lease expires, the key will be deleted.
    If lease is 0, then no lease is attached to the key. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?create_revision:int -> ?mod_revision:int -> ?version:int -> ?value:bytes -> ?lease:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?create_revision:int -> ?mod_revision:int -> ?version:int -> ?value:bytes -> ?lease:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
  and Event : sig
    module rec EventType : sig
      type t =
        | PUT
        | DELETE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    type': EventType.t;(** type is the kind of event. If type is a PUT, it indicates
    new data has been stored to the key. If type is a DELETE,
    it indicates the key was deleted. *)
    kv: KeyValue.t option;(** kv holds the KeyValue for the event.
    A PUT event contains current kv pair.
    A PUT event with kv.Version=1 indicates the creation of a key.
    A DELETE/EXPIRE event contains the deleted key with
    its modification revision set to the revision of deletion. *)
    prev_kv: KeyValue.t option;(** prev_kv holds the key-value pair before the event happens. *)
    }[@@deriving show { with_path = false}]
    val make: ?type':EventType.t -> ?kv:KeyValue.t -> ?prev_kv:KeyValue.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?type':EventType.t -> ?kv:KeyValue.t -> ?prev_kv:KeyValue.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end
end = struct
  module rec KeyValue : sig
    type t = {
    key: bytes;(** key is the key in bytes. An empty key is not allowed. *)
    create_revision: int;(** create_revision is the revision of last creation on this key. *)
    mod_revision: int;(** mod_revision is the revision of last modification on this key. *)
    version: int;(** version is the version of the key. A deletion resets
    the version to zero and any modification of the key
    increases its version. *)
    value: bytes;(** value is the value held by the key, in bytes. *)
    lease: int;(** lease is the ID of the lease that attached to key.
    When the attached lease expires, the key will be deleted.
    If lease is 0, then no lease is attached to the key. *)
    }[@@deriving show { with_path = false}]
    val make: ?key:bytes -> ?create_revision:int -> ?mod_revision:int -> ?version:int -> ?value:bytes -> ?lease:int -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?key:bytes -> ?create_revision:int -> ?mod_revision:int -> ?version:int -> ?value:bytes -> ?lease:int -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = KeyValue
    let name () = ".mvccpb.KeyValue"
    type t = {
    key: bytes;(** key is the key in bytes. An empty key is not allowed. *)
    create_revision: int;(** create_revision is the revision of last creation on this key. *)
    mod_revision: int;(** mod_revision is the revision of last modification on this key. *)
    version: int;(** version is the version of the key. A deletion resets
    the version to zero and any modification of the key
    increases its version. *)
    value: bytes;(** value is the value held by the key, in bytes. *)
    lease: int;(** lease is the ID of the lease that attached to key.
    When the attached lease expires, the key will be deleted.
    If lease is 0, then no lease is attached to the key. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?key:bytes -> ?create_revision:int -> ?mod_revision:int -> ?version:int -> ?value:bytes -> ?lease:int -> unit -> t
    let make ?(key = (Bytes.of_string {||})) ?(create_revision = 0) ?(mod_revision = 0) ?(version = 0) ?(value = (Bytes.of_string {||})) ?(lease = 0) () = { key; create_revision; mod_revision; version; value; lease }
    let merge =
    let merge_key = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_create_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "create_revision", "createRevision"), int64_int, (0)) ) in
    let merge_mod_revision = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "mod_revision", "modRevision"), int64_int, (0)) ) in
    let merge_version = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "version", "version"), int64_int, (0)) ) in
    let merge_value = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "value", "value"), bytes, ((Bytes.of_string {||}))) ) in
    let merge_lease = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "lease", "lease"), int64_int, (0)) ) in
    fun t1 t2 -> {
    key = (merge_key t1.key t2.key);
    create_revision = (merge_create_revision t1.create_revision t2.create_revision);
    mod_revision = (merge_mod_revision t1.mod_revision t2.mod_revision);
    version = (merge_version t1.version t2.version);
    value = (merge_value t1.value t2.value);
    lease = (merge_lease t1.lease t2.lease);
     }
    let spec () = Runtime'.Spec.( basic ((1, "key", "key"), bytes, ((Bytes.of_string {||}))) ^:: basic ((2, "create_revision", "createRevision"), int64_int, (0)) ^:: basic ((3, "mod_revision", "modRevision"), int64_int, (0)) ^:: basic ((4, "version", "version"), int64_int, (0)) ^:: basic ((5, "value", "value"), bytes, ((Bytes.of_string {||}))) ^:: basic ((6, "lease", "lease"), int64_int, (0)) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { key; create_revision; mod_revision; version; value; lease } -> serialize writer key create_revision mod_revision version value lease

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor key create_revision mod_revision version value lease = { key; create_revision; mod_revision; version; value; lease } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { key; create_revision; mod_revision; version; value; lease } -> serialize key create_revision mod_revision version value lease
    let from_json_exn =
      let constructor key create_revision mod_revision version value lease = { key; create_revision; mod_revision; version; value; lease } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
  and Event : sig
    module rec EventType : sig
      type t =
        | PUT
        | DELETE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end
    type t = {
    type': EventType.t;(** type is the kind of event. If type is a PUT, it indicates
    new data has been stored to the key. If type is a DELETE,
    it indicates the key was deleted. *)
    kv: KeyValue.t option;(** kv holds the KeyValue for the event.
    A PUT event contains current kv pair.
    A PUT event with kv.Version=1 indicates the creation of a key.
    A DELETE/EXPIRE event contains the deleted key with
    its modification revision set to the revision of deletion. *)
    prev_kv: KeyValue.t option;(** prev_kv holds the key-value pair before the event happens. *)
    }[@@deriving show { with_path = false}]
    val make: ?type':EventType.t -> ?kv:KeyValue.t -> ?prev_kv:KeyValue.t -> unit -> t
    (** Helper function to generate a message using default values *)

    val to_proto: t -> Runtime'.Writer.t
    (** Serialize the message to binary format *)

    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from binary format *)

    val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
    (** Serialize to Json (compatible with Yojson.Basic.t) *)

    val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
    (** Deserialize from Json (compatible with Yojson.Basic.t) *)

    val name: unit -> string
    (** Fully qualified protobuf name of this message *)

    (**/**)
    type make_t = ?type':EventType.t -> ?kv:KeyValue.t -> ?prev_kv:KeyValue.t -> unit -> t
    val merge: t -> t -> t
    val to_proto': Runtime'.Writer.t -> t -> unit
    val from_proto_exn: Runtime'.Reader.t -> t
    val from_json_exn: Runtime'.Json.t -> t
    (**/**)
  end = struct
    module This'_ = Event
    module rec EventType : sig
      type t =
        | PUT
        | DELETE
      [@@deriving show { with_path = false}]
      val name: unit -> string
      (** Fully qualified protobuf name of this enum *)

      (**/**)
      val to_int: t -> int
      val from_int: int -> t Runtime'.Result.t
      val from_int_exn: int -> t
      val to_string: t -> string
      val from_string_exn: string -> t
      (**/**)
    end = struct
      module This'_ = EventType
      type t =
        | PUT
        | DELETE
      [@@deriving show { with_path = false}]
      let name () = ".mvccpb.Event.EventType"
      let to_int = function
        | PUT -> 0
        | DELETE -> 1
      let from_int_exn = function
        | 0 -> PUT
        | 1 -> DELETE
        | n -> Runtime'.Result.raise (`Unknown_enum_value n)
      let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
      let to_string = function
        | PUT -> "PUT"
        | DELETE -> "DELETE"
      let from_string_exn = function
        | "PUT" -> PUT
        | "DELETE" -> DELETE
        | s -> Runtime'.Result.raise (`Unknown_enum_name s)

    end
    let name () = ".mvccpb.Event"
    type t = {
    type': EventType.t;(** type is the kind of event. If type is a PUT, it indicates
    new data has been stored to the key. If type is a DELETE,
    it indicates the key was deleted. *)
    kv: KeyValue.t option;(** kv holds the KeyValue for the event.
    A PUT event contains current kv pair.
    A PUT event with kv.Version=1 indicates the creation of a key.
    A DELETE/EXPIRE event contains the deleted key with
    its modification revision set to the revision of deletion. *)
    prev_kv: KeyValue.t option;(** prev_kv holds the key-value pair before the event happens. *)
    }[@@deriving show { with_path = false}]
    type make_t = ?type':EventType.t -> ?kv:KeyValue.t -> ?prev_kv:KeyValue.t -> unit -> t
    let make ?(type' = EventType.from_int_exn 0) ?kv ?prev_kv () = { type'; kv; prev_kv }
    let merge =
    let merge_type' = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "type", "type"), (enum (module EventType)), (EventType.from_int_exn 0)) ) in
    let merge_kv = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "kv", "kv"), (message (module KeyValue))) ) in
    let merge_prev_kv = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "prev_kv", "prevKv"), (message (module KeyValue))) ) in
    fun t1 t2 -> {
    type' = (merge_type' t1.type' t2.type');
    kv = (merge_kv t1.kv t2.kv);
    prev_kv = (merge_prev_kv t1.prev_kv t2.prev_kv);
     }
    let spec () = Runtime'.Spec.( basic ((1, "type", "type"), (enum (module EventType)), (EventType.from_int_exn 0)) ^:: basic_opt ((2, "kv", "kv"), (message (module KeyValue))) ^:: basic_opt ((3, "prev_kv", "prevKv"), (message (module KeyValue))) ^:: nil )
    let to_proto' =
      let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
      fun writer { type'; kv; prev_kv } -> serialize writer type' kv prev_kv

    let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
    let from_proto_exn =
      let constructor type' kv prev_kv = { type'; kv; prev_kv } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
    let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
    let to_json options =
      let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
      fun { type'; kv; prev_kv } -> serialize type' kv prev_kv
    let from_json_exn =
      let constructor type' kv prev_kv = { type'; kv; prev_kv } in
      Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
    let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
  end
end

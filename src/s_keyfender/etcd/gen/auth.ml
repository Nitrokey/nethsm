(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: etcd/api/authpb/auth.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show { with_path = false}]'
    opens=[Stubs; Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Stubs [@@warning "-33"]
open Google_types [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Gogo = Gogo
end
(**/**)
module Authpb = struct
  module rec UserAddOptions : sig
    val name': unit -> string
    type t = bool [@@deriving show { with_path = false}]
    val make : ?no_password:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "auth.authpb.UserAddOptions"
    type t = bool[@@deriving show { with_path = false}]
    let make =
      fun ?no_password () -> 
      let no_password = match no_password with Some v -> v | None -> false in
      no_password
    
    let to_proto =
      let apply = fun ~f:f' no_password -> f' [] no_password in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions no_password -> no_password in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and User : sig
    val name': unit -> string
    type t = { name: bytes; password: bytes; roles: string list; options: UserAddOptions.t option } [@@deriving show { with_path = false}]
    val make : ?name:bytes -> ?password:bytes -> ?roles:string list -> ?options:UserAddOptions.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "auth.authpb.User"
    type t = { name: bytes; password: bytes; roles: string list; options: UserAddOptions.t option }[@@deriving show { with_path = false}]
    let make =
      fun ?name ?password ?roles ?options () -> 
      let name = match name with Some v -> v | None -> (Bytes.of_string {||}) in
      let password = match password with Some v -> v | None -> (Bytes.of_string {||}) in
      let roles = match roles with Some v -> v | None -> [] in
      { name; password; roles; options }
    
    let to_proto =
      let apply = fun ~f:f' { name; password; roles; options } -> f' [] name password roles options in
      let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: repeated (3, string, packed) ^:: basic_opt (4, (message (fun t -> UserAddOptions.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name password roles options -> { name; password; roles; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: basic (2, bytes, proto3) ^:: repeated (3, string, packed) ^:: basic_opt (4, (message (fun t -> UserAddOptions.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Permission : sig
    module rec Type : sig
      type t = READ | WRITE | READWRITE [@@deriving show { with_path = false}]
      val to_int: t -> int
      val from_int: int -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { permType: Permission.Type.t; key: bytes; range_end: bytes } [@@deriving show { with_path = false}]
    val make : ?permType:Permission.Type.t -> ?key:bytes -> ?range_end:bytes -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec Type : sig
      type t = READ | WRITE | READWRITE [@@deriving show { with_path = false}]
      val to_int: t -> int
      val from_int: int -> (t, [> Runtime'.Result.error]) result
    end = struct 
      type t = READ | WRITE | READWRITE [@@deriving show { with_path = false}]
      let to_int = function
        | READ -> 0
        | WRITE -> 1
        | READWRITE -> 2
      
      let from_int = function
        | 0 -> Ok READ
        | 1 -> Ok WRITE
        | 2 -> Ok READWRITE
        | n -> Error (`Unknown_enum_value n)
      
    end
    let name' () = "auth.authpb.Permission"
    type t = { permType: Permission.Type.t; key: bytes; range_end: bytes }[@@deriving show { with_path = false}]
    let make =
      fun ?permType ?key ?range_end () -> 
      let permType = match permType with Some v -> v | None -> (Permission.Type.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let key = match key with Some v -> v | None -> (Bytes.of_string {||}) in
      let range_end = match range_end with Some v -> v | None -> (Bytes.of_string {||}) in
      { permType; key; range_end }
    
    let to_proto =
      let apply = fun ~f:f' { permType; key; range_end } -> f' [] permType key range_end in
      let spec = Runtime'.Serialize.C.( basic (1, (enum Permission.Type.to_int), proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, bytes, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions permType key range_end -> { permType; key; range_end } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum Permission.Type.from_int), proto3) ^:: basic (2, bytes, proto3) ^:: basic (3, bytes, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Role : sig
    val name': unit -> string
    type t = { name: bytes; keyPermission: Permission.t list } [@@deriving show { with_path = false}]
    val make : ?name:bytes -> ?keyPermission:Permission.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "auth.authpb.Role"
    type t = { name: bytes; keyPermission: Permission.t list }[@@deriving show { with_path = false}]
    let make =
      fun ?name ?keyPermission () -> 
      let name = match name with Some v -> v | None -> (Bytes.of_string {||}) in
      let keyPermission = match keyPermission with Some v -> v | None -> [] in
      { name; keyPermission }
    
    let to_proto =
      let apply = fun ~f:f' { name; keyPermission } -> f' [] name keyPermission in
      let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: repeated (2, (message (fun t -> Permission.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name keyPermission -> { name; keyPermission } in
      let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: repeated (2, (message (fun t -> Permission.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end
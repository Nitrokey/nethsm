// tpm.go contains TPM-related functions used to provision/retrieve and delete
// the "Device ID" stored in the TPM.
package main

import (
	"fmt"
	"log"

	"github.com/google/go-tpm/tpm2"
	"github.com/google/go-tpm/tpmutil"
)

// nvIndexHandle is the NV Index we are manipulating.
// This value comes from the "Owner" range defined in Table 3 of "Registry
// of reserved TPM 2.0 handles and localities"
// [https://trustedcomputinggroup.org/wp-content/uploads/131011-Registry-of-reserved-TPM2-handles-and-localities.pdf].
var nvIndexHandle = tpmutil.Handle(0x01804e01)

// nvIndexPassword is the [Go: authString] for nvIndexHandle.
// This would only be used if the NV Index attributes AttrAuthRead or
// AttrAuthWrite were set.
var nvIndexPassword = ""

// nvIndexAttr are the [Go: attributes] for nvIndexHandle.
var nvIndexAttr = tpm2.AttrOwnerRead | tpm2.AttrOwnerWrite | tpm2.AttrWriteAll

// nvIndexSize is the size of the data stored by nvIndexHandle.
// XXX Document limitations here? Apparently size is limited by the TPMs
// "best" digest algo size?
// 0x20 -> 256 bits
var nvIndexSize = uint16(0x20)

// nvAuthHandle is the [Go: tpm2.HandleOwner, TSS: TPM_RH_OWNER] role
// handle for nvIndexHandle's hierarchy.
var nvAuthHandle = tpm2.HandleOwner

// nvAuthPassword is the [Go: authString or password] for nvAuthHandle.
// This is empty on an un-owned TPM.
var nvAuthPassword = ""

// tpmGetDeviceId returns the 256-bit "Device ID" of the NetHSM stored in the
// TPM NVRAM.
//
// tpmPath is the path to the TPM character device, normally "/dev/tpm0".
//
// THIS IMPLEMENTATION IS INTENTIONALLY INSECURE and does not protect the NV
// Index of the "Device ID" in any way.
//
// If the TPM is blank and un-owned, it will be provisioned with a random
// "Device ID".
func tpmGetDeviceId(tpmPath string) ([]byte, error) {
	tpm, err := tpm2.OpenTPM(tpmPath)
	if err != nil {
		return nil, fmt.Errorf("Error in OpenTPM(%s): %v", tpmPath, err)
	}
	defer tpm.Close()

	// Determine if the TPM needs provisioning, i.e. if nvIndexHandle exists.
	// This is done by attempting to NVReadPublic(nvIndexHandle) and looking
	// for a badHandleError response.
	// XXX Is this the best way to do this? In any case, this is the actual
	// error return code that I see on a freshly started "clean" swtpm in this
	// case.
	needsProvisioning := false
	badHandleError := tpm2.HandleError{tpm2.RCHandle, 1}
	_, err = tpm2.NVReadPublic(tpm, nvIndexHandle)
	if err == badHandleError {
		needsProvisioning = true
	} else if err != nil {
		return nil, fmt.Errorf("Error in NVReadPublic(0x%x): %v", nvIndexHandle, err)
	}

	if needsProvisioning {
		// "Provision" nvIndexHandle with nvIndexSize random bytes generated by
		// the TPM.
		log.Printf("TPM: nvIndexHandle(0x%x) does not exist, provisioning it",
			nvIndexHandle)
		nvIndexData, err := tpm2.GetRandom(tpm, nvIndexSize)
		if err != nil {
			return nil, fmt.Errorf("Error in GetRandom(): %v", err)
		}

		err = tpm2.NVDefineSpace(tpm, nvAuthHandle, nvIndexHandle, nvAuthPassword,
			nvIndexPassword, nil, nvIndexAttr, nvIndexSize)
		if err != nil {
			return nil, fmt.Errorf("Error in NVDefineSpace(0x%x): %v",
				nvIndexHandle, err)
		}

		// 0: offset.
		err = tpm2.NVWrite(tpm, nvAuthHandle, nvIndexHandle, nvIndexPassword,
			nvIndexData, 0)
		if err != nil {
			return nil, fmt.Errorf("Error in NVWrite(0x%x): %v", nvIndexHandle, err)
		}
	}

	// 0: blockSize, translates internally to TPM_PT_NV_BUFFER_MAX.
	data, err := tpm2.NVReadEx(tpm, nvIndexHandle, nvAuthHandle, nvAuthPassword,
		0)
	if err != nil {
		return nil, fmt.Errorf("Error in NVRead(0x%x): %v", nvIndexHandle, err)
	}
	if len(data) != int(nvIndexSize) {
		return nil, fmt.Errorf("Expected %d bytes, got only %d bytes",
			nvIndexSize, len(data))
	}

	return data, nil
}

// tpmDeleteDeviceId can be used to delete an existing "Device ID" NV Index
// from the TPM.
//
// tpmPath is the path to the TPM character device, normally "/dev/tpm0".
//
// XXX: I don't expect this functionality to be in any "final" version of a
// TPM-based design, at least not in this form, but it is currently useful for
// testing to be able to delete the "Device ID" via the "Factory reset" API
// endpoint.
func tpmDeleteDeviceId(tpmPath string) error {
	tpm, err := tpm2.OpenTPM(tpmPath)
	if err != nil {
		return fmt.Errorf("Error in OpenTPM(%s): %v", tpmPath, err)
	}
	defer tpm.Close()

	return tpm2.NVUndefineSpace(tpm, nvAuthPassword, nvAuthHandle, nvIndexHandle)
}
